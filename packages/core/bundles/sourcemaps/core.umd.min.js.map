{"version":3,"names":[],"mappings":"","sources":["core.umd.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('tslib'), require('reflect-metadata')) :\n\ttypeof define === 'function' && define.amd ? define(['tslib', 'reflect-metadata'], factory) :\n\t(global.core = global.core || {}, global.core.umd = global.core.umd || {}, global.core.umd.js = factory(global.tslib_1,global.Reflect));\n}(this, (function (tslib_1,reflectMetadata) { 'use strict';\n\ntslib_1 = tslib_1 && tslib_1.hasOwnProperty('default') ? tslib_1['default'] : tslib_1;\nreflectMetadata = reflectMetadata && reflectMetadata.hasOwnProperty('default') ? reflectMetadata['default'] : reflectMetadata;\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n}\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\nvar lang_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\nvar lang;\n(function (lang) {\n    /**\n     * get object keys.\n     *\n     * @param {*} target\n     * @returns {string[]}\n     */\n    function keys(target) {\n        if (typeCheck.isObject(target)) {\n            if (typeCheck.isFunction(Object.keys)) {\n                return Object.keys(target);\n            }\n            else {\n                var keys_1 = [];\n                for (var name_1 in target) {\n                    keys_1.push(name_1);\n                }\n                return keys_1;\n            }\n        }\n        return [];\n    }\n    lang.keys = keys;\n    /**\n     * values of target object.\n     *\n     * @export\n     * @param {*} target\n     * @returns {any[]}\n     */\n    function values(target) {\n        if (typeCheck.isObject(target)) {\n            if (typeCheck.isFunction(Object.values)) {\n                return Object.values(target);\n            }\n            else {\n                var values_1 = [];\n                for (var name_2 in target) {\n                    values_1.push(target[name_2]);\n                }\n                return values_1;\n            }\n        }\n        return [];\n    }\n    lang.values = values;\n    /**\n     * assign\n     *\n     * @export\n     * @template T\n     * @param {T} target\n     * @param {...any[]} source\n     * @returns {T}\n     */\n    function assign(target, source1, source2, sources) {\n        if (sources && sources.length) {\n            sources.unshift(source2 || {});\n            sources.unshift(source1 || {});\n            return objectAssign.apply(void 0, [target].concat(sources));\n        }\n        else if (source2) {\n            return objectAssign(target, source1 || {}, source2);\n        }\n        else {\n            return objectAssign(target, source1 || {});\n        }\n    }\n    lang.assign = assign;\n    /**\n     * create an new object from target object omit some field.\n     *\n     * @export\n     * @param {ObjectMap<any>} target\n     * @param {...string[]} fields\n     * @returns {*}\n     */\n    function omit(target) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        if (typeCheck.isObject(target)) {\n            var result_1 = {};\n            keys(target).forEach(function (key) {\n                if (fields.indexOf(key) < 0) {\n                    result_1[key] = target[key];\n                }\n            });\n            return result_1;\n        }\n        else {\n            return target;\n        }\n    }\n    lang.omit = omit;\n    /**\n     * object has field or not.\n     *\n     * @export\n     * @param {ObjectMap<any>} target\n     * @returns\n     */\n    function hasField(target) {\n        return keys(target).length > 0;\n    }\n    lang.hasField = hasField;\n    /**\n     * for in opter for object or array.\n     *\n     * @export\n     * @template T\n     * @param {(ObjectMap<T> | T[])} target\n     * @param {(item: T, idx?: number|string) => void|boolean} iterator\n     */\n    function forIn(target, iterator) {\n        if (typeCheck.isArray(target)) {\n            target.forEach(iterator);\n        }\n        else if (typeCheck.isObject(target)) {\n            keys(target).forEach(function (key, idx) {\n                iterator(target[key], key);\n            });\n        }\n    }\n    lang.forIn = forIn;\n    /**\n     * find\n     *\n     * @template T\n     * @param {(ObjectMap<T> | T[])} target\n     * @param {((item: T, idx?: number | string) => boolean)} express\n     */\n    function find(target, express) {\n        var item;\n        forIn(target, function (it, idx) {\n            if (!item) {\n                if (express(it, idx)) {\n                    item = it;\n                    return false;\n                }\n                return true;\n            }\n            else {\n                return false;\n            }\n        });\n    }\n    lang.find = find;\n    /**\n     * get target type parent class.\n     *\n     * @export\n     * @param {Type<any>} target\n     * @returns {Type<any>}\n     */\n    function getParentClass(target) {\n        var p = Reflect.getPrototypeOf(target.prototype);\n        return typeCheck.isClass(p) ? p : p.constructor;\n    }\n    lang.getParentClass = getParentClass;\n    /**\n     * first.\n     *\n     * @export\n     * @template T\n     * @param {T[]} list\n     * @returns {T}\n     */\n    function first(list) {\n        if (typeCheck.isArray(list) && list.length) {\n            return list[0];\n        }\n        return null;\n    }\n    lang.first = first;\n    /**\n     * last.\n     *\n     * @export\n     * @template T\n     * @param {T[]} list\n     * @returns {T}\n     */\n    function last(list) {\n        if (typeCheck.isArray(list) && list.length) {\n            return list[list.length - 1];\n        }\n        return null;\n    }\n    lang.last = last;\n})(lang = exports.lang || (exports.lang = {}));\n\n\n\n\n});\n\nunwrapExports(lang_1);\nvar lang_2 = lang_1.lang;\n\nvar typeCheck = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * check target is function or not.\n *\n * @export\n * @param {*} target\n * @returns\n */\nfunction isFunction(target) {\n    if (!target) {\n        return false;\n    }\n    return typeof target === 'function';\n}\nexports.isFunction = isFunction;\n/**\n * check Abstract class with @Abstract or not\n *\n * @export\n * @param {*} target\n * @returns {target is AbstractType<any>}\n */\nfunction isAbstractDecoratorClass(target) {\n    if (!isFunction(target)) {\n        return false;\n    }\n    if (Reflect.hasOwnMetadata('@Abstract', target)) {\n        return true;\n    }\n    return false;\n}\nexports.isAbstractDecoratorClass = isAbstractDecoratorClass;\n/**\n * get class name.\n *\n * @export\n * @param {AbstractType<any>} classType\n * @returns {string}\n */\nfunction getClassName(classType) {\n    if (!isFunction(classType)) {\n        return '';\n    }\n    if (/^[a-z]$/.test(classType.name)) {\n        return classType.classAnnations ? classType.classAnnations.name : classType.name;\n    }\n    return classType.name;\n}\nexports.getClassName = getClassName;\n/**\n * check target is class or not.\n *\n * @export\n * @param {*} target\n * @returns\n */\nfunction isClass(target) {\n    if (!isFunction(target)) {\n        return false;\n    }\n    if (target.prototype) {\n        if (!target.name || target.name === 'Object') {\n            return false;\n        }\n        if (Reflect.hasOwnMetadata('@Abstract', target)) {\n            return false;\n        }\n        var type = target;\n        // for uglify\n        if (/^[a-z]$/.test(type.name)) {\n            if (type.classAnnations && type.classAnnations.name) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            if (type.classAnnations && isString(type.classAnnations.name)) {\n                return true;\n            }\n            if (!/^[A-Z@]/.test(target.name)) {\n                return false;\n            }\n        }\n        // for IE 8, 9\n        if (!isNodejsEnv() && /MSIE [6-9]/.test(navigator.userAgent)) {\n            return true;\n        }\n        try {\n            target.arguments && target.caller;\n            return false;\n        }\n        catch (e) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isClass = isClass;\n/**\n * is run in nodejs or not.\n *\n * @export\n * @returns {boolean}\n */\nfunction isNodejsEnv() {\n    return (typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined');\n}\nexports.isNodejsEnv = isNodejsEnv;\n/**\n * check target is token or not.\n *\n * @export\n * @param {*} target\n * @returns {target is Token<any>}\n */\nfunction isToken(target) {\n    if (!target) {\n        return false;\n    }\n    if (isString(target) || isSymbol(target) || isClass(target) || (isObject(target) && target instanceof Registration_1.Registration)) {\n        return true;\n    }\n    return false;\n}\nexports.isToken = isToken;\n/**\n * is target promise or not.\n *\n * @export\n * @param {*} target\n * @returns {target is Promise<any>}\n */\nfunction isPromise(target) {\n    if (!target) {\n        return false;\n    }\n    if (isFunction(target.then) && isFunction(target.catch)) {\n        return true;\n    }\n    return false;\n}\nexports.isPromise = isPromise;\n/**\n * is target rxjs observable or not.\n *\n * @export\n * @param {*} target\n * @returns {boolean}\n */\nfunction isObservable(target) {\n    if (!target && !isObject(target)) {\n        return false;\n    }\n    if (isFunction(target.subscribe) && isFunction(target.toPromise)) {\n        return true;\n    }\n    return false;\n}\nexports.isObservable = isObservable;\n/**\n * is target base object or not.\n * eg. {}, have not self constructor;\n * @export\n * @param {*} target\n * @returns {target is Promise<any>}\n */\nfunction isBaseObject(target) {\n    if (!target) {\n        return false;\n    }\n    if (target.constructor && target.constructor.name === 'Object') {\n        return true;\n    }\n    return false;\n}\nexports.isBaseObject = isBaseObject;\n/**\n * is metadata object or not.\n *\n * @export\n * @param {any} target\n * @param {string[]} [props]\n * @param {string[]} [extendsProps]\n * @returns {boolean}\n */\nfunction isMetadataObject(target, props, extendsProps) {\n    if (!target) {\n        return false;\n    }\n    if (isBaseType(target) || isSymbol(target) || target instanceof Registration_1.Registration || target instanceof RegExp || target instanceof Date) {\n        return false;\n    }\n    if (target.constructor && target.constructor.name !== 'Object') {\n        return false;\n    }\n    props = props || [];\n    if (extendsProps) {\n        props = extendsProps.concat(props);\n    }\n    if (props.length) {\n        return lang_1.lang.keys(target).some(function (n) { return props.indexOf(n) > 0; });\n    }\n    return true;\n}\nexports.isMetadataObject = isMetadataObject;\n/**\n * check object is class metadata or not.\n *\n * @export\n * @param {any} target\n * @param {string[]} [extendsProps]\n * @returns {boolean}\n */\nfunction isClassMetadata(target, extendsProps) {\n    return isMetadataObject(target, ['singleton', 'provide', 'alias', 'type'], extendsProps);\n}\nexports.isClassMetadata = isClassMetadata;\n/**\n * check object is param metadata or not.\n *\n * @export\n * @param {any} target\n * @param {string[]} [extendsProps]\n * @returns {boolean}\n */\nfunction isParamMetadata(target, extendsProps) {\n    return isMetadataObject(target, ['type', 'provider', 'index'], extendsProps);\n}\nexports.isParamMetadata = isParamMetadata;\n/**\n * check object is param prop metadata or not.\n *\n * @export\n * @param {any} target\n * @param {string[]} [extendsProps]\n * @returns {boolean}\n */\nfunction isParamPropMetadata(target, extendsProps) {\n    return isMetadataObject(target, ['type', 'provider', 'index'], extendsProps);\n}\nexports.isParamPropMetadata = isParamPropMetadata;\n/**\n * check object is property metadata or not.\n *\n * @export\n * @param {any} target\n * @param {string[]} [extendsProps]\n * @returns {boolean}\n */\nfunction isPropertyMetadata(target, extendsProps) {\n    return isMetadataObject(target, ['type', 'provider'], extendsProps);\n}\nexports.isPropertyMetadata = isPropertyMetadata;\n/**\n * check target is string or not.\n *\n * @export\n * @param {*} target\n * @returns {target is string}\n */\nfunction isString(target) {\n    return typeof target === 'string';\n}\nexports.isString = isString;\n/**\n * check target is boolean or not.\n *\n * @export\n * @param {*} target\n * @returns {target is boolean}\n */\nfunction isBoolean(target) {\n    return typeof target === 'boolean' || (target === true || target === false);\n}\nexports.isBoolean = isBoolean;\n/**\n * check target is number or not.\n *\n * @export\n * @param {*} target\n * @returns {target is number}\n */\nfunction isNumber(target) {\n    return typeof target === 'number';\n}\nexports.isNumber = isNumber;\n/**\n * check target is undefined or not.\n *\n * @export\n * @param {*} target\n * @returns {target is undefined}\n */\nfunction isUndefined(target) {\n    return typeof target === 'undefined' || target === undefined;\n}\nexports.isUndefined = isUndefined;\n/**\n * check target is unll or not.\n *\n * @export\n * @param {*} target\n * @returns {target is null}\n */\nfunction isNull(target) {\n    return target === null;\n}\nexports.isNull = isNull;\n/**\n * check target is array or not.\n *\n * @export\n * @param {*} target\n * @returns {target is Array<any>}\n */\nfunction isArray(target) {\n    return Array.isArray(target);\n}\nexports.isArray = isArray;\n/**\n * check target is object or not.\n *\n * @export\n * @param {*} target\n * @returns {target is object}\n */\nfunction isObject(target) {\n    var type = typeof target;\n    return target != null && (type === 'object' || type === 'function');\n}\nexports.isObject = isObject;\n/**\n * check target is date or not.\n *\n * @export\n * @param {*} target\n * @returns {target is Date}\n */\nfunction isDate(target) {\n    return isObject(target) && target instanceof Date;\n}\nexports.isDate = isDate;\n/**\n * check target is symbol or not.\n *\n * @export\n * @param {*} target\n * @returns {target is Symbol}\n */\nfunction isSymbol(target) {\n    return typeof target === 'symbol' || (isObject(target) && /^Symbol\\(/.test(target.toString()));\n}\nexports.isSymbol = isSymbol;\n/**\n * check target is regexp or not.\n *\n * @export\n * @param {*} target\n * @returns {target is RegExp}\n */\nfunction isRegExp(target) {\n    return target && target instanceof RegExp;\n}\nexports.isRegExp = isRegExp;\n/**\n * is base type or not.\n *\n * @export\n * @param {*} target\n * @returns {boolean}\n */\nfunction isBaseType(target) {\n    return isNull(target) || isUndefined(target) || isBoolean(target) || isString(target) || isNumber(target);\n}\nexports.isBaseType = isBaseType;\n\n\n\n\n});\n\nunwrapExports(typeCheck);\nvar typeCheck_1 = typeCheck.isFunction;\nvar typeCheck_2 = typeCheck.isAbstractDecoratorClass;\nvar typeCheck_3 = typeCheck.getClassName;\nvar typeCheck_4 = typeCheck.isClass;\nvar typeCheck_5 = typeCheck.isNodejsEnv;\nvar typeCheck_6 = typeCheck.isToken;\nvar typeCheck_7 = typeCheck.isPromise;\nvar typeCheck_8 = typeCheck.isObservable;\nvar typeCheck_9 = typeCheck.isBaseObject;\nvar typeCheck_10 = typeCheck.isMetadataObject;\nvar typeCheck_11 = typeCheck.isClassMetadata;\nvar typeCheck_12 = typeCheck.isParamMetadata;\nvar typeCheck_13 = typeCheck.isParamPropMetadata;\nvar typeCheck_14 = typeCheck.isPropertyMetadata;\nvar typeCheck_15 = typeCheck.isString;\nvar typeCheck_16 = typeCheck.isBoolean;\nvar typeCheck_17 = typeCheck.isNumber;\nvar typeCheck_18 = typeCheck.isUndefined;\nvar typeCheck_19 = typeCheck.isNull;\nvar typeCheck_20 = typeCheck.isArray;\nvar typeCheck_21 = typeCheck.isObject;\nvar typeCheck_22 = typeCheck.isDate;\nvar typeCheck_23 = typeCheck.isSymbol;\nvar typeCheck_24 = typeCheck.isRegExp;\nvar typeCheck_25 = typeCheck.isBaseType;\n\nvar MapSet_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * object map set.\n *\n * @export\n * @class MapSet\n * @template TKey\n * @template TVal\n */\nvar ObjectMapSet = /** @class */ (function () {\n    function ObjectMapSet() {\n        this.valueMap = {};\n        this.keyMap = {};\n    }\n    ObjectMapSet.prototype.clear = function () {\n        this.valueMap = {};\n        this.keyMap = {};\n    };\n    ObjectMapSet.prototype.getTypeKey = function (key) {\n        var strKey = '';\n        if (typeCheck.isString(key)) {\n            strKey = key;\n        }\n        else if (typeCheck.isFunction(key)) {\n            strKey = key.name;\n        }\n        else {\n            strKey = key.toString();\n        }\n        return strKey;\n    };\n    ObjectMapSet.prototype.keys = function () {\n        return lang_1.lang.values(this.keyMap);\n    };\n    ObjectMapSet.prototype.values = function () {\n        return lang_1.lang.values(this.valueMap);\n    };\n    ObjectMapSet.prototype.delete = function (key) {\n        var strkey = this.getTypeKey(key).toString();\n        try {\n            delete this.keyMap[strkey];\n            delete this.valueMap[strkey];\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    };\n    ObjectMapSet.prototype.forEach = function (callbackfn, thisArg) {\n        var _this = this;\n        lang_1.lang.forIn(this.keyMap, function (val, name) {\n            callbackfn(_this.valueMap[name], val, _this);\n        });\n    };\n    ObjectMapSet.prototype.get = function (key) {\n        var strKey = this.getTypeKey(key);\n        return this.valueMap[strKey];\n    };\n    ObjectMapSet.prototype.has = function (key) {\n        var strKey = this.getTypeKey(key);\n        return !typeCheck.isUndefined(this.keyMap[strKey]);\n    };\n    ObjectMapSet.prototype.set = function (key, value) {\n        var strKey = this.getTypeKey(key);\n        this.keyMap[strKey] = key;\n        this.valueMap[strKey] = value;\n        return this;\n    };\n    Object.defineProperty(ObjectMapSet.prototype, \"size\", {\n        get: function () {\n            return lang_1.lang.keys(this.keyMap).length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObjectMapSet.classAnnations = { \"name\": \"ObjectMapSet\", \"params\": { \"constructor\": [], \"clear\": [], \"getTypeKey\": [\"key\"], \"keys\": [], \"values\": [], \"delete\": [\"key\"], \"forEach\": [\"callbackfn\", \"thisArg\"], \"get\": [\"key\"], \"has\": [\"key\"], \"set\": [\"key\", \"value\"] } };\n    return ObjectMapSet;\n}());\nexports.ObjectMapSet = ObjectMapSet;\n/**\n * map set.\n *\n * @export\n * @class MapSet\n * @template TKey\n * @template TVal\n */\nvar MapSet = /** @class */ (function () {\n    function MapSet() {\n        this.map = typeCheck.isClass(Map) ? new Map() : new ObjectMapSet();\n    }\n    MapSet.prototype.keys = function () {\n        return this.map.keys();\n    };\n    MapSet.prototype.values = function () {\n        return this.map.values();\n    };\n    MapSet.prototype.clear = function () {\n        this.map.clear();\n    };\n    MapSet.prototype.delete = function (key) {\n        return this.map.delete(key);\n    };\n    MapSet.prototype.forEach = function (callbackfn, thisArg) {\n        var map = this.map;\n        map.forEach(callbackfn, thisArg);\n    };\n    MapSet.prototype.get = function (key) {\n        return this.map.get(key);\n    };\n    MapSet.prototype.has = function (key) {\n        return this.map.has(key);\n    };\n    MapSet.prototype.set = function (key, value) {\n        this.map.set(key, value);\n        return this;\n    };\n    Object.defineProperty(MapSet.prototype, \"size\", {\n        get: function () {\n            return this.map.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MapSet.classAnnations = { \"name\": \"MapSet\", \"params\": { \"constructor\": [], \"keys\": [], \"values\": [], \"clear\": [], \"delete\": [\"key\"], \"forEach\": [\"callbackfn\", \"thisArg\"], \"get\": [\"key\"], \"has\": [\"key\"], \"set\": [\"key\", \"value\"] } };\n    return MapSet;\n}());\nexports.MapSet = MapSet;\n\n\n\n\n});\n\nunwrapExports(MapSet_1);\nvar MapSet_2 = MapSet_1.ObjectMapSet;\nvar MapSet_3 = MapSet_1.MapSet;\n\nvar PromiseUtil_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * defer\n *\n * @export\n * @class Defer\n * @template T\n */\nvar Defer = /** @class */ (function () {\n    function Defer() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    }\n    Defer.create = function (then) {\n        var defer = new Defer();\n        if (then) {\n            defer.promise = defer.promise.then(then);\n            return defer;\n        }\n        else {\n            return defer;\n        }\n    };\n    Defer.classAnnations = { \"name\": \"Defer\", \"params\": { \"create\": [\"then\"], \"constructor\": [] } };\n    return Defer;\n}());\nexports.Defer = Defer;\nvar PromiseUtil;\n(function (PromiseUtil) {\n    /**\n     * foreach opter for promises.\n     *\n     * @export\n     * @template T\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\n     * @param {Express<T, any>} express\n     * @param {T} [defVal]\n     * @returns\n     */\n    function forEach(promises, express, defVal) {\n        var defer = new Defer();\n        var pf = Promise.resolve(defVal);\n        var length = promises ? promises.length : 0;\n        if (length) {\n            promises.forEach(function (p, idx) {\n                pf = pf.then(function (v) { return typeCheck.isFunction(p) ? p(v) : p; })\n                    .then(function (data) {\n                    if (express(data) === false) {\n                        defer.resolve('complete');\n                        return Promise.reject('complete');\n                    }\n                    else if (idx === length - 1) {\n                        defer.resolve('complete');\n                        return Promise.reject('complete');\n                    }\n                    return data;\n                });\n            });\n            pf.catch(function (err) {\n                return err;\n            });\n        }\n        else {\n            defer.reject('array empty.');\n        }\n        return defer.promise;\n    }\n    PromiseUtil.forEach = forEach;\n    /**\n     * run promise step by step.\n     *\n     * @export\n     * @template T\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\n     * @returns\n     */\n    function step(promises) {\n        var result = Promise.resolve(null);\n        promises.forEach(function (p) {\n            result = result.then(function (v) { return typeCheck.isFunction(p) ? p(v) : p; });\n        });\n        return result;\n    }\n    PromiseUtil.step = step;\n    /**\n     * find first validate value from promises.\n     *\n     * @export\n     * @template T\n     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\n     * @param {Express<T, boolean>} validate\n     * @returns\n     */\n    function find(promises, filter, defVal) {\n        var defer = new Defer();\n        forEach(promises, function (val) {\n            if (filter(val)) {\n                defer.resolve(val);\n                return false;\n            }\n            return true;\n        }, defVal)\n            .then(function () { return defer.resolve(null); })\n            .catch(function () {\n            defer.resolve(null);\n        });\n        return defer.promise;\n    }\n    PromiseUtil.find = find;\n})(PromiseUtil = exports.PromiseUtil || (exports.PromiseUtil = {}));\n\n\n\n\n});\n\nunwrapExports(PromiseUtil_1);\nvar PromiseUtil_2 = PromiseUtil_1.Defer;\nvar PromiseUtil_3 = PromiseUtil_1.PromiseUtil;\n\nvar utils = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(typeCheck, exports);\ntslib_1.__exportStar(MapSet_1, exports);\ntslib_1.__exportStar(lang_1, exports);\ntslib_1.__exportStar(PromiseUtil_1, exports);\n\n\n\n\n});\n\nunwrapExports(utils);\n\nvar Registration_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * inject token.\n * @export\n * @class Registration\n * @template T\n */\nvar Registration = /** @class */ (function () {\n    /**\n     * Creates an instance of Registration.\n     * @param {(Token<T> | Token<any>)} provideType\n     * @param {string} desc\n     * @memberof Registration\n     */\n    function Registration(provideType, desc) {\n        this.type = 'Reg';\n        if (provideType instanceof Registration) {\n            this.classType = provideType.getProvide();\n            var pdec = provideType.getDesc();\n            if (pdec && desc && pdec !== desc) {\n                this.desc = pdec + '_' + desc;\n            }\n            else {\n                this.desc = desc;\n            }\n        }\n        else {\n            this.classType = provideType;\n            this.desc = desc;\n        }\n    }\n    Registration.prototype.getProvide = function () {\n        return this.classType;\n    };\n    /**\n     * get class.\n     *\n     * @returns\n     * @memberof Registration\n     */\n    Registration.prototype.getClass = function () {\n        if (utils.isClass(this.classType)) {\n            return this.classType;\n        }\n        return null;\n    };\n    /**\n     * get desc.\n     *\n     * @returns\n     * @memberof Registration\n     */\n    Registration.prototype.getDesc = function () {\n        return this.desc;\n    };\n    /**\n     * to string.\n     *\n     * @returns {string}\n     * @memberof Registration\n     */\n    Registration.prototype.toString = function () {\n        var name = '';\n        if (utils.isFunction(this.classType)) {\n            name = \"{\" + utils.getClassName(this.classType) + \"}\";\n        }\n        else if (this.classType) {\n            name = this.classType.toString();\n        }\n        return (this.type + \" \" + name + \" \" + this.desc).trim();\n    };\n    Registration.classAnnations = { \"name\": \"Registration\", \"params\": { \"constructor\": [\"provideType\", \"desc\"], \"getProvide\": [], \"getClass\": [], \"getDesc\": [], \"toString\": [] } };\n    return Registration;\n}());\nexports.Registration = Registration;\n\n\n\n\n});\n\nunwrapExports(Registration_1);\nvar Registration_2 = Registration_1.Registration;\n\nvar InjectToken_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * inject token.\n *\n * @export\n * @class InjectToken\n * @extends {Registration<T>}\n * @template T\n */\nvar InjectToken = /** @class */ (function (_super) {\n    tslib_1.__extends(InjectToken, _super);\n    function InjectToken(desc) {\n        return _super.call(this, desc, '') || this;\n    }\n    InjectToken.classAnnations = { \"name\": \"InjectToken\", \"params\": { \"constructor\": [\"desc\"] } };\n    return InjectToken;\n}(Registration_1.Registration));\nexports.InjectToken = InjectToken;\n\n\n\n\n});\n\nunwrapExports(InjectToken_1);\nvar InjectToken_2 = InjectToken_1.InjectToken;\n\nvar IContainer = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * IContainer token.\n * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.\n */\nexports.ContainerToken = new InjectToken_1.InjectToken('DI_IContainer');\n\n\n\n\n});\n\nunwrapExports(IContainer);\nvar IContainer_1 = IContainer.ContainerToken;\n\nvar types = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * State of type in ioc.\n *\n * @export\n * @enum {number}\n */\nvar IocState;\n(function (IocState) {\n    IocState[\"design\"] = \"design\";\n    IocState[\"runtime\"] = \"runtime\";\n})(IocState = exports.IocState || (exports.IocState = {}));\n/**\n * iterate way.\n *\n * @export\n * @enum {number}\n */\nvar Mode;\n(function (Mode) {\n    /**\n     * route up. iterate in parents.\n     */\n    Mode[Mode[\"route\"] = 1] = \"route\";\n    /**\n     * iterate in children.\n     */\n    Mode[Mode[\"children\"] = 2] = \"children\";\n    /**\n     * iterate as tree map. node first\n     */\n    Mode[Mode[\"traverse\"] = 3] = \"traverse\";\n    /**\n     * iterate as tree map. node last\n     */\n    Mode[Mode[\"traverseLast\"] = 4] = \"traverseLast\";\n})(Mode = exports.Mode || (exports.Mode = {}));\n\n\n\n\n});\n\nunwrapExports(types);\nvar types_1 = types.IocState;\nvar types_2 = types.Mode;\n\nvar IMethodAccessor = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * IMethodAccessor interface symbol.\n * it is a symbol id, you can register yourself MethodAccessor for this.\n */\nexports.MethodAccessorToken = new InjectToken_1.InjectToken('DI_IMethodAccessor');\n\n\n\n\n});\n\nunwrapExports(IMethodAccessor);\nvar IMethodAccessor_1 = IMethodAccessor.MethodAccessorToken;\n\nvar NullComponent_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * null component.\n *\n * @export\n * @class NullComponent\n * @implements {IComponent}\n */\nvar NullComponent = /** @class */ (function () {\n    function NullComponent() {\n    }\n    NullComponent.prototype.isEmpty = function () {\n        return true;\n    };\n    NullComponent.prototype.add = function (action) {\n        return this;\n    };\n    NullComponent.prototype.remove = function (action) {\n        return this;\n    };\n    NullComponent.prototype.find = function (express, mode) {\n        return exports.NullNode;\n    };\n    NullComponent.prototype.filter = function (express, mode) {\n        return [];\n    };\n    NullComponent.prototype.each = function (express, mode) {\n    };\n    NullComponent.prototype.trans = function (express) {\n    };\n    NullComponent.prototype.transAfter = function (express) {\n    };\n    NullComponent.prototype.routeUp = function (express) {\n    };\n    NullComponent.prototype.equals = function (node) {\n        return node === exports.NullNode;\n    };\n    NullComponent.prototype.empty = function () {\n        return exports.NullNode;\n    };\n    NullComponent.classAnnations = { \"name\": \"NullComponent\", \"params\": { \"isEmpty\": [], \"add\": [\"action\"], \"remove\": [\"action\"], \"find\": [\"express\", \"mode\"], \"filter\": [\"express\", \"mode\"], \"each\": [\"express\", \"mode\"], \"trans\": [\"express\"], \"transAfter\": [\"express\"], \"routeUp\": [\"express\"], \"equals\": [\"node\"], \"empty\": [] } };\n    return NullComponent;\n}());\nexports.NullComponent = NullComponent;\n/**\n * Null node\n */\nexports.NullNode = new NullComponent();\n\n\n\n\n});\n\nunwrapExports(NullComponent_1);\nvar NullComponent_2 = NullComponent_1.NullComponent;\nvar NullComponent_3 = NullComponent_1.NullNode;\n\nvar GComposite_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * generics composite\n *\n * @export\n * @class GComposite\n * @implements {GComponent<T>}\n * @template T\n */\nvar GComposite = /** @class */ (function () {\n    function GComposite(name) {\n        this.name = name;\n        this.children = [];\n    }\n    GComposite.prototype.add = function (node) {\n        node.parent = this;\n        this.children.push(node);\n        return this;\n    };\n    GComposite.prototype.remove = function (node) {\n        var component;\n        if (utils.isString(node)) {\n            component = this.find(function (cmp) { return utils.isString(node) ? cmp.name === node : cmp.equals(node); });\n        }\n        else if (node) {\n            component = node;\n        }\n        else {\n            component = this;\n        }\n        if (!component.parent) {\n            return this;\n        }\n        else if (this.equals(component.parent)) {\n            this.children.splice(this.children.indexOf(component), 1);\n            component.parent = null;\n            return this;\n        }\n        else {\n            component.parent.remove(component);\n            return null;\n        }\n    };\n    GComposite.prototype.find = function (express, mode) {\n        var component;\n        this.each(function (item) {\n            if (component) {\n                return false;\n            }\n            var isFinded = utils.isFunction(express) ? express(item) : express === (item);\n            if (isFinded) {\n                component = item;\n                return false;\n            }\n            return true;\n        }, mode);\n        return (component || this.empty());\n    };\n    GComposite.prototype.filter = function (express, mode) {\n        var nodes = [];\n        this.each(function (item) {\n            if (express(item)) {\n                nodes.push(item);\n            }\n        }, mode);\n        return nodes;\n    };\n    GComposite.prototype.each = function (iterate, mode) {\n        mode = mode || types.Mode.traverse;\n        var r;\n        switch (mode) {\n            case types.Mode.route:\n                r = this.routeUp(iterate);\n                break;\n            case types.Mode.children:\n                r = this.eachChildren(iterate);\n                break;\n            case types.Mode.traverse:\n                r = this.trans(iterate);\n                break;\n            case types.Mode.traverseLast:\n                r = this.transAfter(iterate);\n                break;\n            default:\n                r = this.trans(iterate);\n                break;\n        }\n        return r;\n    };\n    GComposite.prototype.eachChildren = function (iterate) {\n        (this.children || []).forEach(function (item) {\n            return iterate(item);\n        });\n    };\n    /**\n     *do express work in routing.\n     *\n     *@param {Express<T, void | boolean>} express\n     *\n     *@memberOf IComponent\n     */\n    GComposite.prototype.routeUp = function (iterate) {\n        var curr = this;\n        if (iterate(curr) === false) {\n            return false;\n        }\n        \n        if (this.parent && this.parent.routeUp) {\n            return this.parent.routeUp(iterate);\n        }\n    };\n    /**\n     *translate all sub context to do express work.\n     *\n     *@param {Express<T, void | boolean>} express\n     *\n     *@memberOf IComponent\n     */\n    GComposite.prototype.trans = function (express) {\n        var curr = this;\n        if (express(curr) === false) {\n            return false;\n        }\n        var children = this.children || [];\n        for (var i = 0; i < children.length; i++) {\n            var result = children[i].trans(express);\n            if (result === false) {\n                return result;\n            }\n        }\n        return true;\n    };\n    GComposite.prototype.transAfter = function (express) {\n        var children = this.children || [];\n        for (var i = 0; i < children.length; i++) {\n            var result = children[i].transAfter(express);\n            if (result === false) {\n                return false;\n            }\n        }\n        var curr = this;\n        if (express(curr) === false) {\n            return false;\n        }\n        return true;\n    };\n    GComposite.prototype.equals = function (node) {\n        return this === node;\n    };\n    GComposite.prototype.empty = function () {\n        return NullComponent_1.NullNode;\n    };\n    GComposite.prototype.isEmpty = function () {\n        return this.equals(this.empty());\n    };\n    GComposite.classAnnations = { \"name\": \"GComposite\", \"params\": { \"constructor\": [\"name\"], \"add\": [\"node\"], \"remove\": [\"node\"], \"find\": [\"express\", \"mode\"], \"filter\": [\"express\", \"mode\"], \"each\": [\"iterate\", \"mode\"], \"eachChildren\": [\"iterate\"], \"routeUp\": [\"iterate\"], \"trans\": [\"express\"], \"transAfter\": [\"express\"], \"equals\": [\"node\"], \"empty\": [], \"isEmpty\": [] } };\n    return GComposite;\n}());\nexports.GComposite = GComposite;\n\n\n\n\n});\n\nunwrapExports(GComposite_1);\nvar GComposite_2 = GComposite_1.GComposite;\n\nvar Composite_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * compoiste.\n *\n * @export\n * @class Composite\n * @implements {IComponent}\n */\nvar Composite = /** @class */ (function (_super) {\n    tslib_1.__extends(Composite, _super);\n    function Composite(name) {\n        return _super.call(this, name) || this;\n    }\n    Composite.prototype.find = function (express, mode) {\n        return _super.prototype.find.call(this, express, mode);\n    };\n    Composite.prototype.filter = function (express, mode) {\n        return _super.prototype.filter.call(this, express, mode);\n    };\n    Composite.prototype.each = function (express, mode) {\n        return _super.prototype.each.call(this, express, mode);\n    };\n    Composite.prototype.eachChildren = function (express) {\n        _super.prototype.eachChildren.call(this, express);\n    };\n    Composite.classAnnations = { \"name\": \"Composite\", \"params\": { \"constructor\": [\"name\"], \"find\": [\"express\", \"mode\"], \"filter\": [\"express\", \"mode\"], \"each\": [\"express\", \"mode\"], \"eachChildren\": [\"express\"] } };\n    return Composite;\n}(GComposite_1.GComposite));\nexports.Composite = Composite;\n\n\n\n\n});\n\nunwrapExports(Composite_1);\nvar Composite_2 = Composite_1.Composite;\n\nvar components = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(Composite_1, exports);\ntslib_1.__exportStar(GComposite_1, exports);\ntslib_1.__exportStar(NullComponent_1, exports);\n\n\n\n\n});\n\nunwrapExports(components);\n\nvar NullAction = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\nvar NullActionClass = /** @class */ (function (_super) {\n    tslib_1.__extends(NullActionClass, _super);\n    function NullActionClass() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    NullActionClass.prototype.insert = function (action, index) {\n        return this;\n    };\n    NullActionClass.prototype.execute = function (container, data, name) {\n    };\n    NullActionClass.prototype.empty = function () {\n        return exports.NullAction;\n    };\n    NullActionClass.classAnnations = { \"name\": \"NullActionClass\", \"params\": { \"insert\": [\"action\", \"index\"], \"execute\": [\"container\", \"data\", \"name\"], \"empty\": [] } };\n    return NullActionClass;\n}(components.NullComponent));\n/**\n * Null Action\n */\nexports.NullAction = new NullActionClass();\n\n\n\n\n});\n\nunwrapExports(NullAction);\nvar NullAction_1 = NullAction.NullAction;\n\nvar ActionComposite_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * action composite\n *\n * @export\n * @class ActionComposite\n * @extends {GComposite<ActionComponent>}\n * @implements {ActionComponent}\n */\nvar ActionComposite = /** @class */ (function (_super) {\n    tslib_1.__extends(ActionComposite, _super);\n    function ActionComposite(name) {\n        var _this = _super.call(this, name) || this;\n        _this.children = [];\n        return _this;\n    }\n    ActionComposite.prototype.insert = function (node, index) {\n        node.parent = this;\n        if (index < 0) {\n            index = 0;\n        }\n        else if (index >= this.children.length) {\n            index = this.children.length - 1;\n        }\n        this.children.splice(index, 0, node);\n        return this;\n    };\n    ActionComposite.prototype.execute = function (container, data, name) {\n        if (name) {\n            this.find(function (it) { return it.name === name; })\n                .execute(container, data);\n        }\n        else {\n            this.trans(function (action) {\n                if (action instanceof ActionComposite) {\n                    action.working(container, data);\n                }\n            });\n        }\n    };\n    ActionComposite.prototype.empty = function () {\n        return NullAction.NullAction;\n    };\n    ActionComposite.prototype.working = function (container, data) {\n        // do nothing.\n    };\n    ActionComposite.classAnnations = { \"name\": \"ActionComposite\", \"params\": { \"constructor\": [\"name\"], \"insert\": [\"node\", \"index\"], \"execute\": [\"container\", \"data\", \"name\"], \"empty\": [], \"working\": [\"container\", \"data\"] } };\n    return ActionComposite;\n}(components.GComposite));\nexports.ActionComposite = ActionComposite;\n\n\n\n\n});\n\nunwrapExports(ActionComposite_1);\nvar ActionComposite_2 = ActionComposite_1.ActionComposite;\n\nvar LifeState_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * life state.\n *\n * @export\n * @enum {number}\n */\nvar LifeState;\n(function (LifeState) {\n    /**\n     * before create constructor Args\n     */\n    LifeState[\"beforeCreateArgs\"] = \"beforeCreateArgs\";\n    /**\n     * before constructor advice action.\n     */\n    LifeState[\"beforeConstructor\"] = \"beforeConstructor\";\n    /**\n     * after constructor advice action.\n     */\n    LifeState[\"afterConstructor\"] = \"afterConstructor\";\n    /**\n     * on init.\n     */\n    LifeState[\"onInit\"] = \"onInit\";\n    /**\n     * after init.\n     */\n    LifeState[\"AfterInit\"] = \"AfterInit\";\n})(LifeState = exports.LifeState || (exports.LifeState = {}));\n\n\n\n\n});\n\nunwrapExports(LifeState_1);\nvar LifeState_2 = LifeState_1.LifeState;\n\nvar CoreActions_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * cores decorator actions\n *\n * @export\n */\nvar CoreActions;\n(function (CoreActions) {\n    /**\n     * the action bind parameter type form metadata.\n     */\n    CoreActions[\"bindParameterType\"] = \"bindParameterType\";\n    /**\n     * the action bind Property type from metadata.\n     */\n    CoreActions[\"bindPropertyType\"] = \"bindPropertyType\";\n    /**\n     * inject property action.\n     */\n    CoreActions[\"injectProperty\"] = \"injectProperty\";\n    /**\n     * class provider bind action.\n     */\n    CoreActions[\"bindProvider\"] = \"bindProvider\";\n    /**\n     * bind parameter provider action.\n     */\n    CoreActions[\"bindParameterProviders\"] = \"bindParameterProviders\";\n    /**\n     * cache action.\n     */\n    CoreActions[\"cache\"] = \"cache\";\n    /**\n     * component init action.  after constructor befor property inject.\n     */\n    CoreActions[\"componentBeforeInit\"] = \"componentBeforeInit\";\n    /**\n     * component on init hooks. after property inject.\n     */\n    CoreActions[\"componentInit\"] = \"componentInit\";\n    /**\n     * component after init hooks. after component init.\n     */\n    CoreActions[\"componentAfterInit\"] = \"componentAfterInit\";\n    /**\n     * singleton action.\n     */\n    CoreActions[\"singletion\"] = \"singletion\";\n    /**\n     * autorun action.\n     */\n    CoreActions[\"autorun\"] = \"autorun\";\n    /**\n     * method autorun action.\n     */\n    CoreActions[\"methodAutorun\"] = \"methodAutorun\";\n})(CoreActions = exports.CoreActions || (exports.CoreActions = {}));\n\n\n\n\n});\n\nunwrapExports(CoreActions_1);\nvar CoreActions_2 = CoreActions_1.CoreActions;\n\nvar ArgsIterator_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar ArgsIterator = /** @class */ (function () {\n    function ArgsIterator(args) {\n        this.args = args;\n        this.idx = -1;\n        this.metadata = null;\n    }\n    ArgsIterator.prototype.isCompeted = function () {\n        return this.idx >= this.args.length;\n    };\n    ArgsIterator.prototype.end = function () {\n        this.idx = this.args.length;\n    };\n    ArgsIterator.prototype.next = function (express) {\n        this.idx++;\n        if (this.isCompeted()) {\n            return null;\n        }\n        var arg = this.args[this.idx];\n        if (express.isMetadata && express.isMetadata(arg)) {\n            this.metadata = utils.lang.assign(this.metadata || {}, arg);\n            this.end();\n        }\n        else if (express.match(arg)) {\n            this.metadata = this.metadata || {};\n            express.setMetadata(this.metadata, arg);\n        }\n        else if (utils.isMetadataObject(arg)) { // when match failed then check is base metadata.\n            this.metadata = utils.lang.assign(this.metadata || {}, arg);\n            this.end();\n        }\n        else {\n            this.end();\n        }\n    };\n    ArgsIterator.prototype.getArgs = function () {\n        return this.args;\n    };\n    ArgsIterator.prototype.getMetadata = function () {\n        return this.metadata;\n    };\n    ArgsIterator.classAnnations = { \"name\": \"ArgsIterator\", \"params\": { \"constructor\": [\"args\"], \"isCompeted\": [], \"end\": [], \"next\": [\"express\"], \"getArgs\": [], \"getMetadata\": [] } };\n    return ArgsIterator;\n}());\nexports.ArgsIterator = ArgsIterator;\n\n\n\n\n});\n\nunwrapExports(ArgsIterator_1);\nvar ArgsIterator_2 = ArgsIterator_1.ArgsIterator;\n\nvar DecoratorType_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * decorator type category.\n *\n * @export\n * @enum {number}\n */\nvar DecoratorType;\n(function (DecoratorType) {\n    /**\n     * Class decorator\n     */\n    DecoratorType[DecoratorType[\"Class\"] = 1] = \"Class\";\n    /**\n     * Parameter decorator\n     */\n    DecoratorType[DecoratorType[\"Parameter\"] = 2] = \"Parameter\";\n    /**\n     * Property decorator\n     */\n    DecoratorType[DecoratorType[\"Property\"] = 4] = \"Property\";\n    /**\n     * Method decorator\n     */\n    DecoratorType[DecoratorType[\"Method\"] = 8] = \"Method\";\n    /**\n     * decorator for any where.\n     */\n    DecoratorType[DecoratorType[\"All\"] = 13] = \"All\";\n})(DecoratorType = exports.DecoratorType || (exports.DecoratorType = {}));\n\n\n\n\n});\n\nunwrapExports(DecoratorType_1);\nvar DecoratorType_2 = DecoratorType_1.DecoratorType;\n\nvar DecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\nexports.ParamerterName = 'paramerter_names';\n/**\n * create dectorator for class params props methods.\n *\n * @export\n * @template T\n * @param {string} name\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {*}\n */\nfunction createDecorator(name, adapter, metadataExtends) {\n    var metaName = \"@\" + name;\n    var factory = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var metadata = null;\n        if (args.length < 1) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\n            };\n        }\n        metadata = argsToMetadata(args, adapter);\n        if (metadata) {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\n            };\n        }\n        else {\n            if (args.length === 1) {\n                if (!utils.isClass(args[0])) {\n                    return function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        return storeMetadata(name, metaName, args, metadata, metadataExtends);\n                    };\n                }\n            }\n        }\n        return storeMetadata(name, metaName, args, metadata, metadataExtends);\n    };\n    factory.toString = function () { return metaName; };\n    factory.decoratorType = DecoratorType_1.DecoratorType.All;\n    return factory;\n}\nexports.createDecorator = createDecorator;\nfunction argsToMetadata(args, adapter) {\n    var metadata = null;\n    if (args.length) {\n        if (adapter) {\n            var iterator = new ArgsIterator_1.ArgsIterator(args);\n            adapter(iterator);\n            metadata = iterator.getMetadata();\n        }\n        else if (args.length === 1 && utils.isMetadataObject(args[0])) {\n            metadata = args[0];\n        }\n    }\n    return metadata;\n}\nfunction storeMetadata(name, metaName, args, metadata, metadataExtends) {\n    var target;\n    switch (args.length) {\n        case 1:\n            target = args[0];\n            if (utils.isClass(target) || utils.isAbstractDecoratorClass(target)) {\n                setTypeMetadata(name, metaName, target, metadata, metadataExtends);\n                return target;\n            }\n            break;\n        case 2:\n            target = args[0];\n            var propertyKey = args[1];\n            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\n            break;\n        case 3:\n            if (utils.isNumber(args[2])) {\n                target = args[0];\n                var propertyKey_1 = args[1];\n                var parameterIndex = args[2];\n                setParamMetadata(name, metaName, target, propertyKey_1, parameterIndex, metadata, metadataExtends);\n            }\n            else if (utils.isUndefined(args[2])) {\n                target = args[0];\n                var propertyKey_2 = args[1];\n                setPropertyMetadata(name, metaName, target, propertyKey_2, metadata, metadataExtends);\n            }\n            else {\n                target = args[0];\n                var propertyKey_3 = args[1];\n                var descriptor = args[2];\n                setMethodMetadata(name, metaName, target, propertyKey_3, descriptor, metadata, metadataExtends);\n                return descriptor;\n            }\n            break;\n        default:\n            throw new Error(\"Invalid @\" + name + \" Decorator declaration.\");\n    }\n}\n/**\n * get all class metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns\n */\nfunction getTypeMetadata(decorator, target) {\n    var annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);\n    annotations = utils.isArray(annotations) ? annotations : [];\n    return annotations;\n}\nexports.getTypeMetadata = getTypeMetadata;\n/**\n * get own class metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns\n */\nfunction getOwnTypeMetadata(decorator, target) {\n    var annotations = Reflect.getOwnMetadata(utils.isFunction(decorator) ? decorator.toString() : decorator, target);\n    annotations = utils.isArray(annotations) ? annotations : [];\n    return annotations;\n}\nexports.getOwnTypeMetadata = getOwnTypeMetadata;\n/**\n * has class decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @returns {boolean}\n */\nfunction hasClassMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    return Reflect.hasMetadata(name, target);\n}\nexports.hasClassMetadata = hasClassMetadata;\n/**\n * has own class decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @returns {boolean}\n */\nfunction hasOwnClassMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    return Reflect.hasOwnMetadata(name, target);\n}\nexports.hasOwnClassMetadata = hasOwnClassMetadata;\nfunction setTypeMetadata(name, metaName, target, metadata, metadataExtends) {\n    var annotations = getOwnTypeMetadata(metaName, target).slice(0);\n    // let designParams = Reflect.getMetadata('design:paramtypes', target) || [];\n    var typeMetadata = (metadata || {});\n    if (!typeMetadata.type) {\n        typeMetadata.type = target;\n    }\n    typeMetadata.decorator = name;\n    if (metadataExtends) {\n        typeMetadata = metadataExtends(typeMetadata);\n    }\n    annotations.unshift(typeMetadata);\n    setParamerterNames(target);\n    Reflect.defineMetadata(metaName, annotations, target);\n}\nvar methodMetadataExt = '__method';\n/**\n * get all method metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns {ObjectMap<T[]>}\n */\nfunction getMethodMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var meta = Reflect.getMetadata(name + methodMetadataExt, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getMethodMetadata = getMethodMetadata;\n/**\n * get own method metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns {ObjectMap<T[]>}\n */\nfunction getOwnMethodMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getOwnMethodMetadata = getOwnMethodMetadata;\n/**\n * has own method decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @param {(string | symbol)} [propertyKey]\n * @returns {boolean}\n */\nfunction hasOwnMethodMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    if (propertyKey) {\n        var meta = getOwnMethodMetadata(name, target);\n        return meta && meta.hasOwnProperty(propertyKey);\n    }\n    else {\n        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);\n    }\n}\nexports.hasOwnMethodMetadata = hasOwnMethodMetadata;\n/**\n * has method decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @param {(string | symbol)} [propertyKey]\n * @returns {boolean}\n */\nfunction hasMethodMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    if (propertyKey) {\n        var meta = getMethodMetadata(name, target);\n        return meta && meta.hasOwnProperty(propertyKey);\n    }\n    else {\n        return Reflect.hasMetadata(name + methodMetadataExt, target);\n    }\n}\nexports.hasMethodMetadata = hasMethodMetadata;\nfunction setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends) {\n    var meta = utils.lang.assign({}, getOwnMethodMetadata(metaName, target));\n    meta[propertyKey] = meta[propertyKey] || [];\n    var methodMeadata = (metadata || {});\n    methodMeadata.decorator = name;\n    methodMeadata.propertyKey = propertyKey;\n    // methodMeadata.descriptor = descriptor;\n    if (metadataExtends) {\n        methodMeadata = metadataExtends(methodMeadata);\n    }\n    meta[propertyKey].unshift(methodMeadata);\n    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);\n}\nvar propertyMetadataExt = '__props';\n/**\n * get all property metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns {ObjectMap<T[]>}\n */\nfunction getPropertyMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var meta = Reflect.getMetadata(name + propertyMetadataExt, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getPropertyMetadata = getPropertyMetadata;\n/**\n * get own property metadata of one specail decorator in target type.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @returns {ObjectMap<T[]>}\n */\nfunction getOwnPropertyMetadata(decorator, target) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getOwnPropertyMetadata = getOwnPropertyMetadata;\n/**\n * has property decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {Type<any>} target\n * @param {(string | symbol)} [propertyKey]\n * @returns {boolean}\n */\nfunction hasPropertyMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    if (propertyKey) {\n        var meta = getPropertyMetadata(name, target);\n        return meta && meta.hasOwnProperty(propertyKey);\n    }\n    else {\n        return Reflect.hasMetadata(name + propertyMetadataExt, target);\n    }\n}\nexports.hasPropertyMetadata = hasPropertyMetadata;\nfunction setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends) {\n    var meta = utils.lang.assign({}, getOwnPropertyMetadata(metaName, target));\n    var propmetadata = (metadata || {});\n    propmetadata.propertyKey = propertyKey;\n    propmetadata.decorator = name;\n    if (!propmetadata.type) {\n        var t = Reflect.getMetadata('design:type', target, propertyKey);\n        if (!t) {\n            // Needed to support react native inheritance\n            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);\n        }\n        propmetadata.type = t;\n    }\n    if (metadataExtends) {\n        propmetadata = metadataExtends(propmetadata);\n    }\n    if (!meta[propertyKey] || !utils.isArray(meta[propertyKey])) {\n        meta[propertyKey] = [];\n    }\n    meta[propertyKey].unshift(propmetadata);\n    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);\n}\nvar paramsMetadataExt = '__params';\n/**\n * get paramerter metadata of one specail decorator in target method.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @param {(string | symbol)} propertyKey\n * @returns {T[][]}\n */\nfunction getParamMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);\n    parameters = utils.isArray(parameters) ? parameters : [];\n    return parameters;\n}\nexports.getParamMetadata = getParamMetadata;\n/**\n * get own paramerter metadata of one specail decorator in target method.\n *\n * @export\n * @template T\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @param {(string | symbol)} propertyKey\n * @returns {T[][]}\n */\nfunction getOwnParamMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    var parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);\n    parameters = utils.isArray(parameters) ? parameters : [];\n    return parameters;\n}\nexports.getOwnParamMetadata = getOwnParamMetadata;\n/**\n * has param decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @param {(string | symbol)} propertyKey\n * @returns {boolean}\n */\nfunction hasParamMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);\n}\nexports.hasParamMetadata = hasParamMetadata;\n/**\n * has param decorator metadata.\n *\n * @export\n * @param {(string | Function)} decorator\n * @param {(Type<any> | object)} target\n * @param {(string | symbol)} propertyKey\n * @returns {boolean}\n */\nfunction hasOwnParamMetadata(decorator, target, propertyKey) {\n    var name = utils.isFunction(decorator) ? decorator.toString() : decorator;\n    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);\n}\nexports.hasOwnParamMetadata = hasOwnParamMetadata;\nfunction setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends) {\n    var parameters = getOwnParamMetadata(metaName, target, propertyKey).slice(0);\n    // there might be gaps if some in between parameters do not have annotations.\n    // we pad with nulls.\n    while (parameters.length <= parameterIndex) {\n        parameters.push(null);\n    }\n    parameters[parameterIndex] = parameters[parameterIndex] || [];\n    var paramMeadata = (metadata || {});\n    if (!paramMeadata.type) {\n        var t = Reflect.getOwnMetadata('design:type', target, propertyKey);\n        if (!t) {\n            // Needed to support react native inheritance\n            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);\n        }\n        paramMeadata.type = t;\n    }\n    paramMeadata.propertyKey = propertyKey;\n    paramMeadata.decorator = name;\n    paramMeadata.index = parameterIndex;\n    if (metadataExtends) {\n        paramMeadata = metadataExtends(paramMeadata);\n    }\n    parameters[parameterIndex].unshift(paramMeadata);\n    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);\n}\nfunction getParamerterNames(target) {\n    var meta = Reflect.getMetadata(exports.ParamerterName, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getMetadata(exports.ParamerterName, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getParamerterNames = getParamerterNames;\nfunction getOwnParamerterNames(target) {\n    var meta = Reflect.getOwnMetadata(exports.ParamerterName, target);\n    if (!meta || utils.isArray(meta) || !utils.lang.hasField(meta)) {\n        meta = Reflect.getOwnMetadata(exports.ParamerterName, target.constructor);\n    }\n    return utils.isArray(meta) ? {} : (meta || {});\n}\nexports.getOwnParamerterNames = getOwnParamerterNames;\nfunction setParamerterNames(target) {\n    var meta = utils.lang.assign({}, getParamerterNames(target));\n    var descriptors = Object.getOwnPropertyDescriptors(target.prototype);\n    var isUglify = /^[a-z]/.test(target.name);\n    var anName = '';\n    if (target.classAnnations && target.classAnnations.params) {\n        anName = target.classAnnations.name;\n        meta = utils.lang.assign(meta, target.classAnnations.params);\n    }\n    if (!isUglify && target.name !== anName) {\n        utils.lang.forIn(descriptors, function (item, name) {\n            if (name !== 'constructor') {\n                if (item.value) {\n                    meta[name] = getParamNames(item.value);\n                }\n                if (item.set) {\n                    meta[name] = getParamNames(item.set);\n                }\n            }\n        });\n        meta['constructor'] = getParamNames(target.prototype.constructor);\n    }\n    Reflect.defineMetadata(exports.ParamerterName, meta, target);\n}\nexports.setParamerterNames = setParamerterNames;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\nfunction getParamNames(func) {\n    if (!utils.isFunction(func)) {\n        return [];\n    }\n    var fnStr = func.toString().replace(STRIP_COMMENTS, '');\n    var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n    if (result === null) {\n        result = [];\n    }\n    return result;\n}\n\n\n\n\n});\n\nunwrapExports(DecoratorFactory);\nvar DecoratorFactory_1 = DecoratorFactory.ParamerterName;\nvar DecoratorFactory_2 = DecoratorFactory.createDecorator;\nvar DecoratorFactory_3 = DecoratorFactory.getTypeMetadata;\nvar DecoratorFactory_4 = DecoratorFactory.getOwnTypeMetadata;\nvar DecoratorFactory_5 = DecoratorFactory.hasClassMetadata;\nvar DecoratorFactory_6 = DecoratorFactory.hasOwnClassMetadata;\nvar DecoratorFactory_7 = DecoratorFactory.getMethodMetadata;\nvar DecoratorFactory_8 = DecoratorFactory.getOwnMethodMetadata;\nvar DecoratorFactory_9 = DecoratorFactory.hasOwnMethodMetadata;\nvar DecoratorFactory_10 = DecoratorFactory.hasMethodMetadata;\nvar DecoratorFactory_11 = DecoratorFactory.getPropertyMetadata;\nvar DecoratorFactory_12 = DecoratorFactory.getOwnPropertyMetadata;\nvar DecoratorFactory_13 = DecoratorFactory.hasPropertyMetadata;\nvar DecoratorFactory_14 = DecoratorFactory.getParamMetadata;\nvar DecoratorFactory_15 = DecoratorFactory.getOwnParamMetadata;\nvar DecoratorFactory_16 = DecoratorFactory.hasParamMetadata;\nvar DecoratorFactory_17 = DecoratorFactory.hasOwnParamMetadata;\nvar DecoratorFactory_18 = DecoratorFactory.getParamerterNames;\nvar DecoratorFactory_19 = DecoratorFactory.getOwnParamerterNames;\nvar DecoratorFactory_20 = DecoratorFactory.setParamerterNames;\n\nvar ClassDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n/**\n * create class decorator\n *\n * @export\n * @template T metadata type.\n * @param {string} name decorator name.\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {*}\n */\nfunction createClassDecorator(name, adapter, metadataExtends) {\n    var classAdapter = (function (args) {\n        if (adapter) {\n            adapter(args);\n        }\n        args.next({\n            // isMetadata: (arg) => isClassMetadata(arg),\n            match: function (arg) { return arg && (utils.isSymbol(arg) || utils.isString(arg) || (utils.isObject(arg) && arg instanceof Registration_1.Registration)); },\n            setMetadata: function (metadata, arg) {\n                metadata.provide = arg;\n            }\n        });\n        args.next({\n            match: function (arg) { return utils.isString(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.alias = arg;\n            }\n        });\n        args.next({\n            match: function (arg) { return utils.isBoolean(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.singleton = arg;\n            }\n        });\n        args.next({\n            match: function (arg) { return utils.isNumber(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.expires = arg;\n            }\n        });\n    });\n    var decorator = DecoratorFactory.createDecorator(name, classAdapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Class;\n    return decorator;\n}\nexports.createClassDecorator = createClassDecorator;\n\n\n\n\n});\n\nunwrapExports(ClassDecoratorFactory);\nvar ClassDecoratorFactory_1 = ClassDecoratorFactory.createClassDecorator;\n\nvar MethodDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * create method decorator.\n *\n * @export\n * @template T metadata type.\n * @param {string} name decorator name.\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns\n */\nfunction createMethodDecorator(name, adapter, metadataExtends) {\n    var methodAdapter = function (args) {\n        if (adapter) {\n            adapter(args);\n        }\n        args.next({\n            match: function (arg) { return utils.isArray(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.providers = arg;\n            }\n        });\n    };\n    var decorator = DecoratorFactory.createDecorator(name, methodAdapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Method;\n    return decorator;\n}\nexports.createMethodDecorator = createMethodDecorator;\n\n\n\n\n});\n\nunwrapExports(MethodDecoratorFactory);\nvar MethodDecoratorFactory_1 = MethodDecoratorFactory.createMethodDecorator;\n\nvar ParamDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * create parameter decorator.\n *\n * @export\n * @template T metadata type.\n * @param {string} name decorator name.\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns\n */\nfunction createParamDecorator(name, adapter, metadataExtends) {\n    var paramAdapter = (function (args) {\n        if (adapter) {\n            adapter(args);\n        }\n        args.next({\n            isMetadata: function (arg) { return utils.isParamMetadata(arg); },\n            match: function (arg) { return utils.isToken(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.provider = arg;\n            }\n        });\n        // args.next<T>({\n        //     match: (arg) => isString(arg),\n        //     setMetadata: (metadata, arg) => {\n        //         metadata.alias = arg;\n        //     }\n        // });\n    });\n    var decorator = DecoratorFactory.createDecorator(name, paramAdapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Parameter;\n    return decorator;\n}\nexports.createParamDecorator = createParamDecorator;\n\n\n\n\n});\n\nunwrapExports(ParamDecoratorFactory);\nvar ParamDecoratorFactory_1 = ParamDecoratorFactory.createParamDecorator;\n\nvar PropertyDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * create property decorator.\n *\n * @export\n * @template T metadata type.\n * @param {string} name decorator name.\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns\n */\nfunction createPropDecorator(name, adapter, metadataExtends) {\n    var propPropAdapter = (function (args) {\n        if (adapter) {\n            adapter(args);\n        }\n        args.next({\n            isMetadata: function (arg) { return utils.isPropertyMetadata(arg); },\n            match: function (arg) { return utils.isToken(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.provider = arg;\n            }\n        });\n        // args.next<T>({\n        //     match: (arg) => isString(arg),\n        //     setMetadata: (metadata, arg) => {\n        //         metadata.alias = arg;\n        //     }\n        // });\n    });\n    var decorator = DecoratorFactory.createDecorator(name, propPropAdapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Property;\n    return decorator;\n}\nexports.createPropDecorator = createPropDecorator;\n\n\n\n\n});\n\nunwrapExports(PropertyDecoratorFactory);\nvar PropertyDecoratorFactory_1 = PropertyDecoratorFactory.createPropDecorator;\n\nvar ParamPropDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * create parameter or property decorator\n *\n * @export\n * @template T\n * @param {string} name\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {IParamPropDecorator<T>}\n */\nfunction createParamPropDecorator(name, adapter, metadataExtends) {\n    var paramPropAdapter = (function (args) {\n        if (adapter) {\n            adapter(args);\n        }\n        args.next({\n            isMetadata: function (arg) { return utils.isParamPropMetadata(arg); },\n            match: function (arg) { return utils.isToken(arg); },\n            setMetadata: function (metadata, arg) {\n                metadata.provider = arg;\n            }\n        });\n        // args.next<T>({\n        //     match: (arg) => isString(arg),\n        //     setMetadata: (metadata, arg) => {\n        //         metadata.alias = arg;\n        //     }\n        // });\n    });\n    var decorator = DecoratorFactory.createDecorator(name, paramPropAdapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;\n    return decorator;\n}\nexports.createParamPropDecorator = createParamPropDecorator;\n\n\n\n\n});\n\nunwrapExports(ParamPropDecoratorFactory);\nvar ParamPropDecoratorFactory_1 = ParamPropDecoratorFactory.createParamPropDecorator;\n\nvar ClassMethodDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * create decorator for class and method.\n *\n * @export\n * @template T\n * @param {string} name\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {IClassMethodDecorator<T>}\n */\nfunction createClassMethodDecorator(name, adapter, metadataExtends) {\n    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Class | DecoratorType_1.DecoratorType.Method;\n    return decorator;\n}\nexports.createClassMethodDecorator = createClassMethodDecorator;\n\n\n\n\n});\n\nunwrapExports(ClassMethodDecoratorFactory);\nvar ClassMethodDecoratorFactory_1 = ClassMethodDecoratorFactory.createClassMethodDecorator;\n\nvar MethodPropDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * create method or property decorator\n *\n * @export\n * @template T\n * @param {string} name\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {IMethodPropDecorator<T>}\n */\nfunction createMethodPropDecorator(name, adapter, metadataExtends) {\n    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property;\n    return decorator;\n}\nexports.createMethodPropDecorator = createMethodPropDecorator;\n\n\n\n\n});\n\nunwrapExports(MethodPropDecoratorFactory);\nvar MethodPropDecoratorFactory_1 = MethodPropDecoratorFactory.createMethodPropDecorator;\n\nvar MethodPropParamDecoratorFactory = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * define method or property decorator\n *\n * @export\n * @template T\n * @param {string} name\n * @param {MetadataAdapter} [adapter]  metadata adapter\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\n * @returns {IMethodPropParamDecorator<T>}\n */\nfunction createMethodPropParamDecorator(name, adapter, metadataExtends) {\n    var decorator = DecoratorFactory.createDecorator(name, adapter, metadataExtends);\n    decorator.decoratorType = DecoratorType_1.DecoratorType.Method | DecoratorType_1.DecoratorType.Property | DecoratorType_1.DecoratorType.Parameter;\n    return decorator;\n}\nexports.createMethodPropParamDecorator = createMethodPropParamDecorator;\n\n\n\n\n});\n\nunwrapExports(MethodPropParamDecoratorFactory);\nvar MethodPropParamDecoratorFactory_1 = MethodPropParamDecoratorFactory.createMethodPropParamDecorator;\n\nvar factories = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(ArgsIterator_1, exports);\ntslib_1.__exportStar(DecoratorType_1, exports);\ntslib_1.__exportStar(DecoratorFactory, exports);\ntslib_1.__exportStar(ClassDecoratorFactory, exports);\ntslib_1.__exportStar(MethodDecoratorFactory, exports);\ntslib_1.__exportStar(ParamDecoratorFactory, exports);\ntslib_1.__exportStar(PropertyDecoratorFactory, exports);\ntslib_1.__exportStar(ParamPropDecoratorFactory, exports);\ntslib_1.__exportStar(ClassMethodDecoratorFactory, exports);\ntslib_1.__exportStar(MethodPropDecoratorFactory, exports);\ntslib_1.__exportStar(MethodPropParamDecoratorFactory, exports);\n\n\n\n\n});\n\nunwrapExports(factories);\n\nvar BindProviderAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * bind provider action. for binding a factory to an token.\n *\n * @export\n * @class BindProviderAction\n * @extends {ActionComposite}\n */\nvar BindProviderAction = /** @class */ (function (_super) {\n    tslib_1.__extends(BindProviderAction, _super);\n    function BindProviderAction() {\n        return _super.call(this, CoreActions_1.CoreActions.bindProvider) || this;\n    }\n    BindProviderAction.prototype.working = function (container, data) {\n        var type = data.targetType;\n        var lifeScope = container.getLifeScope();\n        var matchs = lifeScope.getClassDecorators(function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindProvider) && factories.hasOwnClassMetadata(surm.name, type); });\n        var provides = [];\n        var raiseContainer = data.raiseContainer || container;\n        matchs.forEach(function (surm) {\n            var metadata = factories.getOwnTypeMetadata(surm.name, type);\n            if (Array.isArray(metadata) && metadata.length > 0) {\n                // bind all provider.\n                metadata.forEach(function (c) {\n                    if (c && c.provide) {\n                        var provideKey = raiseContainer.getTokenKey(c.provide, c.alias);\n                        provides.push(provideKey);\n                        raiseContainer.bindProvider(provideKey, c.type);\n                    }\n                });\n            }\n        });\n        data.execResult = provides;\n    };\n    BindProviderAction.classAnnations = { \"name\": \"BindProviderAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return BindProviderAction;\n}(ActionComposite_1.ActionComposite));\nexports.BindProviderAction = BindProviderAction;\n\n\n\n\n});\n\nunwrapExports(BindProviderAction_1);\nvar BindProviderAction_2 = BindProviderAction_1.BindProviderAction;\n\nvar BindParameterTypeAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n/**\n * bind parameter type action.\n *\n * @export\n * @class BindParameterTypeAction\n * @extends {ActionComposite}\n */\nvar BindParameterTypeAction = /** @class */ (function (_super) {\n    tslib_1.__extends(BindParameterTypeAction, _super);\n    function BindParameterTypeAction() {\n        return _super.call(this, CoreActions_1.CoreActions.bindParameterType) || this;\n    }\n    BindParameterTypeAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        var target = data.target;\n        var type = data.targetType;\n        var propertyKey = data.propertyKey;\n        var lifeScope = container.getLifeScope();\n        var designParams;\n        if (target && propertyKey) {\n            designParams = Reflect.getMetadata('design:paramtypes', target, propertyKey) || [];\n        }\n        else {\n            designParams = Reflect.getMetadata('design:paramtypes', type) || [];\n        }\n        designParams = designParams.slice(0);\n        designParams.forEach(function (dtype) {\n            if (lifeScope.isVaildDependence(dtype)) {\n                if (!container.has(dtype)) {\n                    container.register(dtype);\n                }\n            }\n        });\n        var matchs = lifeScope.getParameterDecorators((function (surm) {\n            return surm.actions.includes(CoreActions_1.CoreActions.bindParameterType) && ((target || propertyKey !== 'constructor') ? factories.hasParamMetadata(surm.name, target, propertyKey)\n                : factories.hasOwnParamMetadata(surm.name, type));\n        }));\n        matchs.forEach(function (surm) {\n            var parameters = (target || propertyKey !== 'constructor') ? factories.getParamMetadata(surm.name, target, propertyKey) : factories.getOwnParamMetadata(surm.name, type);\n            if (utils.isArray(parameters) && parameters.length) {\n                parameters.forEach(function (params) {\n                    var parm = (utils.isArray(params) && params.length > 0) ? params[0] : null;\n                    if (parm && parm.index >= 0) {\n                        if (lifeScope.isVaildDependence(parm.provider)) {\n                            if (!container.has(parm.provider, parm.alias)) {\n                                container.register(container.getToken(parm.provider, parm.alias));\n                            }\n                        }\n                        if (lifeScope.isVaildDependence(parm.type)) {\n                            if (!container.has(parm.type)) {\n                                container.register(parm.type);\n                            }\n                        }\n                        var token = parm.provider ? container.getTokenKey(parm.provider, parm.alias) : parm.type;\n                        if (token) {\n                            designParams[parm.index] = token;\n                        }\n                    }\n                });\n            }\n        });\n        data.execResult = designParams;\n    };\n    BindParameterTypeAction.classAnnations = { \"name\": \"BindParameterTypeAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return BindParameterTypeAction;\n}(ActionComposite_1.ActionComposite));\nexports.BindParameterTypeAction = BindParameterTypeAction;\n\n\n\n\n});\n\nunwrapExports(BindParameterTypeAction_1);\nvar BindParameterTypeAction_2 = BindParameterTypeAction_1.BindParameterTypeAction;\n\nvar BindPropertyTypeAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * bind property type action. to get the property autowride token of Type calss.\n *\n * @export\n * @class SetPropAction\n * @extends {ActionComposite}\n */\nvar BindPropertyTypeAction = /** @class */ (function (_super) {\n    tslib_1.__extends(BindPropertyTypeAction, _super);\n    function BindPropertyTypeAction() {\n        return _super.call(this, CoreActions_1.CoreActions.bindPropertyType) || this;\n    }\n    BindPropertyTypeAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        var type = data.targetType;\n        var lifeScope = container.getLifeScope();\n        var matchs = lifeScope.getPropertyDecorators(function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindPropertyType) && factories.hasPropertyMetadata(surm.name, type); });\n        var list = [];\n        matchs.forEach(function (surm) {\n            var propMetadata = factories.getPropertyMetadata(surm.name, type);\n            for (var n in propMetadata) {\n                list = list.concat(propMetadata[n]);\n            }\n            list = list.filter(function (n) { return !!n; });\n            list.forEach(function (prop) {\n                if (lifeScope.isVaildDependence(prop.provider)) {\n                    if (!container.has(prop.provider, prop.alias)) {\n                        container.register(container.getToken(prop.provider, prop.alias));\n                    }\n                }\n                if (lifeScope.isVaildDependence(prop.type)) {\n                    if (!container.has(prop.type)) {\n                        container.register(prop.type);\n                    }\n                }\n            });\n        });\n        data.execResult = list;\n    };\n    BindPropertyTypeAction.classAnnations = { \"name\": \"BindPropertyTypeAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return BindPropertyTypeAction;\n}(ActionComposite_1.ActionComposite));\nexports.BindPropertyTypeAction = BindPropertyTypeAction;\n\n\n\n\n});\n\nunwrapExports(BindPropertyTypeAction_1);\nvar BindPropertyTypeAction_2 = BindPropertyTypeAction_1.BindPropertyTypeAction;\n\nvar InjectPropertyAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * inject property value action, to inject property value for resolve instance.\n *\n * @export\n * @class SetPropAction\n * @extends {ActionComposite}\n */\nvar InjectPropertyAction = /** @class */ (function (_super) {\n    tslib_1.__extends(InjectPropertyAction, _super);\n    function InjectPropertyAction() {\n        return _super.call(this, CoreActions_1.CoreActions.injectProperty) || this;\n    }\n    InjectPropertyAction.prototype.working = function (container, data) {\n        if (!data.execResult) {\n            this.parent.find(function (act) { return act.name === CoreActions_1.CoreActions.bindPropertyType; }).execute(container, data);\n        }\n        if (data.target && data.execResult && data.execResult.length) {\n            var providerMap_1 = data.providerMap;\n            data.execResult.reverse().forEach(function (prop, idx) {\n                if (prop) {\n                    var token = prop.provider ? container.getToken(prop.provider, prop.alias) : prop.type;\n                    if (providerMap_1 && providerMap_1.has(token)) {\n                        data.target[prop.propertyKey] = providerMap_1.resolve(token, providerMap_1);\n                    }\n                    else if (container.has(token)) {\n                        data.target[prop.propertyKey] = container.resolve(token, providerMap_1);\n                    }\n                }\n            });\n        }\n    };\n    InjectPropertyAction.classAnnations = { \"name\": \"InjectPropertyAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return InjectPropertyAction;\n}(ActionComposite_1.ActionComposite));\nexports.InjectPropertyAction = InjectPropertyAction;\n\n\n\n\n});\n\nunwrapExports(InjectPropertyAction_1);\nvar InjectPropertyAction_2 = InjectPropertyAction_1.InjectPropertyAction;\n\nvar BindParameterProviderAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n/**\n * bind parameters action.\n *\n * @export\n * @class BindParameterProviderAction\n * @extends {ActionComposite}\n */\nvar BindParameterProviderAction = /** @class */ (function (_super) {\n    tslib_1.__extends(BindParameterProviderAction, _super);\n    function BindParameterProviderAction() {\n        return _super.call(this, CoreActions_1.CoreActions.bindParameterProviders) || this;\n    }\n    BindParameterProviderAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        var type = data.targetType;\n        var propertyKey = data.propertyKey;\n        var lifeScope = container.getLifeScope();\n        var matchs = lifeScope.getMethodDecorators(function (surm) { return surm.actions.includes(CoreActions_1.CoreActions.bindParameterProviders) && factories.hasOwnMethodMetadata(surm.name, type); });\n        var providers = [];\n        matchs.forEach(function (surm) {\n            var methodmtas = factories.getOwnMethodMetadata(surm.name, type);\n            var metadatas = methodmtas[propertyKey];\n            if (metadatas && utils.isArray(metadatas) && metadatas.length > 0) {\n                metadatas.forEach(function (meta) {\n                    if (meta.providers && meta.providers.length > 0) {\n                        providers = providers.concat(meta.providers);\n                    }\n                });\n            }\n        });\n        data.execResult = providers;\n    };\n    BindParameterProviderAction.classAnnations = { \"name\": \"BindParameterProviderAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return BindParameterProviderAction;\n}(ActionComposite_1.ActionComposite));\nexports.BindParameterProviderAction = BindParameterProviderAction;\n\n\n\n\n});\n\nunwrapExports(BindParameterProviderAction_1);\nvar BindParameterProviderAction_2 = BindParameterProviderAction_1.BindParameterProviderAction;\n\nvar ComponentBeforeInitAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * component before init action, to run @Component decorator class before init hooks.\n *\n * @export\n * @class ComponentBeforeInitAction\n * @extends {ActionComposite}\n */\nvar ComponentBeforeInitAction = /** @class */ (function (_super) {\n    tslib_1.__extends(ComponentBeforeInitAction, _super);\n    function ComponentBeforeInitAction() {\n        return _super.call(this, CoreActions_1.CoreActions.componentBeforeInit) || this;\n    }\n    ComponentBeforeInitAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.targetType && data.target) {\n            var component = data.target;\n            if (utils.isFunction(component.beforeInit)) {\n                container.syncInvoke(data.targetType, 'beforeInit', data.target);\n            }\n        }\n    };\n    ComponentBeforeInitAction.classAnnations = { \"name\": \"ComponentBeforeInitAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return ComponentBeforeInitAction;\n}(ActionComposite_1.ActionComposite));\nexports.ComponentBeforeInitAction = ComponentBeforeInitAction;\n\n\n\n\n});\n\nunwrapExports(ComponentBeforeInitAction_1);\nvar ComponentBeforeInitAction_2 = ComponentBeforeInitAction_1.ComponentBeforeInitAction;\n\nvar ComponentInitAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * component before init action, to run @Component decorator class before init hooks.\n *\n * @export\n * @class ComponentInitAction\n * @extends {ActionComposite}\n */\nvar ComponentInitAction = /** @class */ (function (_super) {\n    tslib_1.__extends(ComponentInitAction, _super);\n    function ComponentInitAction() {\n        return _super.call(this, CoreActions_1.CoreActions.componentInit) || this;\n    }\n    ComponentInitAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.targetType && data.target) {\n            var component = data.target;\n            if (utils.isFunction(component.onInit)) {\n                container.syncInvoke(data.targetType, 'onInit', data.target);\n            }\n        }\n    };\n    ComponentInitAction.classAnnations = { \"name\": \"ComponentInitAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return ComponentInitAction;\n}(ActionComposite_1.ActionComposite));\nexports.ComponentInitAction = ComponentInitAction;\n\n\n\n\n});\n\nunwrapExports(ComponentInitAction_1);\nvar ComponentInitAction_2 = ComponentInitAction_1.ComponentInitAction;\n\nvar ComponentAfterInitAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * component after init action, to run @Component decorator class after init hooks.\n *\n * @export\n * @class ComponentAfterInitAction\n * @extends {ActionComposite}\n */\nvar ComponentAfterInitAction = /** @class */ (function (_super) {\n    tslib_1.__extends(ComponentAfterInitAction, _super);\n    function ComponentAfterInitAction() {\n        return _super.call(this, CoreActions_1.CoreActions.componentAfterInit) || this;\n    }\n    ComponentAfterInitAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.targetType && data.target) {\n            var component = data.target;\n            if (utils.isFunction(component.afterInit)) {\n                container.syncInvoke(data.targetType, 'afterInit', data.target);\n            }\n        }\n    };\n    ComponentAfterInitAction.classAnnations = { \"name\": \"ComponentAfterInitAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return ComponentAfterInitAction;\n}(ActionComposite_1.ActionComposite));\nexports.ComponentAfterInitAction = ComponentAfterInitAction;\n\n\n\n\n});\n\nunwrapExports(ComponentAfterInitAction_1);\nvar ComponentAfterInitAction_2 = ComponentAfterInitAction_1.ComponentAfterInitAction;\n\nvar ICacheManager = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * ICacheManager interface token.\n * it is a token id, you can register yourself ICacheManager for this.\n */\nexports.CacheManagerToken = new InjectToken_1.InjectToken('DI_ICacheManager');\n\n\n\n\n});\n\nunwrapExports(ICacheManager);\nvar ICacheManager_1 = ICacheManager.CacheManagerToken;\n\nvar CacheAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n/**\n * cache action. To cache instance of Token. define cache expires in decorator.\n *\n * @export\n * @class CacheAction\n * @extends {ActionComposite}\n */\nvar CacheAction = /** @class */ (function (_super) {\n    tslib_1.__extends(CacheAction, _super);\n    function CacheAction() {\n        return _super.call(this, CoreActions_1.CoreActions.cache) || this;\n    }\n    CacheAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return data;\n        }\n        if (data.singleton || !data.targetType || !utils.isClass(data.targetType)) {\n            return data;\n        }\n        var cacheManager = container.get(ICacheManager.CacheManagerToken);\n        if (data.target) {\n            if (!cacheManager.hasCache(data.targetType)) {\n                var cacheMetadata = this.getCacheMetadata(container, data);\n                if (cacheMetadata) {\n                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);\n                }\n            }\n        }\n        else {\n            var target = cacheManager.get(data.targetType);\n            if (target) {\n                var cacheMetadata = this.getCacheMetadata(container, data);\n                if (cacheMetadata) {\n                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);\n                    data.execResult = target;\n                }\n            }\n        }\n        return data;\n    };\n    CacheAction.prototype.getCacheMetadata = function (container, data) {\n        var lifeScope = container.getLifeScope();\n        var matchs = lifeScope.getClassDecorators(function (surm) { return factories.hasOwnClassMetadata(surm.name, data.targetType); });\n        var cacheMetadata;\n        for (var i = 0; i < matchs.length; i++) {\n            var surm = matchs[i];\n            var metadata = factories.getOwnTypeMetadata(surm.name, data.targetType);\n            if (Array.isArray(metadata) && metadata.length > 0) {\n                cacheMetadata = metadata.find(function (c) { return c && utils.isNumber(c.expires) && c.expires > 0; });\n                if (cacheMetadata) {\n                    break;\n                }\n            }\n        }\n        return cacheMetadata;\n    };\n    CacheAction.classAnnations = { \"name\": \"CacheAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"], \"getCacheMetadata\": [\"container\", \"data\"] } };\n    return CacheAction;\n}(ActionComposite_1.ActionComposite));\nexports.CacheAction = CacheAction;\n\n\n\n\n});\n\nunwrapExports(CacheAction_1);\nvar CacheAction_2 = CacheAction_1.CacheAction;\n\nvar SingletonAction = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * singleton action, to set the factory of Token as singleton.\n *\n * @export\n * @class SingletionAction\n * @extends {ActionComposite}\n */\nvar SingletionAction = /** @class */ (function (_super) {\n    tslib_1.__extends(SingletionAction, _super);\n    function SingletionAction() {\n        return _super.call(this, CoreActions_1.CoreActions.singletion) || this;\n    }\n    SingletionAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.tokenKey && data.target && data.singleton) {\n            container.registerValue(data.tokenKey, data.target);\n        }\n    };\n    SingletionAction.classAnnations = { \"name\": \"SingletionAction\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return SingletionAction;\n}(ActionComposite_1.ActionComposite));\nexports.SingletionAction = SingletionAction;\n\n\n\n\n});\n\nunwrapExports(SingletonAction);\nvar SingletonAction_1 = SingletonAction.SingletionAction;\n\nvar Component = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\n *\n * @Component\n */\nexports.Component = factories.createClassDecorator('Component');\n\n\n\n\n});\n\nunwrapExports(Component);\nvar Component_1 = Component.Component;\n\nvar Injectable = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\n *\n * @Injectable\n */\nexports.Injectable = factories.createClassDecorator('Injectable');\n\n\n\n\n});\n\nunwrapExports(Injectable);\nvar Injectable_1 = Injectable.Injectable;\n\nvar Inject = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Inject decorator, for property or param, use to auto wried type instance or value to the instance of one class with the decorator.\n *\n * @Inject\n */\nexports.Inject = factories.createParamPropDecorator('Inject');\n\n\n\n\n});\n\nunwrapExports(Inject);\nvar Inject_1 = Inject.Inject;\n\nvar AutoWried = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * AutoWired decorator, for property or param. use to auto wried type instance or value to the instance of one class with the decorator.\n *\n * @AutoWired\n */\nexports.AutoWired = factories.createParamPropDecorator('AutoWired');\n\n\n\n\n});\n\nunwrapExports(AutoWried);\nvar AutoWried_1 = AutoWried.AutoWired;\n\nvar Param = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * param decorator, define for parameter. use to auto wried type instance or value to the instance of one class with the decorator.\n *\n * @Param\n */\nexports.Param = factories.createParamDecorator('Param');\n\n\n\n\n});\n\nunwrapExports(Param);\nvar Param_1 = Param.Param;\n\nvar Method = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * method decorator.\n *\n * @Method\n */\nexports.Method = factories.createMethodDecorator('Method');\n\n\n\n\n});\n\nunwrapExports(Method);\nvar Method_1 = Method.Method;\n\nvar Singleton = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Singleton decorator, for class. use to define the class is singleton.\n *\n * @Singleton\n */\nexports.Singleton = factories.createClassDecorator('Singleton', null, function (metadata) {\n    metadata.singleton = true;\n    return metadata;\n});\n\n\n\n\n});\n\nunwrapExports(Singleton);\nvar Singleton_1 = Singleton.Singleton;\n\nvar Abstract = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Abstract decorator. define for class.\n *\n * @Abstract\n */\nexports.Abstract = factories.createClassDecorator('Abstract');\n\n\n\n\n});\n\nunwrapExports(Abstract);\nvar Abstract_1 = Abstract.Abstract;\n\nvar AutoRun = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * Autorun decorator, for class or method.  use to define the class auto run (via a method or not) after registered.\n *\n * @Autorun\n */\nexports.Autorun = factories.createClassMethodDecorator('Autorun', function (args) {\n    args.next({\n        isMetadata: function (arg) { return utils.isClassMetadata(arg, ['autorun']); },\n        match: function (arg) { return utils.isString(arg) || utils.isNumber(arg); },\n        setMetadata: function (metadata, arg) {\n            if (utils.isString(arg)) {\n                metadata.autorun = arg;\n            }\n            else {\n                metadata.order = arg;\n            }\n        }\n    });\n}, function (metadata) {\n    metadata.singleton = true;\n    return metadata;\n});\n\n\n\n\n});\n\nunwrapExports(AutoRun);\nvar AutoRun_1 = AutoRun.Autorun;\n\nvar IocExt = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\n *\n * @IocExt\n */\nexports.IocExt = factories.createClassDecorator('IocExt', function (args) {\n    args.next({\n        isMetadata: function (arg) { return utils.isClassMetadata(arg, ['autorun']); },\n        match: function (arg) { return utils.isString(arg); },\n        setMetadata: function (metadata, arg) {\n            metadata.autorun = arg;\n        }\n    });\n}, function (metadata) {\n    metadata.singleton = true;\n    return metadata;\n});\nexports.IocModule = exports.IocExt;\n\n\n\n\n});\n\nunwrapExports(IocExt);\nvar IocExt_1 = IocExt.IocExt;\nvar IocExt_2 = IocExt.IocModule;\n\nvar decorators = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(Component, exports);\ntslib_1.__exportStar(Injectable, exports);\ntslib_1.__exportStar(Inject, exports);\ntslib_1.__exportStar(AutoWried, exports);\ntslib_1.__exportStar(Param, exports);\ntslib_1.__exportStar(Method, exports);\ntslib_1.__exportStar(Singleton, exports);\ntslib_1.__exportStar(Abstract, exports);\ntslib_1.__exportStar(AutoRun, exports);\ntslib_1.__exportStar(IocExt, exports);\n\n\n\n\n});\n\nunwrapExports(decorators);\n\nvar AutorunAction_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n/**\n * Inject DrawType action.\n *\n * @export\n * @class SetPropAction\n * @extends {ActionComposite}\n */\nvar AutorunAction = /** @class */ (function (_super) {\n    tslib_1.__extends(AutorunAction, _super);\n    function AutorunAction() {\n        return _super.call(this, CoreActions_1.CoreActions.autorun) || this;\n    }\n    AutorunAction.prototype.getDecorator = function () {\n        return [decorators.IocExt, decorators.Autorun];\n    };\n    AutorunAction.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.tokenKey && data.targetType) {\n            var decorators$$1 = this.getDecorator();\n            decorators$$1.forEach(function (decorator) {\n                if (factories.hasClassMetadata(decorator, data.targetType)) {\n                    var metas = factories.getTypeMetadata(decorator, data.targetType);\n                    var meta = metas.find(function (it) { return !!it.autorun; });\n                    if (!meta && metas.length) {\n                        meta = metas[0];\n                    }\n                    if (meta) {\n                        var instance = container.get(data.tokenKey);\n                        if (instance && meta.autorun && utils.isFunction(instance[meta.autorun])) {\n                            container.syncInvoke(data.tokenKey, meta.autorun, instance);\n                        }\n                    }\n                }\n            });\n        }\n    };\n    AutorunAction.classAnnations = { \"name\": \"AutorunAction\", \"params\": { \"constructor\": [], \"getDecorator\": [], \"working\": [\"container\", \"data\"] } };\n    return AutorunAction;\n}(ActionComposite_1.ActionComposite));\nexports.AutorunAction = AutorunAction;\n\n\n\n\n});\n\nunwrapExports(AutorunAction_1);\nvar AutorunAction_2 = AutorunAction_1.AutorunAction;\n\nvar actions = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(ActionComposite_1, exports);\ntslib_1.__exportStar(LifeState_1, exports);\ntslib_1.__exportStar(CoreActions_1, exports);\ntslib_1.__exportStar(NullAction, exports);\ntslib_1.__exportStar(BindProviderAction_1, exports);\ntslib_1.__exportStar(BindParameterTypeAction_1, exports);\ntslib_1.__exportStar(BindPropertyTypeAction_1, exports);\ntslib_1.__exportStar(InjectPropertyAction_1, exports);\ntslib_1.__exportStar(BindParameterProviderAction_1, exports);\ntslib_1.__exportStar(ComponentBeforeInitAction_1, exports);\ntslib_1.__exportStar(ComponentInitAction_1, exports);\ntslib_1.__exportStar(ComponentAfterInitAction_1, exports);\ntslib_1.__exportStar(CacheAction_1, exports);\ntslib_1.__exportStar(SingletonAction, exports);\ntslib_1.__exportStar(AutorunAction_1, exports);\n\n\n\n\n});\n\nunwrapExports(actions);\n\nvar ProviderMap_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\nexports.ProviderMapToken = new InjectToken_1.InjectToken('DI_ProviderMap');\n/**\n * Provider Map\n *\n * @export\n * @class Providers\n */\nvar ProviderMap = /** @class */ (function () {\n    function ProviderMap(container) {\n        this.container = container;\n        this.maps = new utils.MapSet();\n    }\n    ProviderMap.prototype.has = function (provide) {\n        return this.maps.has(provide);\n    };\n    ProviderMap.prototype.get = function (provide) {\n        return this.maps.get(provide);\n    };\n    ProviderMap.prototype.add = function (provide, provider) {\n        var _this = this;\n        if (utils.isUndefined(provide)) {\n            return this;\n        }\n        var factory;\n        if (utils.isToken(provider) && this.container.has(provider)) {\n            factory = function () {\n                var providers = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    providers[_i] = arguments[_i];\n                }\n                var _a;\n                return (_a = _this.container).resolve.apply(_a, [provider].concat(providers));\n            };\n        }\n        else {\n            if (utils.isFunction(provider)) {\n                factory = function () {\n                    var providers = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        providers[_i] = arguments[_i];\n                    }\n                    return provider.apply(void 0, [_this.container].concat(providers));\n                };\n            }\n            else {\n                factory = function () {\n                    return provider;\n                };\n            }\n        }\n        this.maps.set(provide, factory);\n        return this;\n    };\n    ProviderMap.prototype.remove = function (provide) {\n        if (this.maps.has(provide)) {\n            this.maps.delete(provide);\n        }\n        return this;\n    };\n    ProviderMap.prototype.resolve = function (provide) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a, _b;\n        if (!this.maps.has(provide)) {\n            return (!utils.isNumber(provide) && this.container.has(provide)) ? (_a = this.container).resolve.apply(_a, [provide].concat(providers)) : null;\n        }\n        var provider = this.maps.get(provide);\n        return utils.isToken(provider) ? (_b = this.container).resolve.apply(_b, [provider].concat(providers)) : provider.apply(void 0, providers);\n    };\n    ProviderMap.prototype.forEach = function (express) {\n        this.maps.forEach(express);\n    };\n    ProviderMap.prototype.copy = function (map) {\n        var _this = this;\n        if (!map) {\n            return;\n        }\n        map.forEach(function (val, token) {\n            _this.maps.set(token, val);\n        });\n    };\n    ProviderMap.classAnnations = { \"name\": \"ProviderMap\", \"params\": { \"constructor\": [\"container\"], \"has\": [\"provide\"], \"get\": [\"provide\"], \"add\": [\"provide\", \"provider\"], \"remove\": [\"provide\"], \"resolve\": [\"provide\", \"providers\"], \"forEach\": [\"express\"], \"copy\": [\"map\"] } };\n    return ProviderMap;\n}());\nexports.ProviderMap = ProviderMap;\n\n\n\n\n});\n\nunwrapExports(ProviderMap_1);\nvar ProviderMap_2 = ProviderMap_1.ProviderMapToken;\nvar ProviderMap_3 = ProviderMap_1.ProviderMap;\n\nvar Provider_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n *  provider, to dynamic resovle instance of params in run time.\n *\n * @export\n * @class Provider\n */\nvar Provider = /** @class */ (function () {\n    function Provider(type, value) {\n        this.type = type;\n        this.value = value;\n    }\n    /**\n     * resolve provider value.\n     *\n     * @template T\n     * @param {IContainer} container\n     * @param {Providers[]} providers\n     * @returns {T}\n     * @memberof Provider\n     */\n    Provider.prototype.resolve = function (container) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        if (utils.isUndefined(this.value)) {\n            return container.has(this.type) ? container.resolve.apply(container, [this.type].concat(providers)) : null;\n        }\n        else {\n            return this.value; // isFunction(this.value) ? this.value(container) : this.value;\n        }\n    };\n    /**\n     * create provider.\n     *\n     * @static\n     * @param {Token<any>} type\n     * @param {(any)} value\n     * @returns Provider\n     * @memberof Provider\n     */\n    Provider.create = function (type, value) {\n        return new Provider(type, value);\n    };\n    /**\n     * create extends provider.\n     *\n     * @static\n     * @param {Token<any>} token\n     * @param {(any)} value\n     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]\n     * @returns {ExtendsProvider}\n     * @memberof Provider\n     */\n    Provider.createExtends = function (token, value, extendsTarget) {\n        return new ExtendsProvider(token, value, extendsTarget);\n    };\n    // /**\n    //  * create custom provider.\n    //  *\n    //  * @static\n    //  * @param {Token<any>} [type]\n    //  * @param {ToInstance<any>} [toInstance]\n    //  * @param {*} [value]\n    //  * @returns {CustomProvider}\n    //  * @memberof Provider\n    //  */\n    // static createCustom(type?: Token<any>, toInstance?: ToInstance<any>, value?: any): CustomProvider {\n    //     return new CustomProvider(type, toInstance, value);\n    // }\n    /**\n     * create invoked provider.\n     *\n     * @static\n     * @param {Token<any>} token\n     * @param {string} method\n     * @param {(any)} [value]\n     * @returns {InvokeProvider}\n     * @memberof Provider\n     */\n    Provider.createInvoke = function (token, method, value) {\n        return new InvokeProvider(token, method, value);\n    };\n    /**\n     * create param provider.\n     *\n     * @static\n     * @param {Token<any>} token\n     * @param {(any)} value\n     * @param {number} [index]\n     * @param {string} [method]\n     * @returns {ParamProvider}\n     * @memberof Provider\n     */\n    Provider.createParam = function (token, value, index, method) {\n        return new ParamProvider(token, value, index, method);\n    };\n    // /**\n    //  * create async param provider.\n    //  *\n    //  * @static\n    //  * @param {(string | string[])} files\n    //  * @param {Token<any>} token\n    //  * @param {number} [index]\n    //  * @param {string} [method]\n    //  * @param {(any)} [value]\n    //  * @returns {AsyncParamProvider}\n    //  * @memberof Provider\n    //  */\n    // static createAsyncParam(files: string | string[], token: Token<any>, index?: number, method?: string, value?: any): AsyncParamProvider {\n    //     return new AsyncParamProvider(files, token, index, method, value)\n    // }\n    Provider.classAnnations = { \"name\": \"Provider\", \"params\": { \"constructor\": [\"type\", \"value\"], \"resolve\": [\"container\", \"providers\"], \"create\": [\"type\", \"value\"], \"createExtends\": [\"token\", \"value\", \"extendsTarget\"], \"createInvoke\": [\"token\", \"method\", \"value\"], \"createParam\": [\"token\", \"value\", \"index\", \"method\"] } };\n    return Provider;\n}());\nexports.Provider = Provider;\n/**\n * InvokeProvider\n *\n * @export\n * @class InvokeProvider\n * @extends {Provider}\n */\nvar InvokeProvider = /** @class */ (function (_super) {\n    tslib_1.__extends(InvokeProvider, _super);\n    function InvokeProvider(type, method, value) {\n        var _this = _super.call(this, type, value) || this;\n        _this.method = method;\n        return _this;\n    }\n    InvokeProvider.prototype.resolve = function (container) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        if (this.method) {\n            return container.syncInvoke.apply(container, [this.type, this.method].concat(providers));\n        }\n        return _super.prototype.resolve.apply(this, [container].concat(providers));\n    };\n    InvokeProvider.classAnnations = { \"name\": \"InvokeProvider\", \"params\": { \"constructor\": [\"type\", \"method\", \"value\"], \"resolve\": [\"container\", \"providers\"] } };\n    return InvokeProvider;\n}(Provider));\nexports.InvokeProvider = InvokeProvider;\n/**\n * param provider.\n *\n * @export\n * @interface ParamProvider\n */\nvar ParamProvider = /** @class */ (function (_super) {\n    tslib_1.__extends(ParamProvider, _super);\n    function ParamProvider(token, value, index, method) {\n        var _this = _super.call(this, token, method, value) || this;\n        _this.index = index;\n        return _this;\n    }\n    ParamProvider.prototype.resolve = function (container) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        return _super.prototype.resolve.apply(this, [container].concat(providers));\n    };\n    ParamProvider.classAnnations = { \"name\": \"ParamProvider\", \"params\": { \"constructor\": [\"token\", \"value\", \"index\", \"method\"], \"resolve\": [\"container\", \"providers\"] } };\n    return ParamProvider;\n}(InvokeProvider));\nexports.ParamProvider = ParamProvider;\n/**\n * Provider enable exntends target with provider in dynamic.\n *\n * @export\n * @class ExtendsProvider\n * @extends {Provider}\n */\nvar ExtendsProvider = /** @class */ (function (_super) {\n    tslib_1.__extends(ExtendsProvider, _super);\n    function ExtendsProvider(token, value, extendsTarget) {\n        var _this = _super.call(this, token, value) || this;\n        _this.extendsTarget = extendsTarget;\n        return _this;\n    }\n    ExtendsProvider.prototype.resolve = function (container) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        return _super.prototype.resolve.apply(this, [container].concat(providers));\n    };\n    ExtendsProvider.prototype.extends = function (target) {\n        if (utils.isObject(target) && utils.isFunction(this.extendsTarget)) {\n            this.extendsTarget(target, this);\n        }\n    };\n    ExtendsProvider.classAnnations = { \"name\": \"ExtendsProvider\", \"params\": { \"constructor\": [\"token\", \"value\", \"extendsTarget\"], \"resolve\": [\"container\", \"providers\"], \"extends\": [\"target\"] } };\n    return ExtendsProvider;\n}(Provider));\nexports.ExtendsProvider = ExtendsProvider;\n\n\n\n\n});\n\nunwrapExports(Provider_1);\nvar Provider_2 = Provider_1.Provider;\nvar Provider_3 = Provider_1.InvokeProvider;\nvar Provider_4 = Provider_1.ParamProvider;\nvar Provider_5 = Provider_1.ExtendsProvider;\n\nvar providers = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\ntslib_1.__exportStar(Provider_1, exports);\n// export * from './ExtendsProvider';\ntslib_1.__exportStar(ProviderMap_1, exports);\n// export * from './InvokeProvider';\n// export * from './ParamProvider';\n// export * from './AsyncParamProvider';\n/**\n * object is provider map or not.\n *\n * @export\n * @param {object} target\n * @returns {target is ProviderMap}\n */\nfunction isProviderMap(target) {\n    if (!utils.isObject(target)) {\n        return false;\n    }\n    return target instanceof ProviderMap_1.ProviderMap;\n}\nexports.isProviderMap = isProviderMap;\n\n\n\n\n});\n\nunwrapExports(providers);\nvar providers_1 = providers.isProviderMap;\n\nvar IRecognizer = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * IRecognizer interface token.\n * it is a token id, you can register yourself IRecognizer for this.\n */\nexports.RecognizerToken = new InjectToken_1.InjectToken('DI_IRecognizer');\n\n\n\n\n});\n\nunwrapExports(IRecognizer);\nvar IRecognizer_1 = IRecognizer.RecognizerToken;\n\nvar IProviderMatcher = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * Providers match interface symbol.\n * it is a symbol id, you can register yourself MethodAccessor for this.\n */\nexports.ProviderMatcherToken = new InjectToken_1.InjectToken('DI_IProviderMatcher');\n\n\n\n\n});\n\nunwrapExports(IProviderMatcher);\nvar IProviderMatcher_1 = IProviderMatcher.ProviderMatcherToken;\n\nvar MethodAutorun_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n/**\n * Inject DrawType action.\n *\n * @export\n * @class SetPropAction\n * @extends {ActionComposite}\n */\nvar MethodAutorun = /** @class */ (function (_super) {\n    tslib_1.__extends(MethodAutorun, _super);\n    function MethodAutorun() {\n        return _super.call(this, CoreActions_1.CoreActions.methodAutorun) || this;\n    }\n    MethodAutorun.prototype.working = function (container, data) {\n        if (data.raiseContainer && data.raiseContainer !== container) {\n            return;\n        }\n        if (data.target && data.targetType) {\n            if (factories.hasMethodMetadata(decorators.Autorun, data.targetType)) {\n                var metas = factories.getMethodMetadata(decorators.Autorun, data.targetType);\n                var lastmetas_1 = [];\n                var idx_1 = utils.lang.keys(metas).length;\n                utils.lang.forIn(metas, function (mm, key) {\n                    if (mm && mm.length) {\n                        var m = mm[0];\n                        m.autorun = key;\n                        idx_1++;\n                        if (!utils.isNumber(m.order)) {\n                            m.order = idx_1;\n                        }\n                        lastmetas_1.push(m);\n                    }\n                });\n                lastmetas_1.sort(function (au1, au2) {\n                    return au1.order - au1.order;\n                }).forEach(function (aut) {\n                    container.syncInvoke(data.targetType, aut.autorun, data.target);\n                });\n            }\n        }\n    };\n    MethodAutorun.classAnnations = { \"name\": \"MethodAutorun\", \"params\": { \"constructor\": [], \"working\": [\"container\", \"data\"] } };\n    return MethodAutorun;\n}(ActionComposite_1.ActionComposite));\nexports.MethodAutorun = MethodAutorun;\n\n\n\n\n});\n\nunwrapExports(MethodAutorun_1);\nvar MethodAutorun_2 = MethodAutorun_1.MethodAutorun;\n\nvar ActionFactory_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * action factory.\n *\n * @export\n * @class ActionFactory\n */\nvar ActionFactory = /** @class */ (function () {\n    function ActionFactory() {\n    }\n    /**\n     * create action by action type. type in 'CoreActions'\n     *\n     * @param {string} type\n     * @returns {ActionComponent}\n     * @memberof ActionFactory\n     */\n    ActionFactory.prototype.create = function (type) {\n        var action;\n        switch (type) {\n            case actions.CoreActions.bindParameterType:\n                action = new actions.BindParameterTypeAction();\n                break;\n            case actions.CoreActions.bindPropertyType:\n                action = new actions.BindPropertyTypeAction();\n                break;\n            case actions.CoreActions.injectProperty:\n                action = new actions.InjectPropertyAction();\n                break;\n            case actions.CoreActions.bindProvider:\n                action = new actions.BindProviderAction();\n                break;\n            case actions.CoreActions.bindParameterProviders:\n                action = new actions.BindParameterProviderAction();\n                break;\n            case actions.CoreActions.componentInit:\n                action = new actions.ComponentInitAction();\n                break;\n            case actions.CoreActions.componentBeforeInit:\n                action = new actions.ComponentBeforeInitAction();\n                break;\n            case actions.CoreActions.componentAfterInit:\n                action = new actions.ComponentAfterInitAction();\n                break;\n            case actions.CoreActions.cache:\n                action = new actions.CacheAction();\n                break;\n            case actions.CoreActions.singletion:\n                action = new actions.SingletionAction();\n                break;\n            case actions.CoreActions.autorun:\n                action = new actions.AutorunAction();\n                break;\n            case actions.CoreActions.methodAutorun:\n                action = new MethodAutorun_1.MethodAutorun();\n                break;\n            default:\n                action = new actions.ActionComposite(type);\n                break;\n        }\n        return action;\n    };\n    ActionFactory.classAnnations = { \"name\": \"ActionFactory\", \"params\": { \"create\": [\"type\"] } };\n    return ActionFactory;\n}());\nexports.ActionFactory = ActionFactory;\n\n\n\n\n});\n\nunwrapExports(ActionFactory_1);\nvar ActionFactory_2 = ActionFactory_1.ActionFactory;\n\nvar DefaultLifeScope_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n/**\n * default implement life scope.\n *\n * @export\n * @class DefaultLifeScope\n * @implements {LifeScope}\n */\nvar DefaultLifeScope = /** @class */ (function () {\n    function DefaultLifeScope(container) {\n        this.container = container;\n        this.decorators = [];\n        this.buildAction();\n    }\n    DefaultLifeScope.prototype.addAction = function (action) {\n        var nodepaths = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            nodepaths[_i - 1] = arguments[_i];\n        }\n        var parent = this.action;\n        nodepaths.forEach(function (pathname) {\n            parent = parent.find(function (act) { return act.name === pathname; });\n        });\n        if (parent) {\n            parent.add(action);\n        }\n        return this;\n    };\n    DefaultLifeScope.prototype.registerDecorator = function (decorator) {\n        var actions$$2 = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            actions$$2[_i - 1] = arguments[_i];\n        }\n        var type = this.getDecoratorType(decorator);\n        return this.registerCustomDecorator.apply(this, [decorator, type].concat(actions$$2));\n    };\n    DefaultLifeScope.prototype.registerCustomDecorator = function (decorator, type) {\n        var actions$$2 = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            actions$$2[_i - 2] = arguments[_i];\n        }\n        var types$$2 = this.toActionName(type);\n        var name = decorator.toString();\n        if (!this.decorators.some(function (d) { return d.name === name; })) {\n            this.decorators.push({\n                name: name,\n                types: types$$2,\n                actions: actions$$2\n            });\n        }\n        return this;\n    };\n    DefaultLifeScope.prototype.execute = function (data) {\n        var names = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            names[_i - 1] = arguments[_i];\n        }\n        names = names.filter(function (n) { return !!n; });\n        var act = this.action;\n        names.forEach(function (name) {\n            act = act.find(function (itm) { return itm.name === name; });\n        });\n        if (act) {\n            act.execute(this.container, data);\n        }\n    };\n    DefaultLifeScope.prototype.routeExecute = function (data) {\n        var names = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            names[_i - 1] = arguments[_i];\n        }\n        var _a;\n        this.execute.apply(this, [data].concat(names));\n        var container = this.container.parent;\n        while (container) {\n            (_a = container.getLifeScope()).execute.apply(_a, [utils.lang.assign({}, data)].concat(names));\n            container = container.parent;\n        }\n    };\n    DefaultLifeScope.prototype.getClassDecorators = function (match) {\n        return this.getTypeDecorators(this.toActionName(factories.DecoratorType.Class), match);\n    };\n    DefaultLifeScope.prototype.getMethodDecorators = function (match) {\n        return this.getTypeDecorators(this.toActionName(factories.DecoratorType.Method), match);\n    };\n    DefaultLifeScope.prototype.getPropertyDecorators = function (match) {\n        return this.getTypeDecorators(this.toActionName(factories.DecoratorType.Property), match);\n    };\n    DefaultLifeScope.prototype.getParameterDecorators = function (match) {\n        return this.getTypeDecorators(this.toActionName(factories.DecoratorType.Parameter), match);\n    };\n    DefaultLifeScope.prototype.getDecoratorType = function (decirator) {\n        return decirator.decoratorType || factories.DecoratorType.All;\n    };\n    /**\n     * is vaildate dependence type or not. dependence type must with class decorator.\n     *\n     * @template T\n     * @param {Type<T>} target\n     * @returns {boolean}\n     * @memberof Container\n     */\n    DefaultLifeScope.prototype.isVaildDependence = function (target) {\n        if (!target) {\n            return false;\n        }\n        if (!utils.isClass(target)) {\n            return false;\n        }\n        if (utils.isAbstractDecoratorClass(target)) {\n            return false;\n        }\n        return this.getClassDecorators().some(function (act) { return factories.hasOwnClassMetadata(act.name, target); });\n    };\n    DefaultLifeScope.prototype.getAtionByName = function (name) {\n        return this.action.find(function (action) { return action.name === name; });\n    };\n    DefaultLifeScope.prototype.getClassAction = function () {\n        return this.getAtionByName(this.toActionName(factories.DecoratorType.Class));\n    };\n    DefaultLifeScope.prototype.getMethodAction = function () {\n        return this.getAtionByName(this.toActionName(factories.DecoratorType.Method));\n    };\n    DefaultLifeScope.prototype.getPropertyAction = function () {\n        return this.getAtionByName(this.toActionName(factories.DecoratorType.Property));\n    };\n    DefaultLifeScope.prototype.getParameterAction = function () {\n        return this.getAtionByName(this.toActionName(factories.DecoratorType.Parameter));\n    };\n    /**\n     * get constructor parameters metadata.\n     *\n     * @template T\n     * @param {Type<T>} type\n     * @returns {IParameter[]}\n     * @memberof IContainer\n     */\n    DefaultLifeScope.prototype.getConstructorParameters = function (type) {\n        return this.getParameters(type);\n    };\n    /**\n     * get method params metadata.\n     *\n     * @template T\n     * @param {Type<T>} type\n     * @param {T} instance\n     * @param {(string | symbol)} propertyKey\n     * @returns {IParameter[]}\n     * @memberof IContainer\n     */\n    DefaultLifeScope.prototype.getMethodParameters = function (type, instance, propertyKey) {\n        return this.getParameters(type, instance, propertyKey);\n    };\n    /**\n     * get paramerter names.\n     *\n     * @template T\n     * @param {Type<T>} type\n     * @param {string} propertyKey\n     * @returns {string[]}\n     * @memberof DefaultLifeScope\n     */\n    DefaultLifeScope.prototype.getParamerterNames = function (type, propertyKey) {\n        var metadata = factories.getOwnParamerterNames(type);\n        var paramNames = [];\n        if (metadata && metadata.hasOwnProperty(propertyKey)) {\n            paramNames = metadata[propertyKey];\n        }\n        if (!utils.isArray(paramNames)) {\n            paramNames = [];\n        }\n        return paramNames;\n    };\n    DefaultLifeScope.prototype.isSingletonType = function (type) {\n        if (factories.hasOwnClassMetadata(decorators.Singleton, type)) {\n            return true;\n        }\n        return this.getClassDecorators().some(function (surm) {\n            var metadatas = factories.getOwnTypeMetadata(surm.name, type) || [];\n            if (utils.isArray(metadatas)) {\n                return metadatas.some(function (m) { return m.singleton === true; });\n            }\n            return false;\n        });\n    };\n    DefaultLifeScope.prototype.getMethodMetadatas = function (type, propertyKey) {\n        var metadatas = [];\n        this.getMethodDecorators().forEach(function (dec) {\n            var metas = factories.getOwnMethodMetadata(dec.name, type);\n            if (metas.hasOwnProperty(propertyKey)) {\n                metadatas = metadatas.concat(metas[propertyKey] || []);\n            }\n        });\n        return metadatas;\n    };\n    DefaultLifeScope.prototype.filerDecorators = function (express) {\n        return this.decorators.filter(express);\n    };\n    DefaultLifeScope.prototype.getParameters = function (type, instance, propertyKey) {\n        propertyKey = propertyKey || 'constructor';\n        var data = {\n            target: instance,\n            targetType: type,\n            propertyKey: propertyKey\n        };\n        this.execute(data, actions.LifeState.onInit, actions.CoreActions.bindParameterType);\n        var paramNames = this.getParamerterNames(type, propertyKey);\n        if (data.execResult.length) {\n            return data.execResult.map(function (typ, idx) {\n                return {\n                    type: typ,\n                    name: paramNames[idx]\n                };\n            });\n        }\n        else {\n            return paramNames.map(function (name) {\n                return {\n                    name: name,\n                    type: undefined\n                };\n            });\n        }\n    };\n    DefaultLifeScope.prototype.getTypeDecorators = function (decType, match) {\n        return this.filerDecorators(function (value) {\n            var flag = (value.types || '').indexOf(decType) >= 0;\n            if (flag && match) {\n                flag = match(value);\n            }\n            return flag;\n        });\n    };\n    DefaultLifeScope.prototype.buildAction = function () {\n        var factory = new ActionFactory_1.ActionFactory();\n        var action = factory.create('');\n        action\n            .add(factory.create(types.IocState.design)\n            .add(factory.create(actions.CoreActions.bindProvider))\n            .add(factory.create(actions.CoreActions.autorun)))\n            .add(factory.create(types.IocState.runtime)\n            .add(factory.create(actions.LifeState.beforeCreateArgs))\n            .add(factory.create(actions.LifeState.beforeConstructor))\n            .add(factory.create(actions.LifeState.afterConstructor))\n            .add(factory.create(actions.LifeState.onInit)\n            .add(factory.create(actions.CoreActions.componentBeforeInit))\n            .add(factory.create(this.toActionName(factories.DecoratorType.Class)))\n            .add(factory.create(this.toActionName(factories.DecoratorType.Method)))\n            .add(factory.create(this.toActionName(factories.DecoratorType.Property))\n            .add(factory.create(actions.CoreActions.bindPropertyType))\n            .add(factory.create(actions.CoreActions.injectProperty)))\n            .add(factory.create(this.toActionName(factories.DecoratorType.Parameter))\n            .add(factory.create(actions.CoreActions.bindParameterType))\n            .add(factory.create(actions.CoreActions.bindParameterProviders)))\n            .add(factory.create(actions.CoreActions.componentInit)))\n            .add(factory.create(actions.LifeState.AfterInit)\n            .add(factory.create(actions.CoreActions.singletion))\n            .add(factory.create(actions.CoreActions.componentAfterInit))\n            .add(factory.create(actions.CoreActions.methodAutorun))))\n            .add(factory.create(actions.CoreActions.cache));\n        this.action = action;\n    };\n    DefaultLifeScope.prototype.toActionName = function (type) {\n        var types$$2 = [];\n        if (type & factories.DecoratorType.Class) {\n            types$$2.push('ClassDecorator');\n        }\n        if (type & factories.DecoratorType.Method) {\n            types$$2.push('MethodDecorator');\n        }\n        if (type & factories.DecoratorType.Property) {\n            types$$2.push('PropertyDecorator');\n        }\n        if (type & factories.DecoratorType.Parameter) {\n            types$$2.push('ParameterDecorator');\n        }\n        return types$$2.join(',');\n    };\n    DefaultLifeScope.classAnnations = { \"name\": \"DefaultLifeScope\", \"params\": { \"constructor\": [\"container\"], \"addAction\": [\"action\", \"nodepaths\"], \"registerDecorator\": [\"decorator\", \"actions\"], \"registerCustomDecorator\": [\"decorator\", \"type\", \"actions\"], \"execute\": [\"data\", \"names\"], \"routeExecute\": [\"data\", \"names\"], \"getClassDecorators\": [\"match\"], \"getMethodDecorators\": [\"match\"], \"getPropertyDecorators\": [\"match\"], \"getParameterDecorators\": [\"match\"], \"getDecoratorType\": [\"decirator\"], \"isVaildDependence\": [\"target\"], \"getAtionByName\": [\"name\"], \"getClassAction\": [], \"getMethodAction\": [], \"getPropertyAction\": [], \"getParameterAction\": [], \"getConstructorParameters\": [\"type\"], \"getMethodParameters\": [\"type\", \"instance\", \"propertyKey\"], \"getParamerterNames\": [\"type\", \"propertyKey\"], \"isSingletonType\": [\"type\"], \"getMethodMetadatas\": [\"type\", \"propertyKey\"], \"filerDecorators\": [\"express\"], \"getParameters\": [\"type\", \"instance\", \"propertyKey\"], \"getTypeDecorators\": [\"decType\", \"match\"], \"buildAction\": [], \"toActionName\": [\"type\"] } };\n    return DefaultLifeScope;\n}());\nexports.DefaultLifeScope = DefaultLifeScope;\n\n\n\n\n});\n\nunwrapExports(DefaultLifeScope_1);\nvar DefaultLifeScope_2 = DefaultLifeScope_1.DefaultLifeScope;\n\nvar ProviderMatcher_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * provider matcher. use to find custome providers in resolve.\n *\n * @export\n * @class ProviderMatcher\n * @implements {IProviderMatcher}\n */\nvar ProviderMatcher = /** @class */ (function () {\n    function ProviderMatcher(container) {\n        this.container = container;\n    }\n    ProviderMatcher.prototype.toProviderMap = function () {\n        var _this = this;\n        var providers$$1 = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            providers$$1[_i] = arguments[_i];\n        }\n        if (providers$$1.length === 1 && providers.isProviderMap(providers$$1[0])) {\n            return providers$$1[0];\n        }\n        var map = this.container.resolve(providers.ProviderMapToken);\n        providers$$1.forEach(function (p, index) {\n            if (utils.isUndefined(p) || utils.isNull(p)) {\n                return;\n            }\n            if (providers.isProviderMap(p)) {\n                map.copy(p);\n            }\n            else if (p instanceof providers.Provider) {\n                if (p instanceof providers.ParamProvider) {\n                    if (!p.type && utils.isNumber(p.index)) {\n                        map.add(p.index, function () {\n                            var providers$$1 = [];\n                            for (var _i = 0; _i < arguments.length; _i++) {\n                                providers$$1[_i] = arguments[_i];\n                            }\n                            return p.resolve.apply(p, [_this.container].concat(providers$$1));\n                        });\n                    }\n                    else {\n                        map.add(p.type, function () {\n                            var providers$$1 = [];\n                            for (var _i = 0; _i < arguments.length; _i++) {\n                                providers$$1[_i] = arguments[_i];\n                            }\n                            return p.resolve.apply(p, [_this.container].concat(providers$$1));\n                        });\n                    }\n                }\n                else {\n                    map.add(p.type, function () {\n                        var providers$$1 = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            providers$$1[_i] = arguments[_i];\n                        }\n                        return p.resolve.apply(p, [_this.container].concat(providers$$1));\n                    });\n                }\n            }\n            else if (utils.isClass(p)) {\n                if (!_this.container.has(p)) {\n                    _this.container.register(p);\n                }\n                map.add(p, p);\n            }\n            else if (utils.isBaseObject(p)) {\n                var pr_1 = p;\n                var isobjMap = false;\n                if (utils.isToken(pr_1.provide)) {\n                    if (utils.isArray(pr_1.deps) && pr_1.deps.length) {\n                        pr_1.deps.forEach(function (d) {\n                            if (utils.isClass(d) && !_this.container.has(d)) {\n                                _this.container.register(d);\n                            }\n                        });\n                    }\n                    if (!utils.isUndefined(pr_1.useValue)) {\n                        map.add(pr_1.provide, function () { return pr_1.useValue; });\n                    }\n                    else if (utils.isClass(pr_1.useClass)) {\n                        if (!_this.container.has(pr_1.useClass)) {\n                            _this.container.register(pr_1.useClass);\n                        }\n                        map.add(pr_1.provide, pr_1.useClass);\n                    }\n                    else if (utils.isFunction(pr_1.useFactory)) {\n                        map.add(pr_1.provide, function () {\n                            var args = [];\n                            if (utils.isArray(pr_1.deps) && pr_1.deps.length) {\n                                args = pr_1.deps.map(function (d) {\n                                    if (utils.isClass(d)) {\n                                        return _this.container.get(d);\n                                    }\n                                    else {\n                                        return d;\n                                    }\n                                });\n                            }\n                            return pr_1.useFactory.apply(pr_1, args);\n                        });\n                    }\n                    else if (utils.isToken(pr_1.useExisting)) {\n                        if (_this.container.has(pr_1.useExisting)) {\n                            map.add(pr_1.provide, function () { return _this.container.resolve(pr_1.useExisting); });\n                        }\n                        else {\n                            console.log('has not register:', pr_1.useExisting);\n                        }\n                    }\n                    else {\n                        isobjMap = true;\n                    }\n                }\n                else {\n                    isobjMap = true;\n                }\n                if (isobjMap) {\n                    utils.lang.forIn(p, function (val, name) {\n                        if (!utils.isUndefined(val)) {\n                            if (utils.isClass(val)) {\n                                map.add(name, val);\n                            }\n                            else if (utils.isFunction(val) || utils.isString(val)) {\n                                map.add(name, function () { return val; });\n                            }\n                            else {\n                                map.add(name, val);\n                            }\n                        }\n                    });\n                }\n            }\n            else if (utils.isFunction(p)) {\n                map.add(name, function () { return p; });\n            }\n            else {\n                map.add(index, p);\n            }\n        });\n        return map;\n    };\n    ProviderMatcher.prototype.matchProviders = function (params) {\n        var providers$$1 = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers$$1[_i - 1] = arguments[_i];\n        }\n        return this.match(params, this.toProviderMap.apply(this, providers$$1));\n    };\n    ProviderMatcher.prototype.match = function (params, providers$$1) {\n        var _this = this;\n        var map = this.container.resolve(providers.ProviderMapToken);\n        if (!params.length) {\n            return map;\n        }\n        params.forEach(function (param, index) {\n            if (!param.name) {\n                return;\n            }\n            if (providers$$1.has(param.name)) {\n                map.add(param.name, providers$$1.get(param.name));\n            }\n            else if (utils.isToken(param.type)) {\n                if (providers$$1.has(param.type)) {\n                    map.add(param.name, providers$$1.get(param.type));\n                }\n                else if (_this.container.has(param.type)) {\n                    map.add(param.name, param.type);\n                }\n            }\n            else if (providers$$1.has(index)) {\n                map.add(param.name, providers$$1.get(index));\n            }\n        });\n        return map;\n    };\n    ProviderMatcher.classAnnations = { \"name\": \"ProviderMatcher\", \"params\": { \"constructor\": [\"container\"], \"toProviderMap\": [\"providers\"], \"matchProviders\": [\"params\", \"providers\"], \"match\": [\"params\", \"providers\"] } };\n    return ProviderMatcher;\n}());\nexports.ProviderMatcher = ProviderMatcher;\n\n\n\n\n});\n\nunwrapExports(ProviderMatcher_1);\nvar ProviderMatcher_2 = ProviderMatcher_1.ProviderMatcher;\n\nvar MethodAccessor_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * method accessor\n *\n * @export\n * @class MethodAccessor\n * @implements {IMethodAccessor}\n */\nvar MethodAccessor = /** @class */ (function () {\n    function MethodAccessor(container) {\n        this.container = container;\n    }\n    MethodAccessor.prototype.getMatcher = function () {\n        return this.container.get(IProviderMatcher.ProviderMatcherToken);\n    };\n    MethodAccessor.prototype.invoke = function (token, propertyKey, target) {\n        var providers = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            providers[_i - 3] = arguments[_i];\n        }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _a, targetClass, actionData, lifeScope, parameters, paramInstances;\n            return tslib_1.__generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!target) {\n                            target = (_a = this.container).resolve.apply(_a, [token].concat(providers));\n                        }\n                        targetClass = this.container.getTokenImpl(token);\n                        if (!targetClass) {\n                            throw Error(token.toString() + ' is not implements by any class.');\n                        }\n                        if (!(target && utils.isFunction(target[propertyKey]))) return [3 /*break*/, 2];\n                        actionData = {\n                            target: target,\n                            targetType: targetClass,\n                            propertyKey: propertyKey,\n                        };\n                        lifeScope = this.container.getLifeScope();\n                        lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);\n                        providers = providers.concat(actionData.execResult);\n                        parameters = lifeScope.getMethodParameters(targetClass, target, propertyKey);\n                        return [4 /*yield*/, this.createParams.apply(this, [parameters].concat(providers))];\n                    case 1:\n                        paramInstances = _b.sent();\n                        return [2 /*return*/, target[propertyKey].apply(target, paramInstances)];\n                    case 2: throw new Error(\"type: \" + targetClass + \" has no method \" + propertyKey.toString() + \".\");\n                }\n            });\n        });\n    };\n    MethodAccessor.prototype.syncInvoke = function (token, propertyKey, target) {\n        var providers = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            providers[_i - 3] = arguments[_i];\n        }\n        var _a;\n        if (!target) {\n            target = (_a = this.container).resolve.apply(_a, [token].concat(providers));\n        }\n        var targetClass = this.container.getTokenImpl(token);\n        if (!targetClass) {\n            throw Error(token.toString() + ' is not implements by any class.');\n        }\n        if (target && utils.isFunction(target[propertyKey])) {\n            var actionData = {\n                target: target,\n                targetType: targetClass,\n                propertyKey: propertyKey,\n            };\n            var lifeScope = this.container.getLifeScope();\n            lifeScope.execute(actionData, actions.LifeState.onInit, actions.CoreActions.bindParameterProviders);\n            providers = providers.concat(actionData.execResult);\n            var parameters = lifeScope.getMethodParameters(targetClass, target, propertyKey);\n            var paramInstances = this.createSyncParams.apply(this, [parameters].concat(providers));\n            return target[propertyKey].apply(target, paramInstances);\n        }\n        else {\n            throw new Error(\"type: \" + targetClass + \" has no method \" + propertyKey.toString() + \".\");\n        }\n    };\n    MethodAccessor.prototype.createSyncParams = function (params) {\n        var _this = this;\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a;\n        var providerMap = (_a = this.getMatcher()).matchProviders.apply(_a, [params].concat(providers));\n        return params.map(function (param, index) {\n            var _a;\n            if (param.name && providerMap.has(param.name)) {\n                return providerMap.resolve(param.name);\n            }\n            else if (utils.isToken(param.type)) {\n                return (_a = _this.container).resolve.apply(_a, [param.type].concat(providers));\n            }\n            else {\n                return undefined;\n            }\n        });\n    };\n    MethodAccessor.prototype.createParams = function (params) {\n        var _this = this;\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a;\n        var providerMap = (_a = this.getMatcher()).matchProviders.apply(_a, [params].concat(providers));\n        return Promise.all(params.map(function (param, index) {\n            var _a;\n            if (param.name && providerMap.has(param.name)) {\n                return providerMap.resolve(param.name);\n            }\n            else if (utils.isToken(param.type)) {\n                return (_a = _this.container).resolve.apply(_a, [param.type].concat(providers));\n            }\n            else {\n                return undefined;\n            }\n        }));\n    };\n    MethodAccessor.classAnnations = { \"name\": \"MethodAccessor\", \"params\": { \"constructor\": [\"container\"], \"getMatcher\": [], \"invoke\": [\"token\", \"propertyKey\", \"target\", \"providers\"], \"syncInvoke\": [\"token\", \"propertyKey\", \"target\", \"providers\"], \"createSyncParams\": [\"params\", \"providers\"], \"createParams\": [\"params\", \"providers\"] } };\n    return MethodAccessor;\n}());\nexports.MethodAccessor = MethodAccessor;\n\n\n\n\n});\n\nunwrapExports(MethodAccessor_1);\nvar MethodAccessor_2 = MethodAccessor_1.MethodAccessor;\n\nvar CacheManager_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * cache manager.\n *\n * @export\n * @class CacheManager\n * @implements {ICacheManager}\n */\nvar CacheManager = /** @class */ (function () {\n    function CacheManager(container) {\n        this.container = container;\n        this.cacheTokens = new utils.MapSet();\n    }\n    CacheManager.prototype.isChecking = function () {\n        return !!this.timeout;\n    };\n    CacheManager.prototype.hasCache = function (targetType) {\n        return this.cacheTokens.has(targetType);\n    };\n    CacheManager.prototype.cache = function (targetType, target, expires) {\n        var cache;\n        if (this.hasCache(targetType)) {\n            cache = this.cacheTokens.get(targetType);\n            cache.expires = Date.now() + expires;\n        }\n        else {\n            cache = {\n                target: target,\n                expires: Date.now() + expires\n            };\n        }\n        this.cacheTokens.set(targetType, cache);\n        if (!this.isChecking()) {\n            this.checkExpires();\n        }\n    };\n    CacheManager.prototype.get = function (targetType, expires) {\n        var result = null;\n        if (!this.cacheTokens.has(targetType)) {\n            return null;\n        }\n        var cache = this.cacheTokens.get(targetType);\n        if (cache.expires <= Date.now()) {\n            result = cache.target;\n            if (utils.isNumber(expires) && expires > 0) {\n                cache.expires = Date.now() + expires;\n                this.cacheTokens.set(targetType, cache);\n            }\n        }\n        else {\n            this.destroy(targetType, cache.target);\n        }\n        return result;\n    };\n    CacheManager.prototype.checkExpires = function () {\n        var _this = this;\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = 0;\n        }\n        if (this.cacheTokens.size > 0) {\n            var timeoutCaches_1 = [];\n            this.cacheTokens.forEach(function (cache, targetType) {\n                if (cache.expires >= Date.now()) {\n                    timeoutCaches_1.push(targetType);\n                }\n            });\n            if (timeoutCaches_1.length) {\n                timeoutCaches_1.forEach(function (targetType) {\n                    _this.destroy(targetType, _this.cacheTokens.get(targetType).target);\n                });\n            }\n            this.timeout = setTimeout(function () {\n                _this.checkExpires();\n            }, 60000);\n        }\n    };\n    CacheManager.prototype.destroy = function (targetType, target) {\n        if (!this.hasCache(targetType)) {\n            return;\n        }\n        if (!target) {\n            target = this.cacheTokens.get(targetType).target;\n        }\n        try {\n            var component = target;\n            if (utils.isFunction(component.onDestroy)) {\n                this.container.syncInvoke(targetType, 'onDestroy', target);\n            }\n            this.cacheTokens.delete(targetType);\n        }\n        catch (err) {\n            console.error && console.error(err);\n        }\n    };\n    CacheManager.classAnnations = { \"name\": \"CacheManager\", \"params\": { \"constructor\": [\"container\"], \"isChecking\": [], \"hasCache\": [\"targetType\"], \"cache\": [\"targetType\", \"target\", \"expires\"], \"get\": [\"targetType\", \"expires\"], \"checkExpires\": [], \"destroy\": [\"targetType\", \"target\"] } };\n    return CacheManager;\n}());\nexports.CacheManager = CacheManager;\n\n\n\n\n});\n\nunwrapExports(CacheManager_1);\nvar CacheManager_2 = CacheManager_1.CacheManager;\n\nvar core = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(actions, exports);\ntslib_1.__exportStar(decorators, exports);\ntslib_1.__exportStar(factories, exports);\ntslib_1.__exportStar(providers, exports);\ntslib_1.__exportStar(IRecognizer, exports);\ntslib_1.__exportStar(IProviderMatcher, exports);\ntslib_1.__exportStar(ActionFactory_1, exports);\ntslib_1.__exportStar(DefaultLifeScope_1, exports);\ntslib_1.__exportStar(ProviderMatcher_1, exports);\ntslib_1.__exportStar(MethodAccessor_1, exports);\ntslib_1.__exportStar(CacheManager_1, exports);\n\n\n\n\n});\n\nunwrapExports(core);\n\nvar LifeScope = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * life scope interface symbol.\n * it is a symbol id, you can register yourself MethodAccessor for this.\n */\nexports.LifeScopeToken = new InjectToken_1.InjectToken('DI_LifeScope');\n\n\n\n\n});\n\nunwrapExports(LifeScope);\nvar LifeScope_1 = LifeScope.LifeScopeToken;\n\nvar IContainerBuilder = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * ContainerBuilder interface token.\n * it is a token id, you can register yourself IContainerBuilder for this.\n */\nexports.ContainerBuilderToken = new InjectToken_1.InjectToken('DI_IContainerBuilder');\n\n\n\n\n});\n\nunwrapExports(IContainerBuilder);\nvar IContainerBuilder_1 = IContainerBuilder.ContainerBuilderToken;\n\nvar ResolverChain_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\nexports.ResolverChainToken = new InjectToken_1.InjectToken('di_ResolverChain');\nvar ResolverChain = /** @class */ (function () {\n    function ResolverChain(container) {\n        this.container = container;\n        this.resolvers = [];\n    }\n    ResolverChain.prototype.next = function (resolver) {\n        if (!this.hasResolver(resolver)) {\n            this.resolvers.push(resolver);\n        }\n    };\n    ResolverChain.prototype.toArray = function () {\n        return [this.container].concat(this.resolvers);\n    };\n    ResolverChain.prototype.hasResolver = function (resolver) {\n        if (resolver instanceof Container_1.Container) {\n            return this.resolvers.indexOf(resolver) >= 0;\n        }\n        else {\n            return this.resolvers.some(function (a) {\n                if (a instanceof Container_1.Container) {\n                    return false;\n                }\n                else {\n                    if (!a.type || !resolver.type) {\n                        return false;\n                    }\n                    return a.type === resolver.type;\n                }\n            });\n        }\n    };\n    ResolverChain.prototype.hasToken = function (resolver, token) {\n        var _this = this;\n        if (!token) {\n            return false;\n        }\n        if (resolver instanceof Container_1.Container) {\n            return resolver.hasRegister(token);\n        }\n        else {\n            if (resolver.type === token || this.container.getTokenKey(resolver.token) === token) {\n                return true;\n            }\n            var exps_1 = resolver.exports || [];\n            return exps_1.concat(resolver.providers || []).some(function (t) {\n                if (_this.container.getTokenKey(t) === token) {\n                    return true;\n                }\n                else if (!utils.isClass(token)) {\n                    if (resolver.container.hasRegister(token)) {\n                        var type = resolver.container.getTokenImpl(token);\n                        return exps_1.indexOf(type) >= 0;\n                    }\n                }\n                return false;\n            });\n        }\n    };\n    ResolverChain.prototype.resolve = function (token) {\n        var _this = this;\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a, _b;\n        var resolver = this.toArray().find(function (r) { return _this.hasToken(r, token); });\n        if (!resolver && !this.container.parent) {\n            console.log('have not register', token);\n            return null;\n        }\n        if (resolver) {\n            if (resolver instanceof Container_1.Container) {\n                return resolver.resolveValue.apply(resolver, [token].concat(providers));\n            }\n            else {\n                return (_a = resolver.container).resolveValue.apply(_a, [token].concat(providers));\n            }\n        }\n        else {\n            return (_b = this.container.parent).resolve.apply(_b, [token].concat(providers));\n        }\n    };\n    ResolverChain.prototype.unregister = function (token) {\n        var _this = this;\n        var resolver = this.toArray().find(function (r) { return _this.hasToken(r, token); });\n        if (resolver) {\n            if (resolver instanceof Container_1.Container) {\n                resolver.unregister(token, false);\n            }\n            else {\n                var idx = this.resolvers.indexOf(resolver);\n                if (idx >= 0 && idx < this.resolvers.length) {\n                    this.resolvers.splice(idx, 1);\n                }\n            }\n        }\n        else if (this.container.parent) {\n            this.container.parent.unregister(token);\n        }\n    };\n    ResolverChain.prototype.getTokenImpl = function (token) {\n        var _this = this;\n        var resolver = this.toArray().find(function (r) { return _this.hasToken(r, token); });\n        if (resolver) {\n            if (resolver instanceof Container_1.Container) {\n                return resolver.getTokenImpl(token, false);\n            }\n            else {\n                return resolver.container.getTokenImpl(token, false);\n            }\n        }\n        else if (this.container.parent) {\n            return this.container.parent.getTokenImpl(token);\n        }\n        else {\n            return null;\n        }\n    };\n    ResolverChain.prototype.hasRegister = function (token) {\n        var _this = this;\n        if (this.container.hasRegister(token)) {\n            return true;\n        }\n        if (this.resolvers.length) {\n            return this.resolvers.some(function (r) { return _this.hasToken(r, token); });\n        }\n        return false;\n    };\n    ResolverChain.prototype.has = function (token) {\n        if (this.hasRegister(token)) {\n            return true;\n        }\n        if (this.container.parent) {\n            return this.container.parent.has(token);\n        }\n        return false;\n    };\n    ResolverChain.classAnnations = { \"name\": \"ResolverChain\", \"params\": { \"constructor\": [\"container\"], \"next\": [\"resolver\"], \"toArray\": [], \"hasResolver\": [\"resolver\"], \"hasToken\": [\"resolver\", \"token\"], \"resolve\": [\"token\", \"providers\"], \"unregister\": [\"token\"], \"getTokenImpl\": [\"token\"], \"hasRegister\": [\"token\"], \"has\": [\"token\"] } };\n    return ResolverChain;\n}());\nexports.ResolverChain = ResolverChain;\n\n\n\n\n});\n\nunwrapExports(ResolverChain_1);\nvar ResolverChain_2 = ResolverChain_1.ResolverChainToken;\nvar ResolverChain_3 = ResolverChain_1.ResolverChain;\n\nvar resolves = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(ResolverChain_1, exports);\n\n\n\n\n});\n\nunwrapExports(resolves);\n\nvar registerCores_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n/**\n * register core for container.\n *\n * @export\n * @param {IContainer} container\n */\nfunction registerCores(container) {\n    container.registerSingleton(LifeScope.LifeScopeToken, function () { return new DefaultLifeScope_1.DefaultLifeScope(container); });\n    container.registerSingleton(ICacheManager.CacheManagerToken, function () { return new core.CacheManager(container); });\n    container.registerSingleton(resolves.ResolverChainToken, function () { return new resolves.ResolverChain(container); });\n    container.register(core.ProviderMapToken, function () { return new core.ProviderMap(container); });\n    container.bindProvider(core.ProviderMap, core.ProviderMapToken);\n    container.registerSingleton(core.ProviderMatcherToken, function () { return new core.ProviderMatcher(container); });\n    container.registerSingleton(IMethodAccessor.MethodAccessorToken, function () { return new MethodAccessor_1.MethodAccessor(container); });\n    var lifeScope = container.get(LifeScope.LifeScopeToken);\n    lifeScope.registerDecorator(decorators.Injectable, actions.CoreActions.bindProvider, actions.CoreActions.cache);\n    lifeScope.registerDecorator(decorators.Component, actions.CoreActions.bindProvider, actions.CoreActions.cache, actions.CoreActions.componentBeforeInit, actions.CoreActions.componentInit, actions.CoreActions.componentAfterInit);\n    lifeScope.registerDecorator(decorators.Singleton, actions.CoreActions.bindProvider);\n    lifeScope.registerDecorator(decorators.Abstract, actions.CoreActions.bindProvider, actions.CoreActions.cache);\n    lifeScope.registerDecorator(decorators.AutoWired, actions.CoreActions.bindParameterType, actions.CoreActions.bindPropertyType);\n    lifeScope.registerDecorator(decorators.Inject, actions.CoreActions.bindParameterType, actions.CoreActions.bindPropertyType);\n    lifeScope.registerDecorator(decorators.Param, actions.CoreActions.bindParameterType, actions.CoreActions.bindPropertyType);\n    lifeScope.registerDecorator(decorators.Method, actions.CoreActions.bindParameterProviders);\n    lifeScope.registerDecorator(decorators.Autorun, actions.CoreActions.autorun, actions.CoreActions.methodAutorun);\n    lifeScope.registerDecorator(decorators.IocExt, actions.CoreActions.autorun, actions.CoreActions.componentBeforeInit, actions.CoreActions.componentInit, actions.CoreActions.componentAfterInit);\n    container.register(Date, function () { return new Date(); });\n    container.register(String, function () { return ''; });\n    container.register(Number, function () { return Number.NaN; });\n    container.register(Boolean, function () { return undefined; });\n}\nexports.registerCores = registerCores;\n\n\n\n\n});\n\nunwrapExports(registerCores_1);\nvar registerCores_2 = registerCores_1.registerCores;\n\nvar Container_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Container\n *\n * @export\n * @class Container\n * @implements {IContainer}\n */\nvar Container = /** @class */ (function () {\n    function Container() {\n        this.init();\n    }\n    Container.prototype.getRoot = function () {\n        var root = this;\n        while (root.parent) {\n            root = root.parent;\n        }\n        return root;\n    };\n    Container.prototype.getBuilder = function () {\n        return this.resolveValue(IContainerBuilder.ContainerBuilderToken);\n    };\n    /**\n     * Retrieves an instance from the container based on the provided token.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {string} [alias]\n     * @param {...Providers[]} providers\n     * @returns {T}\n     * @memberof Container\n     */\n    Container.prototype.get = function (token, alias) {\n        var providers = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            providers[_i - 2] = arguments[_i];\n        }\n        return this.resolve.apply(this, [alias ? this.getTokenKey(token, alias) : token].concat(providers));\n    };\n    Object.defineProperty(Container.prototype, \"resolvers\", {\n        /**\n        * resolve token value in this container only.\n        *\n        * @template T\n        * @param {Token<T>} token\n        * @param {...Providers[]} providers\n        * @returns {T}\n        * @memberof Container\n        */\n        get: function () {\n            return this.resolveValue(resolves.ResolverChainToken);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * resolve type instance with token and param provider.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {T} [notFoundValue]\n     * @param {...Providers[]} providers\n     * @memberof Container\n     */\n    Container.prototype.resolve = function (token) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a;\n        var key = this.getTokenKey(token);\n        return (_a = this.resolvers).resolve.apply(_a, [key].concat(providers));\n    };\n    /**\n     * resolve token value in this container only.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {...Providers[]} providers\n     * @returns {T}\n     * @memberof IContainer\n     */\n    Container.prototype.resolveValue = function (token) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var key = this.getTokenKey(token);\n        if (!this.hasRegister(key)) {\n            return null;\n        }\n        var factory = this.factories.get(key);\n        return factory.apply(void 0, providers);\n    };\n    /**\n     * clear cache.\n     *\n     * @param {Type<any>} targetType\n     * @memberof IContainer\n     */\n    Container.prototype.clearCache = function (targetType) {\n        this.resolveValue(ICacheManager.CacheManagerToken).destroy(targetType);\n    };\n    /**\n     * get token.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {string} [alias]\n     * @returns {Token<T>}\n     * @memberof Container\n     */\n    Container.prototype.getToken = function (token, alias) {\n        if (alias) {\n            return new Registration_1.Registration(token, alias);\n        }\n        return token;\n    };\n    /**\n     * get tocken key.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {string} [alias]\n     * @returns {SymbolType<T>}\n     * @memberof Container\n     */\n    Container.prototype.getTokenKey = function (token, alias) {\n        if (alias) {\n            return new Registration_1.Registration(token, alias).toString();\n        }\n        else if (token instanceof Registration_1.Registration) {\n            return token.toString();\n        }\n        return token;\n    };\n    /**\n     * register type.\n     * @abstract\n     * @template T\n     * @param {Token<T>} token\n     * @param {T} [value]\n     * @returns {this}\n     * @memberOf Container\n     */\n    Container.prototype.register = function (token, value) {\n        this.registerFactory(token, value);\n        return this;\n    };\n    /**\n     * has register the token or not.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {string} [alias]\n     * @returns {boolean}\n     * @memberof Container\n     */\n    Container.prototype.has = function (token, alias) {\n        var key = this.getTokenKey(token, alias);\n        return this.resolvers.has(key);\n    };\n    /**\n     * has register type.\n     *\n     * @template T\n     * @param {SymbolType<T>} key\n     * @returns\n     * @memberof Container\n     */\n    Container.prototype.hasRegister = function (key) {\n        return this.factories.has(key);\n    };\n    /**\n     * unregister the token\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @returns {this}\n     * @memberof Container\n     */\n    Container.prototype.unregister = function (token, inchain) {\n        var key = this.getTokenKey(token);\n        if (inchain === false) {\n            if (this.hasRegister(key)) {\n                this.factories.delete(key);\n                if (this.provideTypes.has(key)) {\n                    this.provideTypes.delete(key);\n                }\n                if (utils.isClass(key)) {\n                    this.clearCache(key);\n                }\n            }\n        }\n        else {\n            this.resolvers.unregister(key);\n        }\n        return this;\n    };\n    /**\n     * register stingleton type.\n     * @abstract\n     * @template T\n     * @param {Token<T>} token\n     * @param {Factory<T>} [value]\n     * @returns {this}\n     * @memberOf Container\n     */\n    Container.prototype.registerSingleton = function (token, value) {\n        this.registerFactory(token, value, true);\n        return this;\n    };\n    /**\n     * register value.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {T} value\n     * @returns {this}\n     * @memberof Container\n     */\n    Container.prototype.registerValue = function (token, value) {\n        var _this = this;\n        var key = this.getTokenKey(token);\n        this.singleton.set(key, value);\n        if (!this.factories.has(key)) {\n            this.factories.set(key, function () {\n                return _this.singleton.get(key);\n            });\n        }\n        return this;\n    };\n    /**\n     * bind provider.\n     *\n     * @template T\n     * @param {Token<T>} provide\n     * @param {Token<T>} provider\n     * @returns {this}\n     * @memberof Container\n     */\n    Container.prototype.bindProvider = function (provide, provider) {\n        var _this = this;\n        var provideKey = this.getTokenKey(provide);\n        var factory;\n        if (utils.isToken(provider)) {\n            factory = function () {\n                var providers = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    providers[_i] = arguments[_i];\n                }\n                return _this.resolve.apply(_this, [provider].concat(providers));\n            };\n        }\n        else {\n            if (utils.isFunction(provider)) {\n                factory = function () {\n                    var providers = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        providers[_i] = arguments[_i];\n                    }\n                    return provider.apply(void 0, [_this].concat(providers));\n                };\n            }\n            else {\n                factory = function () {\n                    return provider;\n                };\n            }\n        }\n        if (utils.isClass(provider)) {\n            if (!this.has(provider)) {\n                this.register(provider);\n            }\n            this.provideTypes.set(provideKey, provider);\n        }\n        else if (utils.isToken(provider)) {\n            var token = provider;\n            while (this.provideTypes.has(token) && !utils.isClass(token)) {\n                token = this.provideTypes.get(token);\n                if (utils.isClass(token)) {\n                    this.provideTypes.set(provideKey, token);\n                    break;\n                }\n            }\n        }\n        this.factories.set(provideKey, factory);\n        return this;\n    };\n    /**\n     * get token implements class type.\n     *\n     * @template T\n     * @param {Token<T>} token\n     * @param {boolean} [inchain]\n     * @returns {Type<T>}\n     * @memberof Container\n     */\n    Container.prototype.getTokenImpl = function (token, inchain) {\n        var tokenKey = this.getTokenKey(token);\n        if (inchain === false) {\n            if (utils.isClass(token)) {\n                return token;\n            }\n            if (this.provideTypes.has(tokenKey)) {\n                return this.provideTypes.get(tokenKey);\n            }\n            return null;\n        }\n        else {\n            return this.resolvers.getTokenImpl(tokenKey);\n        }\n    };\n    /**\n     * get token implement class and base classes.\n     *\n     * @param {Token<any>} token\n     * @returns {Token<any>[]}\n     * @memberof Container\n     */\n    Container.prototype.getTokenExtendsChain = function (token) {\n        if (utils.isClass(token)) {\n            return this.getBaseClasses(token);\n        }\n        else {\n            return this.getBaseClasses(this.getTokenImpl(token)).concat([token]);\n        }\n    };\n    Container.prototype.getBaseClasses = function (target) {\n        var types$$1 = [];\n        while (utils.isClass(target) && target !== Object) {\n            types$$1.push(target);\n            target = utils.lang.getParentClass(target);\n        }\n        return types$$1;\n    };\n    /**\n    * get life scope of container.\n    *\n    * @returns {LifeScope}\n    * @memberof IContainer\n    */\n    Container.prototype.getLifeScope = function () {\n        return this.get(LifeScope.LifeScopeToken);\n    };\n    /**\n     * use modules.\n     *\n     * @param {...Modules[]} modules\n     * @returns {this}\n     * @memberof Container\n     */\n    Container.prototype.use = function () {\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i] = arguments[_i];\n        }\n        var _a;\n        (_a = this.getBuilder()).syncLoadModule.apply(_a, [this].concat(modules));\n        return this;\n    };\n    /**\n     * async use modules.\n     *\n     * @param {...LoadType[]} modules load modules.\n     * @returns {Promise<Type<any>[]>}  types loaded.\n     * @memberof IContainer\n     */\n    Container.prototype.loadModule = function () {\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i] = arguments[_i];\n        }\n        var _a;\n        return (_a = this.getBuilder()).loadModule.apply(_a, [this].concat(modules));\n    };\n    /**\n     * invoke method async.\n     *\n     * @template T\n     * @param {Token<any>} token\n     * @param {string} propertyKey\n     * @param {*} [instance]\n     * @param {...Providers[]} providers\n     * @returns {Promise<T>}\n     * @memberof Container\n     */\n    Container.prototype.invoke = function (token, propertyKey, instance) {\n        var providers = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            providers[_i - 3] = arguments[_i];\n        }\n        var _a;\n        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).invoke.apply(_a, [token, propertyKey, instance].concat(providers));\n    };\n    /**\n     * invoke method.\n     *\n     * @template T\n     * @param {Token<any>} token\n     * @param {string} propertyKey\n     * @param {*} [instance]\n     * @param {...Providers[]} providers\n     * @returns {T}\n     * @memberof Container\n     */\n    Container.prototype.syncInvoke = function (token, propertyKey, instance) {\n        var providers = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            providers[_i - 3] = arguments[_i];\n        }\n        var _a;\n        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).syncInvoke.apply(_a, [token, propertyKey, instance].concat(providers));\n    };\n    Container.prototype.createSyncParams = function (params) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a;\n        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).createSyncParams.apply(_a, [params].concat(providers));\n    };\n    Container.prototype.createParams = function (params) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        var _a;\n        return (_a = this.resolveValue(IMethodAccessor.MethodAccessorToken)).createParams.apply(_a, [params].concat(providers));\n    };\n    Container.prototype.cacheDecorator = function (map, action) {\n        if (!map.has(action.name)) {\n            map.set(action.name, action);\n        }\n    };\n    Container.prototype.init = function () {\n        var _this = this;\n        this.factories = new utils.MapSet();\n        this.singleton = new utils.MapSet();\n        this.provideTypes = new utils.MapSet();\n        this.bindProvider(IContainer.ContainerToken, function () { return _this; });\n        registerCores_1.registerCores(this);\n    };\n    Container.prototype.registerFactory = function (token, value, singleton) {\n        var key = this.getTokenKey(token);\n        if (this.factories.has(key)) {\n            return;\n        }\n        var classFactory;\n        if (!utils.isUndefined(value)) {\n            if (utils.isFunction(value)) {\n                if (utils.isClass(value)) {\n                    this.bindTypeFactory(key, value, singleton);\n                }\n                else {\n                    classFactory = this.createCustomFactory(key, value, singleton);\n                }\n            }\n            else if (singleton && value !== undefined) {\n                classFactory = this.createCustomFactory(key, function () { return value; }, singleton);\n            }\n        }\n        else if (!utils.isString(token) && !utils.isSymbol(token)) {\n            var ClassT = (token instanceof Registration_1.Registration) ? token.getClass() : token;\n            if (utils.isClass(ClassT)) {\n                this.bindTypeFactory(key, ClassT, singleton);\n            }\n        }\n        if (classFactory) {\n            this.factories.set(key, classFactory);\n        }\n    };\n    Container.prototype.createCustomFactory = function (key, factory, singleton) {\n        var _this = this;\n        return singleton ?\n            function () {\n                var providers = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    providers[_i] = arguments[_i];\n                }\n                if (_this.singleton.has(key)) {\n                    return _this.singleton.get(key);\n                }\n                var instance = factory.apply(void 0, [_this].concat(providers));\n                _this.singleton.set(key, instance);\n                return instance;\n            }\n            : function () {\n                var providers = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    providers[_i] = arguments[_i];\n                }\n                return factory.apply(void 0, [_this].concat(providers));\n            };\n    };\n    Container.prototype.bindTypeFactory = function (key, ClassT, singleton) {\n        var _this = this;\n        if (!Reflect.isExtensible(ClassT)) {\n            return;\n        }\n        var lifeScope = this.getLifeScope();\n        var parameters = lifeScope.getConstructorParameters(ClassT);\n        if (!singleton) {\n            singleton = lifeScope.isSingletonType(ClassT);\n        }\n        var factory = function () {\n            var providers = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                providers[_i] = arguments[_i];\n            }\n            var _a;\n            if (singleton && _this.singleton.has(key)) {\n                return _this.singleton.get(key);\n            }\n            if (providers.length < 1) {\n                var lifecycleData = {\n                    tokenKey: key,\n                    targetType: ClassT,\n                    // raiseContainer: this,\n                    singleton: singleton\n                };\n                lifeScope.execute(lifecycleData, core.CoreActions.cache);\n                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {\n                    return lifecycleData.execResult;\n                }\n            }\n            var providerMap = (_a = _this.get(core.ProviderMatcherToken)).toProviderMap.apply(_a, providers);\n            lifeScope.execute({\n                tokenKey: key,\n                targetType: ClassT,\n                raiseContainer: _this,\n                params: parameters,\n                providers: providers,\n                providerMap: providerMap,\n                singleton: singleton\n            }, types.IocState.runtime, core.LifeState.beforeCreateArgs);\n            var args = _this.createSyncParams(parameters, providerMap);\n            lifeScope.routeExecute({\n                tokenKey: key,\n                targetType: ClassT,\n                raiseContainer: _this,\n                args: args,\n                params: parameters,\n                providers: providers,\n                providerMap: providerMap,\n                singleton: singleton\n            }, types.IocState.runtime, core.LifeState.beforeConstructor);\n            var instance = new (ClassT.bind.apply(ClassT, [void 0].concat(args)))();\n            lifeScope.routeExecute({\n                tokenKey: key,\n                target: instance,\n                targetType: ClassT,\n                raiseContainer: _this,\n                args: args,\n                params: parameters,\n                providers: providers,\n                providerMap: providerMap,\n                singleton: singleton\n            }, types.IocState.runtime, core.LifeState.afterConstructor);\n            lifeScope.execute({\n                tokenKey: key,\n                target: instance,\n                targetType: ClassT,\n                raiseContainer: _this,\n                args: args,\n                params: parameters,\n                providers: providers,\n                providerMap: providerMap,\n                singleton: singleton\n            }, types.IocState.runtime, core.LifeState.onInit);\n            lifeScope.routeExecute({\n                tokenKey: key,\n                target: instance,\n                targetType: ClassT,\n                raiseContainer: _this,\n                args: args,\n                params: parameters,\n                providers: providers,\n                providerMap: providerMap,\n                singleton: singleton\n            }, types.IocState.runtime, core.LifeState.AfterInit);\n            lifeScope.execute({\n                tokenKey: key,\n                target: instance,\n                targetType: ClassT,\n                raiseContainer: _this\n            }, core.CoreActions.cache);\n            return instance;\n        };\n        this.factories.set(key, factory);\n        lifeScope.routeExecute({\n            tokenKey: key,\n            targetType: ClassT,\n            raiseContainer: this\n        }, types.IocState.design);\n    };\n    Container.classAnnations = { \"name\": \"Container\", \"params\": { \"constructor\": [], \"getRoot\": [], \"getBuilder\": [], \"get\": [\"token\", \"alias\", \"providers\"], \"resolve\": [\"token\", \"providers\"], \"resolveValue\": [\"token\", \"providers\"], \"clearCache\": [\"targetType\"], \"getToken\": [\"token\", \"alias\"], \"getTokenKey\": [\"token\", \"alias\"], \"register\": [\"token\", \"value\"], \"has\": [\"token\", \"alias\"], \"hasRegister\": [\"key\"], \"unregister\": [\"token\", \"inchain\"], \"registerSingleton\": [\"token\", \"value\"], \"registerValue\": [\"token\", \"value\"], \"bindProvider\": [\"provide\", \"provider\"], \"getTokenImpl\": [\"token\", \"inchain\"], \"getTokenExtendsChain\": [\"token\"], \"getBaseClasses\": [\"target\"], \"getLifeScope\": [], \"use\": [\"modules\"], \"loadModule\": [\"modules\"], \"invoke\": [\"token\", \"propertyKey\", \"instance\", \"providers\"], \"syncInvoke\": [\"token\", \"propertyKey\", \"instance\", \"providers\"], \"createSyncParams\": [\"params\", \"providers\"], \"createParams\": [\"params\", \"providers\"], \"cacheDecorator\": [\"map\", \"action\"], \"init\": [], \"registerFactory\": [\"token\", \"value\", \"singleton\"], \"createCustomFactory\": [\"key\", \"factory\", \"singleton\"], \"bindTypeFactory\": [\"key\", \"ClassT\", \"singleton\"] } };\n    return Container;\n}());\nexports.Container = Container;\n\n\n\n\n});\n\nunwrapExports(Container_1);\nvar Container_2 = Container_1.Container;\n\nvar IModuleLoader = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * module loader token.\n */\nexports.ModuleLoaderToken = new InjectToken_1.InjectToken('DI_ModuleLoader');\n\n\n\n\n});\n\nunwrapExports(IModuleLoader);\nvar IModuleLoader_1 = IModuleLoader.ModuleLoaderToken;\n\nvar DefaultModuleLoader_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * default module loader.\n *\n * @export\n * @class DefaultModuleLoader\n * @implements {IModuleLoader}\n */\nvar DefaultModuleLoader = /** @class */ (function () {\n    function DefaultModuleLoader() {\n    }\n    DefaultModuleLoader.prototype.getLoader = function () {\n        if (!this._loader) {\n            this._loader = this.createLoader();\n        }\n        return this._loader;\n    };\n    /**\n     * load module.\n     *\n     * @param {...LoadType[]} modules\n     * @returns {Promise<Modules[]>}\n     * @memberof DefaultModuleLoader\n     */\n    DefaultModuleLoader.prototype.load = function (modules) {\n        var _this = this;\n        if (modules.length) {\n            return Promise.all(modules.map(function (mdty) {\n                if (utils.isString(mdty)) {\n                    return _this.isFile(mdty) ? _this.loadFile(mdty) : _this.loadModule(mdty);\n                }\n                else if (utils.isObject(mdty) && (mdty['modules'] || mdty['files'])) {\n                    return _this.loadPathModule(mdty);\n                }\n                else {\n                    return mdty ? [mdty] : [];\n                }\n            }))\n                .then(function (allms) {\n                var rmodules = [];\n                allms.forEach(function (ms) {\n                    rmodules = rmodules.concat(ms);\n                });\n                return rmodules;\n            });\n        }\n        else {\n            return Promise.resolve([]);\n        }\n    };\n    /**\n     * load types from module.\n     *\n     * @param {...LoadType[]} modules\n     * @returns {Promise<Type<any>[]>}\n     * @memberof IContainerBuilder\n     */\n    DefaultModuleLoader.prototype.loadTypes = function (modules) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var mdls;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.load(modules)];\n                    case 1:\n                        mdls = _a.sent();\n                        return [2 /*return*/, this.getTypes(mdls)];\n                }\n            });\n        });\n    };\n    /**\n     * get all class type in modules.\n     *\n     * @param {Modules[]} modules\n     * @param {...Express<Type<any>, boolean>[]} filters\n     * @returns {Type<any>[]}\n     * @memberof DefaultModuleLoader\n     */\n    DefaultModuleLoader.prototype.getTypes = function (modules) {\n        var _this = this;\n        var regModules = [];\n        modules.forEach(function (m) {\n            var types = _this.getContentTypes(m);\n            regModules.push(types);\n        });\n        return regModules;\n    };\n    DefaultModuleLoader.prototype.loadFile = function (files, basePath) {\n        var loader = this.getLoader();\n        var fRes;\n        if (utils.isArray(files)) {\n            fRes = Promise.all(files.map(function (f) { return loader(f); }))\n                .then(function (allms) {\n                var rms = [];\n                allms.forEach(function (ms) {\n                    rms = rms.concat(ms);\n                });\n                return rms;\n            });\n        }\n        else {\n            fRes = loader(files);\n        }\n        return fRes.then(function (ms) { return ms.filter(function (it) { return !!it; }); });\n    };\n    DefaultModuleLoader.prototype.isFile = function (str) {\n        return str && /\\/((\\w|%|\\.))+\\.\\w+$/.test(str.replace(/\\\\\\\\/gi, '/'));\n    };\n    DefaultModuleLoader.prototype.loadModule = function (moduleName) {\n        var loader = this.getLoader();\n        return loader(moduleName).then(function (ms) { return ms.filter(function (it) { return !!it; }); });\n    };\n    DefaultModuleLoader.prototype.loadPathModule = function (pmd) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var modules;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        modules = [];\n                        if (!pmd.files) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.loadFile(pmd.files, pmd.basePath)\n                                .then(function (allmoduls) {\n                                allmoduls.forEach(function (ms) {\n                                    modules = modules.concat(ms);\n                                });\n                                return modules;\n                            })];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        if (!pmd.modules) return [3 /*break*/, 4];\n                        return [4 /*yield*/, Promise.all(pmd.modules.map(function (nmd) {\n                                return utils.isString(nmd) ? _this.loadModule(nmd) : nmd;\n                            })).then(function (ms) {\n                                modules = modules.concat(ms);\n                                return modules;\n                            })];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [2 /*return*/, modules];\n                }\n            });\n        });\n    };\n    DefaultModuleLoader.prototype.createLoader = function () {\n        if (typeof commonjsRequire !== 'undefined') {\n            return function (modulepath) {\n                return new Promise(function (resolve, reject) {\n                    commonjsRequire([modulepath], function (mud) {\n                        resolve(mud);\n                    }, function (err) {\n                        reject(err);\n                    });\n                });\n            };\n        }\n        else {\n            throw new Error('has not module loader');\n        }\n    };\n    DefaultModuleLoader.prototype.getContentTypes = function (regModule) {\n        var regModules = [];\n        if (utils.isClass(regModule)) {\n            regModules.push(regModule);\n        }\n        else {\n            var rmodules = regModule['exports'] ? regModule['exports'] : regModule;\n            for (var p in rmodules) {\n                var type = rmodules[p];\n                if (utils.isClass(type)) {\n                    regModules.push(type);\n                }\n            }\n        }\n        return regModules;\n    };\n    DefaultModuleLoader.classAnnations = { \"name\": \"DefaultModuleLoader\", \"params\": { \"constructor\": [], \"getLoader\": [], \"load\": [\"modules\"], \"loadTypes\": [\"modules\"], \"getTypes\": [\"modules\"], \"loadFile\": [\"files\", \"basePath\"], \"isFile\": [\"str\"], \"loadModule\": [\"moduleName\"], \"loadPathModule\": [\"pmd\"], \"createLoader\": [], \"getContentTypes\": [\"regModule\"] } };\n    return DefaultModuleLoader;\n}());\nexports.DefaultModuleLoader = DefaultModuleLoader;\n\n\n\n\n});\n\nunwrapExports(DefaultModuleLoader_1);\nvar DefaultModuleLoader_2 = DefaultModuleLoader_1.DefaultModuleLoader;\n\nvar IModuleValidate = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * inject module validate token.\n *\n * @export\n * @class InjectModuleValidateToken\n * @extends {Registration<T>}\n * @template T\n */\nvar InjectModuleValidateToken = /** @class */ (function (_super) {\n    tslib_1.__extends(InjectModuleValidateToken, _super);\n    function InjectModuleValidateToken(desc) {\n        return _super.call(this, 'DI_ModuleValidate', desc) || this;\n    }\n    InjectModuleValidateToken.classAnnations = { \"name\": \"InjectModuleValidateToken\", \"params\": { \"constructor\": [\"desc\"] } };\n    return InjectModuleValidateToken;\n}(Registration_1.Registration));\nexports.InjectModuleValidateToken = InjectModuleValidateToken;\n/**\n * Module Validate Token\n */\nexports.ModuleValidateToken = new InjectToken_1.InjectToken('DI_ModuleValidate');\n\n\n\n\n});\n\nunwrapExports(IModuleValidate);\nvar IModuleValidate_1 = IModuleValidate.InjectModuleValidateToken;\nvar IModuleValidate_2 = IModuleValidate.ModuleValidateToken;\n\nvar IMetaAccessor = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n * application service token.\n *\n * @export\n * @class InjectMetaAccessorToken\n * @extends {Registration<MetaAccessor<T>>}\n * @template T\n */\nvar InjectMetaAccessorToken = /** @class */ (function (_super) {\n    tslib_1.__extends(InjectMetaAccessorToken, _super);\n    function InjectMetaAccessorToken(type) {\n        return _super.call(this, type, 'boot__metaAccessor') || this;\n    }\n    InjectMetaAccessorToken.classAnnations = { \"name\": \"InjectMetaAccessorToken\", \"params\": { \"constructor\": [\"type\"] } };\n    return InjectMetaAccessorToken;\n}(Registration_1.Registration));\nexports.InjectMetaAccessorToken = InjectMetaAccessorToken;\n/**\n * default MetaAccessor token.\n */\nexports.DefaultMetaAccessorToken = new InjectMetaAccessorToken('default');\n/**\n * Annotation MetaAccessor token.\n */\nexports.AnnotationMetaAccessorToken = new InjectMetaAccessorToken('Annotation');\n\n\n\n\n});\n\nunwrapExports(IMetaAccessor);\nvar IMetaAccessor_1 = IMetaAccessor.InjectMetaAccessorToken;\nvar IMetaAccessor_2 = IMetaAccessor.DefaultMetaAccessorToken;\nvar IMetaAccessor_3 = IMetaAccessor.AnnotationMetaAccessorToken;\n\nvar ModuleValidate = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n/**\n * base module validate.\n *\n * @export\n * @abstract\n * @class BaseModuelValidate\n * @implements {IModuleValidate}\n */\nvar BaseModuelValidate = /** @class */ (function () {\n    function BaseModuelValidate() {\n    }\n    BaseModuelValidate.prototype.validate = function (type) {\n        if (!utils.isClass(type)) {\n            return false;\n        }\n        var decorator = this.getDecorator();\n        if (utils.isString(decorator)) {\n            return core.hasOwnClassMetadata(decorator, type);\n        }\n        else if (utils.isArray(decorator)) {\n            if (decorator.length > 0) {\n                return decorator.some(function (decor) { return core.hasOwnClassMetadata(decor, type); });\n            }\n        }\n        return false;\n    };\n    BaseModuelValidate.prototype.getMetaConfig = function (token, container) {\n        if (utils.isToken(token)) {\n            var accessor = this.getMetaAccessor(container);\n            return accessor.getMetadata(token, container);\n        }\n        return {};\n    };\n    BaseModuelValidate.prototype.getMetaAccessor = function (container) {\n        var decorator = this.getDecorator();\n        return container.resolve(IMetaAccessor.AnnotationMetaAccessorToken, { decorator: decorator });\n    };\n    BaseModuelValidate.classAnnations = { \"name\": \"BaseModuelValidate\", \"params\": { \"constructor\": [], \"validate\": [\"type\"], \"getMetaConfig\": [\"token\", \"container\"], \"getMetaAccessor\": [\"container\"], \"getDecorator\": [] } };\n    return BaseModuelValidate;\n}());\nexports.BaseModuelValidate = BaseModuelValidate;\n/**\n * IocExt module validate token.\n */\nexports.IocExtModuleValidateToken = new IModuleValidate.InjectModuleValidateToken(core.IocExt.toString());\n/**\n * IocExt module validate.\n *\n * @export\n * @class IocExtModuleValidate\n * @extends {BaseModuelValidate}\n * @implements {IModuleValidate}\n */\nvar IocExtModuleValidate = /** @class */ (function (_super) {\n    tslib_1.__extends(IocExtModuleValidate, _super);\n    function IocExtModuleValidate() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    IocExtModuleValidate.prototype.getDecorator = function () {\n        return core.IocExt.toString();\n    };\n    IocExtModuleValidate.classAnnations = { \"name\": \"IocExtModuleValidate\", \"params\": { \"getDecorator\": [] } };\n    return IocExtModuleValidate;\n}(BaseModuelValidate));\nexports.IocExtModuleValidate = IocExtModuleValidate;\n\n\n\n\n});\n\nunwrapExports(ModuleValidate);\nvar ModuleValidate_1 = ModuleValidate.BaseModuelValidate;\nvar ModuleValidate_2 = ModuleValidate.IocExtModuleValidateToken;\nvar ModuleValidate_3 = ModuleValidate.IocExtModuleValidate;\n\nvar MetaAccessor_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\nvar MetaAccessor = /** @class */ (function () {\n    function MetaAccessor(decorator) {\n        this.decorators = utils.isArray(decorator) ? decorator : [decorator];\n    }\n    MetaAccessor.prototype.getDecorators = function () {\n        return this.decorators;\n    };\n    MetaAccessor.prototype.getMetadata = function (token, container) {\n        var type = utils.isClass(token) ? token : container.getTokenImpl(token);\n        if (utils.isClass(type)) {\n            var decorators = this.getDecorators();\n            var firstDecor = decorators.find(function (decor) { return core.hasOwnClassMetadata(decor, type); });\n            var metas = core.getTypeMetadata(firstDecor, type);\n            if (metas && metas.length) {\n                var meta = metas[0];\n                return meta;\n            }\n        }\n        return {};\n    };\n    MetaAccessor.classAnnations = { \"name\": \"MetaAccessor\", \"params\": { \"constructor\": [\"decorator\"], \"getDecorators\": [], \"getMetadata\": [\"token\", \"container\"] } };\n    MetaAccessor = tslib_1.__decorate([\n        core.Injectable(IMetaAccessor.DefaultMetaAccessorToken),\n        tslib_1.__metadata(\"design:paramtypes\", [Object])\n    ], MetaAccessor);\n    return MetaAccessor;\n}());\nexports.MetaAccessor = MetaAccessor;\n/**\n * Annotation MetaAccessor.\n *\n * @export\n * @class AnnotationMetaAccessor\n * @implements {IMetaAccessor<any>}\n */\nvar AnnotationMetaAccessor = /** @class */ (function () {\n    function AnnotationMetaAccessor(decorator) {\n        this.decorators = utils.isArray(decorator) ? decorator : [decorator];\n    }\n    AnnotationMetaAccessor.prototype.getDecorators = function () {\n        return this.decorators;\n    };\n    AnnotationMetaAccessor.prototype.getMetadata = function (token, container) {\n        if (utils.isToken(token)) {\n            var accessor_1;\n            var provider_1 = { decorator: this.getDecorators() };\n            container.getTokenExtendsChain(token).forEach(function (tk) {\n                if (accessor_1) {\n                    return false;\n                }\n                var accToken = new IMetaAccessor.InjectMetaAccessorToken(tk);\n                if (container.has(accToken)) {\n                    accessor_1 = container.resolve(accToken, provider_1);\n                }\n                return true;\n            });\n            if (!accessor_1) {\n                accessor_1 = this.getDefaultMetaAccessor(container, provider_1);\n            }\n            if (accessor_1) {\n                return accessor_1.getMetadata(token, container);\n            }\n            else {\n                return {};\n            }\n        }\n        return {};\n    };\n    AnnotationMetaAccessor.prototype.getDefaultMetaAccessor = function (container) {\n        var providers = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            providers[_i - 1] = arguments[_i];\n        }\n        return container.resolve.apply(container, [IMetaAccessor.DefaultMetaAccessorToken].concat(providers));\n    };\n    AnnotationMetaAccessor.classAnnations = { \"name\": \"AnnotationMetaAccessor\", \"params\": { \"constructor\": [\"decorator\"], \"getDecorators\": [], \"getMetadata\": [\"token\", \"container\"], \"getDefaultMetaAccessor\": [\"container\", \"providers\"] } };\n    AnnotationMetaAccessor = tslib_1.__decorate([\n        core.Injectable(IMetaAccessor.AnnotationMetaAccessorToken),\n        tslib_1.__metadata(\"design:paramtypes\", [Object])\n    ], AnnotationMetaAccessor);\n    return AnnotationMetaAccessor;\n}());\nexports.AnnotationMetaAccessor = AnnotationMetaAccessor;\n\n\n\n\n});\n\nunwrapExports(MetaAccessor_1);\nvar MetaAccessor_2 = MetaAccessor_1.MetaAccessor;\nvar MetaAccessor_3 = MetaAccessor_1.AnnotationMetaAccessor;\n\nvar IModuleInjector = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n/**\n *  inject module injector token.\n */\nvar InjectModuleInjectorToken = /** @class */ (function (_super) {\n    tslib_1.__extends(InjectModuleInjectorToken, _super);\n    function InjectModuleInjectorToken(desc, sync) {\n        if (sync === void 0) { sync = false; }\n        return _super.call(this, sync ? 'DI_SyncModuleInjector' : 'DI_ModuleInjector', desc) || this;\n    }\n    InjectModuleInjectorToken.classAnnations = { \"name\": \"InjectModuleInjectorToken\", \"params\": { \"constructor\": [\"desc\", \"sync\"] } };\n    return InjectModuleInjectorToken;\n}(Registration_1.Registration));\nexports.InjectModuleInjectorToken = InjectModuleInjectorToken;\n/**\n * async module injector token.\n */\nexports.ModuleInjectorToken = new InjectModuleInjectorToken('');\n/**\n * Sync module injector token.\n */\nexports.SyncModuleInjectorToken = new InjectModuleInjectorToken('', true);\n\n\n\n\n});\n\nunwrapExports(IModuleInjector);\nvar IModuleInjector_1 = IModuleInjector.InjectModuleInjectorToken;\nvar IModuleInjector_2 = IModuleInjector.ModuleInjectorToken;\nvar IModuleInjector_3 = IModuleInjector.SyncModuleInjectorToken;\n\nvar ModuleInjector_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * base module injector. abstract class.\n *\n * @export\n * @abstract\n * @class BaseModuleInjector\n * @implements {IModuleInjector}\n */\nvar BaseModuleInjector = /** @class */ (function () {\n    /**\n     *Creates an instance of BaseModuleInjector.\n     * @param {IModuleValidate} [validate]\n     * @param {boolean} [skipNext] skip next when has match module to injector.\n     * @memberof BaseModuleInjector\n     */\n    function BaseModuleInjector(validate, skipNext) {\n        this.validate = validate;\n        this.skipNext = skipNext;\n    }\n    BaseModuleInjector.prototype.filter = function (modules) {\n        var _this = this;\n        modules = modules || [];\n        return this.validate ? modules.filter(function (md) { return _this.validate.validate(md); }) : modules;\n    };\n    BaseModuleInjector.prototype.next = function (all, filtered) {\n        if (filtered.length === 0) {\n            return all;\n        }\n        if (this.skipNext) {\n            return null;\n        }\n        if (filtered.length === all.length) {\n            return null;\n        }\n        return all.filter(function (it) { return filtered.indexOf(it) < 0; });\n    };\n    BaseModuleInjector.prototype.setup = function (container, type) {\n        container.register(type);\n    };\n    BaseModuleInjector.classAnnations = { \"name\": \"BaseModuleInjector\", \"params\": { \"constructor\": [\"validate\", \"skipNext\"], \"inject\": [\"container\", \"modules\"], \"filter\": [\"modules\"], \"next\": [\"all\", \"filtered\"], \"setup\": [\"container\", \"type\"] } };\n    return BaseModuleInjector;\n}());\nexports.BaseModuleInjector = BaseModuleInjector;\n/**\n * sync module injector.\n *\n * @export\n * @class SyncModuleInjector\n * @extends {BaseModuleInjector}\n * @implements {IModuleInjector}\n */\nvar SyncModuleInjector = /** @class */ (function (_super) {\n    tslib_1.__extends(SyncModuleInjector, _super);\n    function SyncModuleInjector(validate, skipNext) {\n        var _this = _super.call(this, validate, skipNext) || this;\n        _this.validate = validate;\n        return _this;\n    }\n    SyncModuleInjector.prototype.inject = function (container, modules) {\n        var _this = this;\n        var types = this.filter(modules);\n        if (types.length) {\n            types.forEach(function (ty) {\n                _this.setup(container, ty);\n            });\n        }\n        var next = this.next(modules, types);\n        return { injected: types, next: next };\n    };\n    SyncModuleInjector.classAnnations = { \"name\": \"SyncModuleInjector\", \"params\": { \"constructor\": [\"validate\", \"skipNext\"], \"inject\": [\"container\", \"modules\"] } };\n    SyncModuleInjector = tslib_1.__decorate([\n        core.Injectable(IModuleInjector.SyncModuleInjectorToken),\n        tslib_1.__metadata(\"design:paramtypes\", [Object, Boolean])\n    ], SyncModuleInjector);\n    return SyncModuleInjector;\n}(BaseModuleInjector));\nexports.SyncModuleInjector = SyncModuleInjector;\n/**\n * module injector.\n *\n * @export\n * @class ModuleInjector\n * @extends {BaseModuleInjector}\n * @implements {IModuleInjector}\n */\nvar ModuleInjector = /** @class */ (function (_super) {\n    tslib_1.__extends(ModuleInjector, _super);\n    function ModuleInjector(validate, skipNext) {\n        var _this = _super.call(this, validate, skipNext) || this;\n        _this.validate = validate;\n        return _this;\n    }\n    ModuleInjector.prototype.inject = function (container, modules) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var types, next;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        types = this.filter(modules);\n                        if (!types.length) return [3 /*break*/, 2];\n                        return [4 /*yield*/, utils.PromiseUtil.step(types.map(function (ty) {\n                                return _this.setup(container, ty);\n                            }))];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        next = this.next(modules, types);\n                        return [2 /*return*/, { injected: types, next: next }];\n                }\n            });\n        });\n    };\n    ModuleInjector.classAnnations = { \"name\": \"ModuleInjector\", \"params\": { \"constructor\": [\"validate\", \"skipNext\"], \"inject\": [\"container\", \"modules\"] } };\n    ModuleInjector = tslib_1.__decorate([\n        core.Injectable(IModuleInjector.ModuleInjectorToken),\n        tslib_1.__metadata(\"design:paramtypes\", [Object, Boolean])\n    ], ModuleInjector);\n    return ModuleInjector;\n}(BaseModuleInjector));\nexports.ModuleInjector = ModuleInjector;\n\n\n\n\n});\n\nunwrapExports(ModuleInjector_1);\nvar ModuleInjector_2 = ModuleInjector_1.BaseModuleInjector;\nvar ModuleInjector_3 = ModuleInjector_1.SyncModuleInjector;\nvar ModuleInjector_4 = ModuleInjector_1.ModuleInjector;\n\nvar IModuleInjectorChain = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * module fileter token. mast use as singlton.\n */\nexports.ModuleInjectorChainToken = new InjectToken_1.InjectToken('DI_ModuleInjectorChain');\n\n\n\n\n});\n\nunwrapExports(IModuleInjectorChain);\nvar IModuleInjectorChain_1 = IModuleInjectorChain.ModuleInjectorChainToken;\n\nvar ModuleInjectorChain_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n/**\n * Module Injector chain, base injector chain.\n *\n * @export\n * @class ModuleInjectorChain\n * @implements {IModuleInjectorChain}\n */\nvar ModuleInjectorChain = /** @class */ (function () {\n    function ModuleInjectorChain() {\n        this._injectors = [];\n    }\n    Object.defineProperty(ModuleInjectorChain.prototype, \"injectors\", {\n        get: function () {\n            return this._injectors;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ModuleInjectorChain.prototype.first = function (injector) {\n        if (this.isInjector(injector)) {\n            this._injectors.unshift(injector);\n        }\n        return this;\n    };\n    ModuleInjectorChain.prototype.next = function (injector) {\n        if (this.isInjector(injector)) {\n            this._injectors.push(injector);\n        }\n        return this;\n    };\n    ModuleInjectorChain.prototype.isInjector = function (injector) {\n        return injector instanceof ModuleInjector_1.ModuleInjector || injector instanceof ModuleInjector_1.SyncModuleInjector;\n    };\n    ModuleInjectorChain.prototype.inject = function (container, modules) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var types;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        types = [];\n                        return [4 /*yield*/, utils.PromiseUtil.forEach(this.injectors.map(function (jtor) { return function (ijrt) { return jtor.inject(container, ijrt.next); }; }), function (result) {\n                                types = types.concat(result.injected || []);\n                                return result.next && result.next.length > 0;\n                            }, { injected: [], next: modules }).catch(function (err) { return []; })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, types];\n                }\n            });\n        });\n    };\n    ModuleInjectorChain.prototype.syncInject = function (container, modules) {\n        var types = [];\n        var completed = false;\n        this.injectors.forEach(function (jtor) {\n            if (completed) {\n                return false;\n            }\n            if (jtor instanceof ModuleInjector_1.SyncModuleInjector) {\n                var result = jtor.inject(container, modules);\n                types = types.concat(result.injected);\n                completed = (!result.next || result.next.length < 1);\n            }\n            return true;\n        });\n        return types;\n    };\n    ModuleInjectorChain.classAnnations = { \"name\": \"ModuleInjectorChain\", \"params\": { \"constructor\": [], \"first\": [\"injector\"], \"next\": [\"injector\"], \"isInjector\": [\"injector\"], \"inject\": [\"container\", \"modules\"], \"syncInject\": [\"container\", \"modules\"] } };\n    return ModuleInjectorChain;\n}());\nexports.ModuleInjectorChain = ModuleInjectorChain;\n\n\n\n\n});\n\nunwrapExports(ModuleInjectorChain_1);\nvar ModuleInjectorChain_2 = ModuleInjectorChain_1.ModuleInjectorChain;\n\nvar injectors = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(IModuleLoader, exports);\ntslib_1.__exportStar(DefaultModuleLoader_1, exports);\ntslib_1.__exportStar(IModuleValidate, exports);\ntslib_1.__exportStar(ModuleValidate, exports);\ntslib_1.__exportStar(IMetaAccessor, exports);\ntslib_1.__exportStar(MetaAccessor_1, exports);\ntslib_1.__exportStar(IModuleInjector, exports);\ntslib_1.__exportStar(ModuleInjector_1, exports);\ntslib_1.__exportStar(IModuleInjectorChain, exports);\ntslib_1.__exportStar(ModuleInjectorChain_1, exports);\n\n\n\n\n});\n\nunwrapExports(injectors);\n\nvar DefaultContainerBuilder_1 = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n\n/**\n * default container builder.\n *\n * @export\n * @class DefaultContainerBuilder\n * @implements {IContainerBuilder}\n */\nvar DefaultContainerBuilder = /** @class */ (function () {\n    function DefaultContainerBuilder(loader) {\n        this._loader = loader;\n    }\n    Object.defineProperty(DefaultContainerBuilder.prototype, \"loader\", {\n        get: function () {\n            if (!this._loader) {\n                this._loader = new injectors.DefaultModuleLoader();\n            }\n            return this._loader;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DefaultContainerBuilder.prototype.create = function () {\n        var _this = this;\n        var container = new Container_1.Container();\n        container.bindProvider(IContainerBuilder.ContainerBuilderToken, function () { return _this; });\n        container.bindProvider(injectors.ModuleLoaderToken, function () { return _this.loader; });\n        return container;\n    };\n    /**\n     * build container.\n     *\n     * @param {...LoadType[]} [modules]\n     * @returns\n     * @memberof DefaultContainerBuilder\n     */\n    DefaultContainerBuilder.prototype.build = function () {\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i] = arguments[_i];\n        }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var container;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        container = this.create();\n                        if (!modules.length) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.loadModule.apply(this, [container].concat(modules))];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, container];\n                }\n            });\n        });\n    };\n    /**\n     * load modules for container.\n     *\n     * @param {IContainer} container\n     * @param {...LoadType[]} modules\n     * @returns {Promise<Type<any>[]>}\n     * @memberof DefaultContainerBuilder\n     */\n    DefaultContainerBuilder.prototype.loadModule = function (container) {\n        var modules = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            modules[_i - 1] = arguments[_i];\n        }\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var regModules, injTypes, injChain_1;\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.loader.loadTypes(modules)];\n                    case 1:\n                        regModules = _a.sent();\n                        injTypes = [];\n                        if (!(regModules && regModules.length)) return [3 /*break*/, 3];\n                        injChain_1 = this.getInjectorChain(container);\n                        return [4 /*yield*/, utils.PromiseUtil.step(regModules.map(function (typs) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                                var ityps;\n                                return tslib_1.__generator(this, function (_a) {\n                                    switch (_a.label) {\n                                        case 0: return [4 /*yield*/, injChain_1.inject(container, typs)];\n                                        case 1:\n                                            ityps = _a.sent();\n                                            injTypes = injTypes.concat(ityps);\n                                            return [2 /*return*/];\n                                    }\n                                });\n                            }); }))];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3: return [2 /*return*/, injTypes];\n                }\n            });\n        });\n    };\n    DefaultContainerBuilder.prototype.syncBuild = function () {\n        var modules = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            modules[_i] = arguments[_i];\n        }\n        var container = this.create();\n        if (modules.length) {\n            this.syncLoadModule.apply(this, [container].concat(modules));\n        }\n        return container;\n    };\n    DefaultContainerBuilder.prototype.syncLoadModule = function (container) {\n        var modules = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            modules[_i - 1] = arguments[_i];\n        }\n        var regModules = this.loader.getTypes(modules);\n        var injTypes = [];\n        if (regModules && regModules.length) {\n            var injChain_2 = this.getInjectorChain(container);\n            regModules.forEach(function (typs) {\n                var ityps = injChain_2.syncInject(container, typs);\n                injTypes = injTypes.concat(ityps);\n            });\n        }\n        return injTypes;\n    };\n    DefaultContainerBuilder.prototype.getInjectorChain = function (container) {\n        if (!container.has(injectors.ModuleInjectorChainToken)) {\n            container.register(injectors.SyncModuleInjector)\n                .register(injectors.ModuleInjector)\n                .register(injectors.MetaAccessor)\n                .register(injectors.AnnotationMetaAccessor)\n                .bindProvider(injectors.IocExtModuleValidateToken, new injectors.IocExtModuleValidate())\n                .bindProvider(injectors.ModuleInjectorChainToken, new injectors.ModuleInjectorChain());\n        }\n        var currChain = container.get(injectors.ModuleInjectorChainToken);\n        if (this.injectorChain !== currChain) {\n            this.injectorChain = null;\n        }\n        if (!this.injectorChain) {\n            this.injectorChain = currChain;\n            this.injectorChain\n                .next(container.resolve(injectors.SyncModuleInjectorToken, { validate: container.get(injectors.IocExtModuleValidateToken), skipNext: true }))\n                .next(container.resolve(injectors.SyncModuleInjectorToken));\n        }\n        return this.injectorChain;\n    };\n    DefaultContainerBuilder.classAnnations = { \"name\": \"DefaultContainerBuilder\", \"params\": { \"constructor\": [\"loader\"], \"create\": [], \"build\": [\"modules\"], \"loadModule\": [\"container\", \"modules\"], \"syncBuild\": [\"modules\"], \"syncLoadModule\": [\"container\", \"modules\"], \"getInjectorChain\": [\"container\"] } };\n    return DefaultContainerBuilder;\n}());\nexports.DefaultContainerBuilder = DefaultContainerBuilder;\n\n\n\n\n});\n\nunwrapExports(DefaultContainerBuilder_1);\nvar DefaultContainerBuilder_2 = DefaultContainerBuilder_1.DefaultContainerBuilder;\n\nvar D__workspace_github_tsioc_packages_core_lib = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\ntslib_1.__exportStar(IContainer, exports);\ntslib_1.__exportStar(Container_1, exports);\ntslib_1.__exportStar(types, exports);\ntslib_1.__exportStar(Registration_1, exports);\ntslib_1.__exportStar(InjectToken_1, exports);\ntslib_1.__exportStar(IContainerBuilder, exports);\ntslib_1.__exportStar(IMethodAccessor, exports);\ntslib_1.__exportStar(ICacheManager, exports);\ntslib_1.__exportStar(LifeScope, exports);\ntslib_1.__exportStar(DefaultContainerBuilder_1, exports);\ntslib_1.__exportStar(utils, exports);\ntslib_1.__exportStar(components, exports);\ntslib_1.__exportStar(core, exports);\ntslib_1.__exportStar(injectors, exports);\ntslib_1.__exportStar(resolves, exports);\n\n\n\n\n});\n\nvar index$9 = unwrapExports(D__workspace_github_tsioc_packages_core_lib);\n\nreturn index$9;\n\n})));\n\n//# sourceMappingURL=sourcemaps/core.umd.js.map\n\n//# sourceMappingURL=sourcemaps/core.umd.js.map\n"],"file":"../core.umd.min.js"}