{"version":3,"file":"../core.umd.js","sources":["../../../node_modules/object-assign/index.js","utils/utils/lang.ts","utils/utils/typeCheck.ts","utils/utils/MapSet.ts","utils/utils/PromiseUtil.ts","utils/utils/index.ts","Registration.ts","InjectToken.ts","IContainer.ts","types.ts","IMethodAccessor.ts","components/components/NullComponent.ts","components/components/GComposite.ts","components/components/Composite.ts","components/components/index.ts","core/actions/core/actions/NullAction.ts","core/actions/core/actions/ActionComposite.ts","core/actions/core/actions/LifeState.ts","core/actions/core/actions/CoreActions.ts","core/factories/core/factories/ArgsIterator.ts","core/factories/core/factories/DecoratorType.ts","core/factories/core/factories/DecoratorFactory.ts","core/factories/core/factories/ClassDecoratorFactory.ts","core/factories/core/factories/MethodDecoratorFactory.ts","core/factories/core/factories/ParamDecoratorFactory.ts","core/factories/core/factories/PropertyDecoratorFactory.ts","core/factories/core/factories/ParamPropDecoratorFactory.ts","core/factories/core/factories/ClassMethodDecoratorFactory.ts","core/factories/core/factories/MethodPropDecoratorFactory.ts","core/factories/core/factories/MethodPropParamDecoratorFactory.ts","core/factories/core/factories/index.ts","core/actions/core/actions/BindProviderAction.ts","core/actions/core/actions/BindParameterTypeAction.ts","core/actions/core/actions/BindPropertyTypeAction.ts","core/actions/core/actions/InjectPropertyAction.ts","core/actions/core/actions/BindParameterProviderAction.ts","core/actions/core/actions/ComponentBeforeInitAction.ts","core/actions/core/actions/ComponentInitAction.ts","core/actions/core/actions/ComponentAfterInitAction.ts","ICacheManager.ts","core/actions/core/actions/CacheAction.ts","core/actions/core/actions/SingletonAction.ts","core/decorators/core/decorators/Component.ts","core/decorators/core/decorators/Injectable.ts","core/decorators/core/decorators/Inject.ts","core/decorators/core/decorators/AutoWried.ts","core/decorators/core/decorators/Param.ts","core/decorators/core/decorators/Method.ts","core/decorators/core/decorators/Singleton.ts","core/decorators/core/decorators/Abstract.ts","core/decorators/core/decorators/AutoRun.ts","core/decorators/core/decorators/IocExt.ts","core/decorators/core/decorators/index.ts","core/actions/core/actions/AutorunAction.ts","core/actions/core/actions/index.ts","core/providers/core/providers/ProviderMap.ts","core/providers/core/providers/Provider.ts","core/providers/core/providers/index.ts","core/core/IRecognizer.ts","core/core/IProviderMatcher.ts","core/actions/core/actions/MethodAutorun.ts","core/core/ActionFactory.ts","core/core/DefaultLifeScope.ts","core/core/ProviderMatcher.ts","core/core/MethodAccessor.ts","core/core/CacheManager.ts","core/core/index.ts","LifeScope.ts","IContainerBuilder.ts","resolves/resolves/ResolverChain.ts","resolves/resolves/index.ts","registerCores.ts","Container.ts","injectors/injectors/IModuleLoader.ts","injectors/injectors/DefaultModuleLoader.ts","injectors/injectors/IModuleValidate.ts","injectors/injectors/IMetaAccessor.ts","injectors/injectors/ModuleValidate.ts","injectors/injectors/MetaAccessor.ts","injectors/injectors/IModuleInjector.ts","injectors/injectors/ModuleInjector.ts","injectors/injectors/IModuleInjectorChain.ts","injectors/injectors/ModuleInjectorChain.ts","injectors/injectors/index.ts","DefaultContainerBuilder.ts","index.ts"],"sourcesContent":["/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","import { ObjectMap, Type } from '../types';\r\nimport { isArray, isObject, isFunction, isClass } from './typeCheck';\r\nimport * as objAssign from 'object-assign';\r\n\r\nexport namespace lang {\r\n\r\n    /**\r\n     * get object keys.\r\n     *\r\n     * @param {*} target\r\n     * @returns {string[]}\r\n     */\r\n    export function keys(target: any): string[] {\r\n        if (isObject(target)) {\r\n            if (isFunction(Object.keys)) {\r\n                return Object.keys(target);\r\n            } else {\r\n                let keys = [];\r\n                for (let name in target) {\r\n                    keys.push(name);\r\n                }\r\n                return keys;\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * values of target object.\r\n     *\r\n     * @export\r\n     * @param {*} target\r\n     * @returns {any[]}\r\n     */\r\n    export function values(target: any): any[] {\r\n        if (isObject(target)) {\r\n            if (isFunction(Object.values)) {\r\n                return Object.values(target);\r\n            } else {\r\n                let values = [];\r\n                for (let name in target) {\r\n                    values.push(target[name]);\r\n                }\r\n                return values;\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n\r\n    /**\r\n     * assign\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T} target\r\n     * @param {...any[]} source\r\n     * @returns {T}\r\n     */\r\n    export function assign<T, U, V>(target: T, source1: U, source2?: V, sources?: any[]): (T & U & V) | (T & U) {\r\n        if (sources && sources.length) {\r\n            sources.unshift(source2 || {});\r\n            sources.unshift(source1 || {});\r\n            return objAssign(target as any, ...sources);\r\n        } else if (source2) {\r\n            return objAssign(target, source1 || {} as U, source2);\r\n        } else {\r\n            return objAssign(target, source1 || {} as U);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create an new object from target object omit some field.\r\n     *\r\n     * @export\r\n     * @param {ObjectMap<any>} target\r\n     * @param {...string[]} fields\r\n     * @returns {*}\r\n     */\r\n    export function omit(target: ObjectMap<any>, ...fields: string[]): any {\r\n        if (isObject(target)) {\r\n            let result: any = {};\r\n            keys(target).forEach(key => {\r\n                if (fields.indexOf(key) < 0) {\r\n                    result[key] = target[key];\r\n                }\r\n            });\r\n            return result;\r\n        } else {\r\n            return target;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * object has field or not.\r\n     *\r\n     * @export\r\n     * @param {ObjectMap<any>} target\r\n     * @returns\r\n     */\r\n    export function hasField(target: ObjectMap<any>) {\r\n        return keys(target).length > 0;\r\n    }\r\n\r\n    /**\r\n     * for in opter for object or array.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {(ObjectMap<T> | T[])} target\r\n     * @param {(item: T, idx?: number|string) => void|boolean} iterator\r\n     */\r\n    export function forIn<T>(target: ObjectMap<T> | T[], iterator: (item: T, idx?: number | string) => void | boolean) {\r\n        if (isArray(target)) {\r\n            target.forEach(iterator);\r\n        } else if (isObject(target)) {\r\n            keys(target).forEach((key, idx) => {\r\n                iterator(target[key], key);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find\r\n     *\r\n     * @template T\r\n     * @param {(ObjectMap<T> | T[])} target\r\n     * @param {((item: T, idx?: number | string) => boolean)} express\r\n     */\r\n    export function find<T>(target: ObjectMap<T> | T[], express: (item: T, idx?: number | string) => boolean) {\r\n        let item: T;\r\n        forIn(target, (it, idx) => {\r\n            if (!item) {\r\n                if (express(it, idx)) {\r\n                    item = it;\r\n                    return false;\r\n                }\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * get target type parent class.\r\n     *\r\n     * @export\r\n     * @param {Type<any>} target\r\n     * @returns {Type<any>}\r\n     */\r\n    export function getParentClass(target: Type<any>): Type<any> {\r\n        let p = Reflect.getPrototypeOf(target.prototype);\r\n        return isClass(p) ? p : p.constructor as Type<any>;\r\n    }\r\n\r\n\r\n    /**\r\n     * first.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T[]} list\r\n     * @returns {T}\r\n     */\r\n    export function first<T>(list: T[]): T {\r\n        if (isArray(list) && list.length) {\r\n            return list[0];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * last.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {T[]} list\r\n     * @returns {T}\r\n     */\r\n    export function last<T>(list: T[]): T {\r\n        if (isArray(list) && list.length) {\r\n            return list[list.length - 1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n","import { Type, AbstractType, Token } from '../types';\r\nimport { Registration } from '../Registration';\r\nimport { lang } from './lang';\r\n\r\ndeclare let process: any;\r\n\r\n/**\r\n * check target is function or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns\r\n */\r\nexport function isFunction(target: any): target is Function {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    return typeof target === 'function';\r\n}\r\n\r\n/**\r\n * check Abstract class with @Abstract or not\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is AbstractType<any>}\r\n */\r\nexport function isAbstractDecoratorClass(target: any): target is AbstractType<any> {\r\n    if (!isFunction(target)) {\r\n        return false;\r\n    }\r\n\r\n    if (Reflect.hasOwnMetadata('@Abstract', target)) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\r\n/**\r\n * get class name.\r\n *\r\n * @export\r\n * @param {AbstractType<any>} classType\r\n * @returns {string}\r\n */\r\nexport function getClassName(classType: AbstractType<any>): string {\r\n    if (!isFunction(classType)) {\r\n        return '';\r\n    }\r\n    if (/^[a-z]$/.test(classType.name)) {\r\n        return classType.classAnnations ? classType.classAnnations.name : classType.name;\r\n    }\r\n\r\n    return classType.name;\r\n}\r\n\r\n\r\n/**\r\n * check target is class or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns\r\n */\r\nexport function isClass(target: any): target is Type<any> {\r\n    if (!isFunction(target)) {\r\n        return false;\r\n    }\r\n\r\n    if (target.prototype) {\r\n        if (!target.name || target.name === 'Object') {\r\n            return false;\r\n        }\r\n\r\n        if (Reflect.hasOwnMetadata('@Abstract', target)) {\r\n            return false;\r\n        }\r\n\r\n        let type = target as Type<any>;\r\n\r\n        // for uglify\r\n        if (/^[a-z]$/.test(type.name)) {\r\n            if (type.classAnnations && type.classAnnations.name) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (type.classAnnations && isString(type.classAnnations.name)) {\r\n                return true\r\n            }\r\n\r\n            if (!/^[A-Z@]/.test(target.name)) {\r\n                return false;\r\n            }\r\n\r\n        }\r\n\r\n        // for IE 8, 9\r\n        if (!isNodejsEnv() && /MSIE [6-9]/.test(navigator.userAgent)) {\r\n            return true;\r\n        }\r\n        try {\r\n            target.arguments && target.caller;\r\n            return false;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\r\n/**\r\n * is run in nodejs or not.\r\n *\r\n * @export\r\n * @returns {boolean}\r\n */\r\nexport function isNodejsEnv(): boolean {\r\n    return (typeof process !== 'undefined') && (typeof process.versions.node !== 'undefined')\r\n}\r\n\r\n/**\r\n * check target is token or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Token<any>}\r\n */\r\nexport function isToken(target: any): target is Token<any> {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (isString(target) || isSymbol(target) || isClass(target) || (isObject(target) && target instanceof Registration)) {\r\n        return true\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target promise or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Promise<any>}\r\n */\r\nexport function isPromise(target: any): target is Promise<any> {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (isFunction(target.then) && isFunction(target.catch)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target rxjs observable or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isObservable(target: any): boolean {\r\n    if (!target && !isObject(target)) {\r\n        return false;\r\n    }\r\n    if (isFunction(target.subscribe) && isFunction(target.toPromise)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is target base object or not.\r\n * eg. {}, have not self constructor;\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Promise<any>}\r\n */\r\nexport function isBaseObject(target: any): target is object {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (target.constructor && target.constructor.name === 'Object') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * is metadata object or not.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @param {string[]} [props]\r\n * @param {string[]} [extendsProps]\r\n * @returns {boolean}\r\n */\r\nexport function isMetadataObject(target: any, props?: string[], extendsProps?: string[]): boolean {\r\n    if (!target) {\r\n        return false;\r\n    }\r\n    if (isBaseType(target) || isSymbol(target) || target instanceof Registration || target instanceof RegExp || target instanceof Date) {\r\n        return false;\r\n    }\r\n\r\n    if (target.constructor && target.constructor.name !== 'Object') {\r\n        return false;\r\n    }\r\n\r\n    props = props || [];\r\n    if (extendsProps) {\r\n        props = extendsProps.concat(props);\r\n    }\r\n\r\n    if (props.length) {\r\n        return lang.keys(target).some(n => props.indexOf(n) > 0)\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n\r\n\r\n/**\r\n * check object is class metadata or not.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @param {string[]} [extendsProps]\r\n * @returns {boolean}\r\n */\r\nexport function isClassMetadata(target, extendsProps?: string[]): boolean {\r\n    return isMetadataObject(target, ['singleton', 'provide', 'alias', 'type'], extendsProps);\r\n}\r\n\r\n\r\n\r\n/**\r\n * check object is param metadata or not.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @param {string[]} [extendsProps]\r\n * @returns {boolean}\r\n */\r\nexport function isParamMetadata(target, extendsProps?: string[]): boolean {\r\n    return isMetadataObject(target, ['type', 'provider', 'index'], extendsProps);\r\n}\r\n\r\n\r\n/**\r\n * check object is param prop metadata or not.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @param {string[]} [extendsProps]\r\n * @returns {boolean}\r\n */\r\nexport function isParamPropMetadata(target, extendsProps?: string[]): boolean {\r\n    return isMetadataObject(target, ['type', 'provider', 'index'], extendsProps);\r\n}\r\n\r\n\r\n/**\r\n * check object is property metadata or not.\r\n *\r\n * @export\r\n * @param {any} target\r\n * @param {string[]} [extendsProps]\r\n * @returns {boolean}\r\n */\r\nexport function isPropertyMetadata(target, extendsProps?: string[]): boolean {\r\n    return isMetadataObject(target, ['type', 'provider'], extendsProps);\r\n}\r\n\r\n\r\n/**\r\n * check target is string or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is string}\r\n */\r\nexport function isString(target: any): target is string {\r\n    return typeof target === 'string';\r\n}\r\n\r\n/**\r\n * check target is boolean or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is boolean}\r\n */\r\nexport function isBoolean(target: any): target is boolean {\r\n    return typeof target === 'boolean' || (target === true || target === false);\r\n}\r\n\r\n/**\r\n * check target is number or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is number}\r\n */\r\nexport function isNumber(target: any): target is number {\r\n    return typeof target === 'number';\r\n}\r\n\r\n\r\n/**\r\n * check target is undefined or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is undefined}\r\n */\r\nexport function isUndefined(target: any): target is undefined {\r\n    return typeof target === 'undefined' || target === undefined;\r\n}\r\n\r\n/**\r\n * check target is unll or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is null}\r\n */\r\nexport function isNull(target: any): target is null {\r\n    return target === null;\r\n}\r\n\r\n/**\r\n * check target is array or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Array<any>}\r\n */\r\nexport function isArray(target: any): target is Array<any> {\r\n    return Array.isArray(target);\r\n}\r\n\r\n/**\r\n * check target is object or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is object}\r\n */\r\nexport function isObject(target: any): target is object {\r\n    var type = typeof target;\r\n    return target != null && (type === 'object' || type === 'function');\r\n}\r\n\r\n/**\r\n * check target is date or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Date}\r\n */\r\nexport function isDate(target: any): target is Date {\r\n    return isObject(target) && target instanceof Date;\r\n}\r\n\r\n/**\r\n * check target is symbol or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is Symbol}\r\n */\r\nexport function isSymbol(target: any): target is Symbol {\r\n    return typeof target === 'symbol' || (isObject(target) && /^Symbol\\(/.test(target.toString()));\r\n}\r\n\r\n/**\r\n * check target is regexp or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {target is RegExp}\r\n */\r\nexport function isRegExp(target: any): target is RegExp {\r\n    return target && target instanceof RegExp;\r\n}\r\n\r\n/**\r\n * is base type or not.\r\n *\r\n * @export\r\n * @param {*} target\r\n * @returns {boolean}\r\n */\r\nexport function isBaseType(target: any): boolean {\r\n    return isNull(target) || isUndefined(target) || isBoolean(target) || isString(target) || isNumber(target);\r\n}\r\n","import { isClass, isString, isFunction, isUndefined } from './typeCheck';\r\nimport { lang } from './lang';\r\n\r\n/**\r\n * object map set.\r\n *\r\n * @export\r\n * @class MapSet\r\n * @template TKey\r\n * @template TVal\r\n */\r\nexport class ObjectMapSet<TKey, TVal> {\r\n    private valueMap: any;\r\n    private keyMap: any;\r\n    constructor() {\r\n        this.valueMap = {};\r\n        this.keyMap = {};\r\n    }\r\n\r\n    clear(): void {\r\n        this.valueMap = {};\r\n        this.keyMap = {};\r\n    }\r\n\r\n    getTypeKey(key: TKey) {\r\n        let strKey = '';\r\n        if (isString(key)) {\r\n            strKey = key;\r\n        } else if (isFunction(key)) {\r\n            strKey = key.name;\r\n        } else {\r\n            strKey = key.toString();\r\n        }\r\n        return strKey;\r\n    }\r\n\r\n    keys(): TKey[] {\r\n        return lang.values(this.keyMap);\r\n    }\r\n\r\n    values(): TVal[] {\r\n        return lang.values(this.valueMap);\r\n    }\r\n\r\n    delete(key: TKey): boolean {\r\n        let strkey = this.getTypeKey(key).toString();\r\n        try {\r\n            delete this.keyMap[strkey];\r\n            delete this.valueMap[strkey];\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n    forEach(callbackfn: (value: TVal, key: TKey, map: any) => void, thisArg?: any): void {\r\n        lang.forIn<TKey>(this.keyMap, (val, name) => {\r\n            callbackfn(this.valueMap[name], val, this);\r\n        });\r\n    }\r\n    get(key: TKey): TVal {\r\n        let strKey = this.getTypeKey(key);\r\n        return this.valueMap[strKey];\r\n    }\r\n    has(key: TKey): boolean {\r\n        let strKey = this.getTypeKey(key);\r\n        return !isUndefined(this.keyMap[strKey]);\r\n    }\r\n    set(key: TKey, value: TVal): this {\r\n        let strKey = this.getTypeKey(key);\r\n\r\n        this.keyMap[strKey] = key;\r\n        this.valueMap[strKey] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    get size(): number {\r\n        return lang.keys(this.keyMap).length;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ObjectMapSet\",\"params\":{\"constructor\":[],\"clear\":[],\"getTypeKey\":[\"key\"],\"keys\":[],\"values\":[],\"delete\":[\"key\"],\"forEach\":[\"callbackfn\",\"thisArg\"],\"get\":[\"key\"],\"has\":[\"key\"],\"set\":[\"key\",\"value\"]}};\n                   }\r\n\r\n/**\r\n * map set.\r\n *\r\n * @export\r\n * @class MapSet\r\n * @template TKey\r\n * @template TVal\r\n */\r\nexport class MapSet<TKey, TVal> {\r\n\r\n    private map: ObjectMapSet<TKey, TVal> | Map<TKey, TVal>;\r\n    constructor() {\r\n        this.map = isClass(Map) ? new Map<TKey, TVal>() : new ObjectMapSet<TKey, TVal>();\r\n    }\r\n\r\n    keys(): TKey[] {\r\n        return this.map.keys() as TKey[];\r\n    }\r\n\r\n    values(): TVal[] {\r\n        return this.map.values()  as TVal[];\r\n    }\r\n\r\n    clear(): void {\r\n        this.map.clear();\r\n    }\r\n    delete(key: TKey): boolean {\r\n        return this.map.delete(key);\r\n    }\r\n    forEach(callbackfn: (value: TVal, key: TKey, map: any) => void, thisArg?: any): void {\r\n        let map = this.map as any;\r\n        map.forEach(callbackfn, thisArg);\r\n    }\r\n    get(key: TKey): TVal | undefined {\r\n        return this.map.get(key);\r\n    }\r\n    has(key: TKey): boolean {\r\n        return this.map.has(key);\r\n    }\r\n    set(key: TKey, value: TVal): this {\r\n        this.map.set(key, value);\r\n        return this;\r\n    }\r\n    get size(): number {\r\n        return this.map.size;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"MapSet\",\"params\":{\"constructor\":[],\"keys\":[],\"values\":[],\"clear\":[],\"delete\":[\"key\"],\"forEach\":[\"callbackfn\",\"thisArg\"],\"get\":[\"key\"],\"has\":[\"key\"],\"set\":[\"key\",\"value\"]}};\n                   }\r\n","import { isFunction } from './typeCheck';\r\nimport { Express } from '../types';\r\n\r\n/**\r\n * defer\r\n *\r\n * @export\r\n * @class Defer\r\n * @template T\r\n */\r\nexport class Defer<T> {\r\n    static create<T>(then?: (val: T) => T | PromiseLike<T>): Defer<T> {\r\n        let defer = new Defer<T>();\r\n        if (then) {\r\n            defer.promise = defer.promise.then(then);\r\n            return defer;\r\n        } else {\r\n            return defer;\r\n        }\r\n    }\r\n    /**\r\n     * promise.\r\n     *\r\n     * @type {Promise<T>}\r\n     * @memberof Defer\r\n     */\r\n    promise: Promise<T>\r\n    /**\r\n     * resolve.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    resolve: (value?: T | PromiseLike<T>) => void;\r\n    /**\r\n     * reject.\r\n     *\r\n     * @memberof Defer\r\n     */\r\n    reject: (reason?: any) => void;\r\n\r\n    constructor() {\r\n        this.promise = new Promise<T>((resolve, reject) => {\r\n            this.resolve = resolve;\r\n            this.reject = reject;\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"Defer\",\"params\":{\"create\":[\"then\"],\"constructor\":[]}};\n                   }\r\n\r\nexport namespace PromiseUtil {\r\n\r\n    /**\r\n     * foreach opter for promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, any>} express\r\n     * @param {T} [defVal]\r\n     * @returns\r\n     */\r\n    export function forEach<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], express: Express<T, any>, defVal?: T) {\r\n        let defer = new Defer<string>();\r\n        let pf = Promise.resolve<T>(defVal);\r\n        let length = promises ? promises.length : 0;\r\n\r\n        if (length) {\r\n            promises.forEach((p, idx) => {\r\n                pf = pf.then(v => isFunction(p) ? p(v) : p)\r\n                    .then(data => {\r\n                        if (express(data) === false) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        } else if (idx === length - 1) {\r\n                            defer.resolve('complete');\r\n                            return Promise.reject<T>('complete');\r\n                        }\r\n                        return data;\r\n                    });\r\n            });\r\n            pf.catch(err => {\r\n                return err;\r\n            });\r\n        } else {\r\n            defer.reject('array empty.');\r\n        }\r\n        return defer.promise;\r\n    }\r\n\r\n    /**\r\n     * run promise step by step.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {((T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @returns\r\n     */\r\n    export function step<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[]) {\r\n        let result = Promise.resolve<T>(null);\r\n        promises.forEach(p => {\r\n            result = result.then(v => isFunction(p) ? p(v) : p);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * find first validate value from promises.\r\n     *\r\n     * @export\r\n     * @template T\r\n     * @param {(...(T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[])} promises\r\n     * @param {Express<T, boolean>} validate\r\n     * @returns\r\n     */\r\n    export function find<T>(promises: (T | PromiseLike<T> | ((value: T) => T | PromiseLike<T>))[], filter: Express<T, boolean>, defVal?: T) {\r\n        let defer = new Defer<T>();\r\n        forEach(promises, val => {\r\n            if (filter(val)) {\r\n                defer.resolve(val);\r\n                return false;\r\n            }\r\n            return true;\r\n        }, defVal)\r\n            .then(() => defer.resolve(null))\r\n            .catch(() => {\r\n                defer.resolve(null)\r\n            });\r\n        return defer.promise;\r\n    }\r\n\r\n}\r\n","\r\nexport * from './typeCheck';\r\nexport * from './MapSet';\r\nexport * from './lang';\r\nexport * from './PromiseUtil';\r\n\r\n","import { Type, AbstractType, Token, SymbolType } from './types';\r\nimport { isClass, isFunction, getClassName } from './utils';\r\n\r\n/**\r\n * inject token.\r\n * @export\r\n * @class Registration\r\n * @template T\r\n */\r\nexport class Registration<T> {\r\n\r\n    protected type = 'Reg';\r\n    protected classType: SymbolType<any>;\r\n    protected desc: string;\r\n    /**\r\n     * Creates an instance of Registration.\r\n     * @param {(Token<T> | Token<any>)} provideType\r\n     * @param {string} desc\r\n     * @memberof Registration\r\n     */\r\n    constructor(provideType: Token<T> | Token<any>, desc: string) {\r\n        if (provideType instanceof Registration) {\r\n            this.classType = provideType.getProvide();\r\n            let pdec = provideType.getDesc();\r\n            if (pdec && desc && pdec !== desc) {\r\n                this.desc = pdec + '_' + desc;\r\n            } else {\r\n                this.desc = desc;\r\n            }\r\n        } else {\r\n            this.classType = provideType;\r\n            this.desc = desc;\r\n        }\r\n    }\r\n\r\n    getProvide(): SymbolType<any> {\r\n        return this.classType;\r\n    }\r\n\r\n\r\n    /**\r\n     * get class.\r\n     *\r\n     * @returns\r\n     * @memberof Registration\r\n     */\r\n    getClass(): Type<T> | AbstractType<T> {\r\n        if (isClass(this.classType)) {\r\n            return this.classType;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * get desc.\r\n     *\r\n     * @returns\r\n     * @memberof Registration\r\n     */\r\n    getDesc() {\r\n        return this.desc;\r\n    }\r\n\r\n    /**\r\n     * to string.\r\n     *\r\n     * @returns {string}\r\n     * @memberof Registration\r\n     */\r\n    toString(): string {\r\n        let name = '';\r\n        if (isFunction(this.classType)) {\r\n            name = `{${getClassName(this.classType)}}`;\r\n        } else if (this.classType) {\r\n            name = this.classType.toString();\r\n        }\r\n        return `${this.type} ${name} ${this.desc}`.trim();\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"Registration\",\"params\":{\"constructor\":[\"provideType\",\"desc\"],\"getProvide\":[],\"getClass\":[],\"getDesc\":[],\"toString\":[]}};\n                   }\r\n","import { Registration } from './Registration';\r\n\r\n/**\r\n * inject token.\r\n *\r\n * @export\r\n * @class InjectToken\r\n * @extends {Registration<T>}\r\n * @template T\r\n */\r\nexport class InjectToken<T> extends Registration<T> {\r\n\r\n    constructor(desc: string | symbol) {\r\n        super(desc, '');\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InjectToken\",\"params\":{\"constructor\":[\"desc\"]}};\n                   }\r\n","import { Type, Token, Factory, SymbolType, Providers, Modules, LoadType } from './types';\r\nimport { IMethodAccessor } from './IMethodAccessor';\r\nimport { LifeScope } from './LifeScope';\r\nimport { InjectToken } from './InjectToken';\r\nimport { IContainerBuilder } from './IContainerBuilder';\r\nimport { IResolver } from './IResolver';\r\nimport { ResolverChain } from './resolves';\r\n\r\n/**\r\n * IContainer token.\r\n * it is a symbol id, you can use  @Inject, @Autowried or @Param to get container instance in yourself class.\r\n */\r\nexport const ContainerToken = new InjectToken<IContainer>('DI_IContainer');\r\n\r\n\r\n/**\r\n * container interface.\r\n *\r\n * @export\r\n * @interface IContainer\r\n */\r\nexport interface IContainer extends IMethodAccessor, IResolver {\r\n\r\n    /**\r\n     * parent container.\r\n     *\r\n     * @type {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    parent: IContainer;\r\n\r\n    /**\r\n     * get root container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof IContainer\r\n     */\r\n    getRoot(): IContainer;\r\n\r\n    /**\r\n     * resolve chain.\r\n     *\r\n     * @type {ResolverChain}\r\n     * @memberof IContainer\r\n     */\r\n    readonly resolvers: ResolverChain;\r\n\r\n    /**\r\n     * get container builder of this container.\r\n     *\r\n     * @returns {IContainerBuilder}\r\n     * @memberof IContainer\r\n     */\r\n    getBuilder(): IContainerBuilder;\r\n\r\n    /**\r\n     * has register the token or not.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {boolean}\r\n     * @memberof IContainer\r\n     */\r\n    has<T>(token: Token<T>, alias?: string): boolean;\r\n\r\n    /**\r\n     * current container has register.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} key\r\n     * @memberof IContainer\r\n     */\r\n    hasRegister<T>(key: SymbolType<T>);\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: Providers[]): T;\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: Providers[]): T;\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>);\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} target\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getToken<T>(target: Token<T>, alias?: string): Token<T>;\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T>;\r\n\r\n    /**\r\n     * get token implement class type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {boolean} inchain\r\n     * @returns {Type<T>}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, inchain?: boolean): Type<T>;\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @returns {Token<any>[]}\r\n     * @memberof IContainer\r\n     */\r\n    getTokenExtendsChain(token: Token<any>): Token<any>[];\r\n\r\n    /**\r\n     * register type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * unregister the token\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    unregister<T>(token: Token<T>, inchain?: boolean): this;\r\n\r\n    /**\r\n     * bind provider\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T> | Factory<T>} provider\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this;\r\n\r\n    /**\r\n     * register stingleton type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} value\r\n     * @returns {this}\r\n     * @memberOf IContainer\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this;\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this;\r\n\r\n    /**\r\n     * get life scope of container.\r\n     *\r\n     * @returns {LifeScope}\r\n     * @memberof IContainer\r\n     */\r\n    getLifeScope(): LifeScope;\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof IContainer\r\n     */\r\n    use(...modules: Modules[]): this;\r\n\r\n    /**\r\n     * load modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]>;\r\n}\r\n","import { Registration } from './Registration';\r\nimport { IContainer } from './IContainer';\r\nimport { ProviderMap, ProviderType } from './core';\r\n\r\n/**\r\n * module types.\r\n */\r\nexport type Modules = Type<any> | ObjectMap<any>;\r\n\r\n/**\r\n * load modules in base on an path.\r\n *\r\n * @export\r\n * @interface PathModules\r\n */\r\nexport interface PathModules {\r\n    /**\r\n     * fire express base on the root path.\r\n     *\r\n     * @type {string}\r\n     * @memberof LoadOptions\r\n     */\r\n    basePath?: string;\r\n    /**\r\n     * script files match express.\r\n     * see: https://github.com/isaacs/node-glob\r\n     *\r\n     * @type {(string | string[])}\r\n     * @memberof BuilderOptions\r\n     */\r\n    files?: string | string[];\r\n\r\n    /**\r\n     * modules\r\n     *\r\n     * @type {((Modules | string)[])}\r\n     * @memberof AsyncLoadOptions\r\n     */\r\n    modules?: (Modules | string)[];\r\n}\r\n\r\n/**\r\n * load module type.\r\n */\r\nexport type LoadType = Modules | string | PathModules;\r\n/**\r\n * symbol type\r\n */\r\nexport type SymbolType<T> = Type<T> | AbstractType<T> | string | symbol;\r\n\r\n/**\r\n * factory tocken.\r\n */\r\nexport type Token<T> = Registration<T> | SymbolType<T>;\r\n\r\n/**\r\n * providers\r\n */\r\nexport type Providers = ObjectMap<any> | ProviderMap | ProviderType;\r\n\r\n/**\r\n * instance factory.\r\n */\r\nexport type InstanceFactory<T> = (...providers: Providers[]) => T\r\n\r\n/**\r\n * to instance via container.\r\n */\r\nexport type ToInstance<T> = (container?: IContainer, ...providers: Providers[]) => T;\r\n\r\n/**\r\n * Factory of Token\r\n */\r\nexport type Factory<T> = T | Type<T> | ToInstance<T>;\r\n\r\n/**\r\n * object map.\r\n *\r\n * @export\r\n * @interface ObjectMap\r\n * @template T\r\n */\r\nexport interface ObjectMap<T> {\r\n    [index: string]: T\r\n}\r\n\r\n/**\r\n * class Annations\r\n *\r\n * @export\r\n * @interface ClassAnnations\r\n */\r\nexport interface ClassAnnations {\r\n    /**\r\n     * class name\r\n     *\r\n     * @type {string}\r\n     * @memberof ClassAnnations\r\n     */\r\n    name: string;\r\n    /**\r\n     * class params declaration.\r\n     *\r\n     * @type {ObjectMap<string[]>}\r\n     * @memberof ClassAnnations\r\n     */\r\n    params: ObjectMap<string[]>;\r\n}\r\n/**\r\n * class type\r\n * @export\r\n * @interface Type\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface Type<T> extends Function {\r\n    new(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n}\r\n\r\n/**\r\n * abstract type\r\n *\r\n * @export\r\n * @interface AbstractType\r\n * @extends {Function}\r\n * @template T\r\n */\r\nexport interface AbstractType<T> extends Function {\r\n    new?(...args: any[]): T;\r\n    classAnnations?: ClassAnnations;\r\n}\r\n\r\n\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express\r\n * @template T\r\n * @template TResult\r\n */\r\nexport interface Express<T, TResult> {\r\n    (item: T): TResult\r\n}\r\n\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express2\r\n * @template T1\r\n * @template T2\r\n * @template TResult\r\n */\r\nexport interface Express2<T1, T2, TResult> {\r\n    (arg1: T1, arg2: T2): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express3\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template TResult\r\n */\r\nexport interface Express3<T1, T2, T3, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3): TResult\r\n}\r\n/**\r\n * express\r\n *\r\n * @export\r\n * @interface Express4\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template TResult\r\n */\r\nexport interface Express4<T1, T2, T3, T4, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4): TResult\r\n}\r\n/**\r\n * express.\r\n *\r\n * @export\r\n * @interface Express5\r\n * @template T1\r\n * @template T2\r\n * @template T3\r\n * @template T4\r\n * @template T5\r\n * @template TResult\r\n */\r\nexport interface Express5<T1, T2, T3, T4, T5, TResult> {\r\n    (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): TResult\r\n}\r\n\r\n/**\r\n * State of type in ioc.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum IocState {\r\n    design = 'design',\r\n    runtime = 'runtime'\r\n}\r\n\r\n/**\r\n * iterate way.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum Mode {\r\n    /**\r\n     * route up. iterate in parents.\r\n     */\r\n    route = 1,\r\n    /**\r\n     * iterate in children.\r\n     */\r\n    children,\r\n    /**\r\n     * iterate as tree map. node first\r\n     */\r\n    traverse,\r\n\r\n    /**\r\n     * iterate as tree map. node last\r\n     */\r\n    traverseLast,\r\n\r\n}\r\n","import { Token, Providers } from './types';\r\nimport { IParameter } from './IParameter';\r\nimport { InjectToken } from './InjectToken';\r\n\r\n/**\r\n * IMethodAccessor interface symbol.\r\n * it is a symbol id, you can register yourself MethodAccessor for this.\r\n */\r\nexport const MethodAccessorToken = new InjectToken<IMethodAccessor>('DI_IMethodAccessor');\r\n\r\n\r\n/**\r\n * execution, invoke some type method\r\n *\r\n * @export\r\n * @interface IExecution\r\n */\r\nexport interface IMethodAccessor {\r\n\r\n    /**\r\n     * try to async invoke the method of intance,  if no instance will create by type.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} token  type of object\r\n     * @param {string} propertyKey method name\r\n     * @param {*} [target] instance of type.\r\n     * @param {...Providers[]} providers param provider.\r\n     * @returns {Promise<T>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    invoke<T>(token: Token<any>, propertyKey: string, target?: any, ...providers: Providers[]): Promise<T>;\r\n\r\n    /**\r\n     * try to invoke the method of intance,  if no instance will create by type.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} token\r\n     * @param {string} propertyKey\r\n     * @param {*} [target]\r\n     * @param {...ParamProvider[]} providers\r\n     * @returns {T}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    syncInvoke<T>(token: Token<any>, propertyKey: string, target?: any, ...providers: Providers[]): T;\r\n\r\n\r\n    /**\r\n     * create params instances with IParameter and provider.\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {...ParamProvider[]} providers\r\n     * @returns {any[]}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    createSyncParams(params: IParameter[], ...providers: Providers[]): any[];\r\n\r\n    /**\r\n     * create params instances with IParameter and provider\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {...AsyncParamProvider[]} providers\r\n     * @returns {Promise<any[]>}\r\n     * @memberof IMethodAccessor\r\n     */\r\n    createParams(params: IParameter[], ...providers: Providers[]): Promise<any[]>;\r\n\r\n}\r\n","import { Mode, Express } from '../types';\r\nimport { GComponent } from './GComponent';\r\n\r\n\r\n/**\r\n * null component.\r\n *\r\n * @export\r\n * @class NullComponent\r\n * @implements {IComponent}\r\n */\r\nexport class NullComponent implements GComponent<any> {\r\n\r\n    isEmpty(): boolean {\r\n        return true;\r\n    }\r\n    name: string;\r\n    parent?: any;\r\n    add(action: any): this {\r\n        return this;\r\n    }\r\n    remove(action: string | any): this {\r\n        return this;\r\n    }\r\n    find(express: any | Express<any, boolean>, mode?: Mode): any {\r\n        return NullNode;\r\n    }\r\n    filter(express: Express<any, boolean | void>, mode?: Mode): any[] {\r\n        return [];\r\n    }\r\n    each(express: Express<any, boolean | void>, mode?: Mode) {\r\n    }\r\n\r\n    trans(express: Express<any, boolean | void>) {\r\n    }\r\n\r\n    transAfter(express: Express<any, boolean | void>) {\r\n    }\r\n\r\n    routeUp(express: Express<any, boolean | void>) {\r\n\r\n    }\r\n\r\n    equals(node: any): boolean {\r\n        return node === NullNode;\r\n    }\r\n\r\n    empty() {\r\n        return NullNode;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"NullComponent\",\"params\":{\"isEmpty\":[],\"add\":[\"action\"],\"remove\":[\"action\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"express\",\"mode\"],\"trans\":[\"express\"],\"transAfter\":[\"express\"],\"routeUp\":[\"express\"],\"equals\":[\"node\"],\"empty\":[]}};\n                   }\r\n\r\n/**\r\n * Null node\r\n */\r\nexport const NullNode: GComponent<any> = new NullComponent();\r\n","import { Mode, Express } from '../types';\r\nimport { NullNode } from './NullComponent';\r\nimport { IComponent } from './IComponent';\r\nimport { isFunction, isString } from '../utils';\r\nimport { GComponent } from './GComponent';\r\n\r\n/**\r\n * generics composite\r\n *\r\n * @export\r\n * @class GComposite\r\n * @implements {GComponent<T>}\r\n * @template T\r\n */\r\nexport class GComposite<T extends IComponent> implements GComponent<T> {\r\n\r\n    parent: T;\r\n    protected children: T[];\r\n    constructor(public name: string) {\r\n        this.children = [];\r\n    }\r\n\r\n    add(node: T): this {\r\n        node.parent = this as IComponent;\r\n        this.children.push(node);\r\n        return this;\r\n\r\n    }\r\n    remove(node?: string | T): this {\r\n        let component: IComponent;\r\n        if (isString(node)) {\r\n            component = this.find(cmp => isString(node) ? cmp.name === node : cmp.equals(node));\r\n        } else if (node) {\r\n            component = node;\r\n        } else {\r\n            component = this as IComponent;\r\n        }\r\n\r\n        if (!component.parent) {\r\n            return this;\r\n        } else if (this.equals(component.parent as T)) {\r\n            this.children.splice(this.children.indexOf(component as T), 1);\r\n            component.parent = null;\r\n            return this;\r\n        } else {\r\n            component.parent.remove(component);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    find(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        let component: any;\r\n        this.each(item => {\r\n            if (component) {\r\n                return false;\r\n            }\r\n            let isFinded = isFunction(express) ? express(item) : express === (item);\r\n            if (isFinded) {\r\n                component = item;\r\n                return false;\r\n            }\r\n            return true;\r\n        }, mode);\r\n        return (component || this.empty()) as T;\r\n    }\r\n\r\n    filter(express: Express<T, void | boolean>, mode?: Mode): T[] {\r\n        let nodes: IComponent[] = [];\r\n        this.each(item => {\r\n            if (express(item)) {\r\n                nodes.push(item);\r\n            }\r\n        }, mode);\r\n        return nodes as T[];\r\n    }\r\n\r\n    each(iterate: Express<T, boolean | void>, mode?: Mode) {\r\n        mode = mode || Mode.traverse;\r\n        let r;\r\n        switch (mode) {\r\n            case Mode.route:\r\n                r = this.routeUp(iterate);\r\n                break;\r\n            case Mode.children:\r\n                r = this.eachChildren(iterate);\r\n                break;\r\n\r\n            case Mode.traverse:\r\n                r = this.trans(iterate);\r\n                break;\r\n            case Mode.traverseLast:\r\n                r = this.transAfter(iterate);\r\n                break;\r\n            default:\r\n                r = this.trans(iterate);\r\n                break;\r\n        }\r\n        return r;\r\n    }\r\n\r\n    eachChildren(iterate: Express<T, void | boolean>) {\r\n        (this.children || []).forEach(item => {\r\n            return iterate(item as T);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *do express work in routing.\r\n     *\r\n     *@param {Express<T, void | boolean>} express\r\n     *\r\n     *@memberOf IComponent\r\n     */\r\n    routeUp(iterate: Express<T, void | boolean>) {\r\n        let curr = this as IComponent;\r\n        if (iterate(curr as T) === false) {\r\n            return false;\r\n        };\r\n        if (this.parent && this.parent.routeUp) {\r\n            return this.parent.routeUp(iterate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *translate all sub context to do express work.\r\n     *\r\n     *@param {Express<T, void | boolean>} express\r\n     *\r\n     *@memberOf IComponent\r\n     */\r\n    trans(express: Express<T, void | boolean>) {\r\n        let curr = this as IComponent;\r\n        if (express(curr as T) === false) {\r\n            return false;\r\n        }\r\n        let children = this.children || [];\r\n        for (let i = 0; i < children.length; i++) {\r\n            let result = children[i].trans(express);\r\n            if (result === false) {\r\n                return result;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    transAfter(express: Express<T, void | boolean>) {\r\n        let children = this.children || []\r\n        for (let i = 0; i < children.length; i++) {\r\n            let result = children[i].transAfter(express);\r\n            if (result === false) {\r\n                return false;\r\n            }\r\n        }\r\n        let curr = this as IComponent;\r\n        if (express(curr as T) === false) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    equals(node: T): boolean {\r\n        return this === node as IComponent;\r\n    }\r\n\r\n    empty(): T {\r\n        return NullNode as T;\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.equals(this.empty() as T);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"GComposite\",\"params\":{\"constructor\":[\"name\"],\"add\":[\"node\"],\"remove\":[\"node\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"iterate\",\"mode\"],\"eachChildren\":[\"iterate\"],\"routeUp\":[\"iterate\"],\"trans\":[\"express\"],\"transAfter\":[\"express\"],\"equals\":[\"node\"],\"empty\":[],\"isEmpty\":[]}};\n                   }\r\n","\r\nimport { Mode, Express } from '../types';\r\nimport { IComponent } from './IComponent';\r\nimport { GComposite } from './GComposite';\r\n\r\n/**\r\n * compoiste.\r\n *\r\n * @export\r\n * @class Composite\r\n * @implements {IComponent}\r\n */\r\nexport class Composite extends GComposite<IComponent> implements IComponent {\r\n\r\n    constructor(name: string) {\r\n        super(name);\r\n    }\r\n\r\n    find<T extends IComponent>(express: T | Express<T, boolean>, mode?: Mode): T {\r\n        return super.find(express, mode) as T;\r\n    }\r\n    filter<T extends IComponent>(express: Express<T, boolean | void>, mode?: Mode): T[] {\r\n        return super.filter(express, mode) as T[];\r\n    }\r\n    each<T extends IComponent>(express: Express<T, boolean | void>, mode?: Mode) {\r\n        return super.each(express, mode);\r\n    }\r\n\r\n    eachChildren<T extends IComponent>(express: Express<T, void | boolean>) {\r\n        super.eachChildren(express);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"Composite\",\"params\":{\"constructor\":[\"name\"],\"find\":[\"express\",\"mode\"],\"filter\":[\"express\",\"mode\"],\"each\":[\"express\",\"mode\"],\"eachChildren\":[\"express\"]}};\n                   }\r\n","export * from  './Composite';\r\nexport * from './IComponent';\r\nexport * from './GComponent';\r\nexport * from './GComposite';\r\nexport * from './NullComponent';\r\n","import { ActionComponent } from './ActionComponent';\r\nimport { ActionData } from '../ActionData';\r\nimport { IContainer } from '../../IContainer';\r\nimport { NullComponent } from '../../components';\r\n\r\nclass NullActionClass extends NullComponent implements ActionComponent {\r\n\r\n    insert(action: ActionComponent, index: number): this {\r\n        return this;\r\n    }\r\n    execute<T>(container: IContainer, data: ActionData<T>, name?: string) {\r\n\r\n    }\r\n\r\n    empty() {\r\n        return NullAction;\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"NullActionClass\",\"params\":{\"insert\":[\"action\",\"index\"],\"execute\":[\"container\",\"data\",\"name\"],\"empty\":[]}};\n                   }\r\n\r\n/**\r\n * Null Action\r\n */\r\nexport const NullAction: ActionComponent = new NullActionClass();\r\n","import { ActionData } from '../ActionData';\r\nimport { NullAction } from './NullAction';\r\nimport { ActionComponent } from './ActionComponent';\r\nimport { Metadate } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { GComposite } from '../../components';\r\n\r\n/**\r\n * action composite\r\n *\r\n * @export\r\n * @class ActionComposite\r\n * @extends {GComposite<ActionComponent>}\r\n * @implements {ActionComponent}\r\n */\r\nexport class ActionComposite extends GComposite<ActionComponent> implements ActionComponent {\r\n\r\n    parent: ActionComponent;\r\n    protected children: ActionComponent[];\r\n    constructor(name: string) {\r\n        super(name);\r\n        this.children = [];\r\n    }\r\n\r\n    insert(node: ActionComponent, index: number): this {\r\n        node.parent = this;\r\n        if (index < 0) {\r\n            index = 0;\r\n        } else if (index >= this.children.length) {\r\n            index = this.children.length - 1;\r\n        }\r\n        this.children.splice(index, 0, node);\r\n        return this;\r\n    }\r\n\r\n    execute(container: IContainer, data: ActionData<Metadate>, name?: string) {\r\n        if (name) {\r\n            this.find(it => it.name === name)\r\n                .execute(container, data);\r\n        } else {\r\n            this.trans(action => {\r\n                if (action instanceof ActionComposite) {\r\n                    action.working(container, data);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    empty() {\r\n        return NullAction;\r\n    }\r\n\r\n    protected working(container: IContainer, data: ActionData<any>) {\r\n        // do nothing.\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"ActionComposite\",\"params\":{\"constructor\":[\"name\"],\"insert\":[\"node\",\"index\"],\"execute\":[\"container\",\"data\",\"name\"],\"empty\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","\r\n/**\r\n * life state.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum LifeState {\r\n\r\n    /**\r\n     * before create constructor Args\r\n     */\r\n    beforeCreateArgs = 'beforeCreateArgs',\r\n\r\n    /**\r\n     * before constructor advice action.\r\n     */\r\n    beforeConstructor = 'beforeConstructor',\r\n\r\n    /**\r\n     * after constructor advice action.\r\n     */\r\n    afterConstructor = 'afterConstructor',\r\n\r\n    /**\r\n     * on init.\r\n     */\r\n    onInit = 'onInit',\r\n\r\n    /**\r\n     * after init.\r\n     */\r\n    AfterInit = 'AfterInit'\r\n}\r\n","/**\r\n * cores decorator actions\r\n *\r\n * @export\r\n */\r\nexport enum CoreActions {\r\n\r\n    /**\r\n     * the action bind parameter type form metadata.\r\n     */\r\n    bindParameterType = 'bindParameterType',\r\n\r\n    /**\r\n     * the action bind Property type from metadata.\r\n     */\r\n    bindPropertyType = 'bindPropertyType',\r\n\r\n    /**\r\n     * inject property action.\r\n     */\r\n    injectProperty = 'injectProperty',\r\n\r\n    /**\r\n     * class provider bind action.\r\n     */\r\n    bindProvider = 'bindProvider',\r\n\r\n    /**\r\n     * bind parameter provider action.\r\n     */\r\n    bindParameterProviders = 'bindParameterProviders',\r\n\r\n\r\n    /**\r\n     * cache action.\r\n     */\r\n    cache = 'cache',\r\n\r\n    /**\r\n     * component init action.  after constructor befor property inject.\r\n     */\r\n    componentBeforeInit = 'componentBeforeInit',\r\n\r\n    /**\r\n     * component on init hooks. after property inject.\r\n     */\r\n    componentInit = 'componentInit',\r\n\r\n    /**\r\n     * component after init hooks. after component init.\r\n     */\r\n    componentAfterInit = 'componentAfterInit',\r\n\r\n    /**\r\n     * singleton action.\r\n     */\r\n    singletion = 'singletion',\r\n\r\n\r\n    /**\r\n     * autorun action.\r\n     */\r\n    autorun = 'autorun',\r\n\r\n    /**\r\n     * method autorun action.\r\n     */\r\n    methodAutorun = 'methodAutorun'\r\n\r\n}\r\n","import { Metadate } from '../metadatas';\r\nimport { lang, isMetadataObject } from '../../utils';\r\n\r\n\r\nexport interface CheckExpress<T extends Metadate> {\r\n    match(arg: any): boolean;\r\n    isMetadata?(arg: any): boolean;\r\n    setMetadata(metadata: T, arg: any): void\r\n}\r\n\r\nexport class ArgsIterator {\r\n    private idx: number;\r\n    private metadata: Metadate;\r\n    constructor(protected args: any[]) {\r\n        this.idx = -1;\r\n        this.metadata = null;\r\n    }\r\n\r\n    isCompeted(): boolean {\r\n        return this.idx >= this.args.length;\r\n    }\r\n\r\n    end() {\r\n        this.idx = this.args.length;\r\n    }\r\n\r\n    next<T>(express: CheckExpress<T>) {\r\n        this.idx++;\r\n        if (this.isCompeted()) {\r\n            return null;\r\n        }\r\n\r\n        let arg = this.args[this.idx];\r\n        if (express.isMetadata && express.isMetadata(arg)) {\r\n            this.metadata = lang.assign(this.metadata || {}, arg);\r\n            this.end();\r\n        } else if (express.match(arg)) {\r\n            this.metadata = this.metadata || {};\r\n            express.setMetadata(this.metadata as T, arg);\r\n        } else if (isMetadataObject(arg)) { // when match failed then check is base metadata.\r\n            this.metadata = lang.assign(this.metadata || {}, arg);\r\n            this.end();\r\n        } else {\r\n            this.end();\r\n        }\r\n    }\r\n\r\n    getArgs() {\r\n        return this.args;\r\n    }\r\n\r\n    getMetadata() {\r\n        return this.metadata;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ArgsIterator\",\"params\":{\"constructor\":[\"args\"],\"isCompeted\":[],\"end\":[],\"next\":[\"express\"],\"getArgs\":[],\"getMetadata\":[]}};\n                   }\r\n\r\n","/**\r\n * decorator type category.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum DecoratorType {\r\n    /**\r\n     * Class decorator\r\n     */\r\n    Class = 1 << 0,\r\n    /**\r\n     * Parameter decorator\r\n     */\r\n    Parameter = 1 << 1,\r\n    /**\r\n     * Property decorator\r\n     */\r\n    Property = 1 << 2,\r\n    /**\r\n     * Method decorator\r\n     */\r\n    Method = 1 << 3,\r\n    /**\r\n     * decorator for any where.\r\n     */\r\n    All = Class | Property | Property | Method\r\n}\r\n","import 'reflect-metadata';\r\nimport { PropertyMetadata, MethodMetadata, ParameterMetadata, Metadate, ClassMetadata } from '../metadatas';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { isClass, isAbstractDecoratorClass, isMetadataObject, isUndefined, isFunction, isNumber, isArray, lang } from '../../utils';\r\nimport { Type, AbstractType, ObjectMap } from '../../types';\r\n\r\n\r\nexport const ParamerterName = 'paramerter_names';\r\n\r\nexport interface MetadataAdapter {\r\n    (args: ArgsIterator);\r\n}\r\n\r\n/**\r\n * extend metadata.\r\n *\r\n * @export\r\n * @interface MetadataExtends\r\n * @template T\r\n */\r\nexport interface MetadataExtends<T> {\r\n    (metadata: T): T;\r\n}\r\n\r\nexport interface MetadataTarget<T> {\r\n    (target: Type<any> | object): Type<any> | object\r\n}\r\n\r\n/**\r\n * decorator for all.\r\n *\r\n * @export\r\n * @interface IDecorator\r\n * @template T\r\n */\r\nexport interface IDecorator<T extends Metadate> {\r\n    /**\r\n     * define decorator setting with params.\r\n     *\r\n     * @param {(Type<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provider: string | symbol | Type<any>, alias?: string): any;\r\n    /**\r\n     * define decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): any;\r\n    (target: Type<any>): void;\r\n    (target: object, propertyKey: string | symbol): void;\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create dectorator for class params props methods.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createDecorator<T>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): any {\r\n    let metaName = `@${name}`;\r\n\r\n    let factory = (...args: any[]) => {\r\n        let metadata: T = null;\r\n        if (args.length < 1) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        }\r\n        metadata = argsToMetadata(args, adapter);\r\n        if (metadata) {\r\n            return (...args: any[]) => {\r\n                return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n            }\r\n        } else {\r\n            if (args.length === 1) {\r\n                if (!isClass(args[0])) {\r\n                    return (...args: any[]) => {\r\n                        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return storeMetadata(name, metaName, args, metadata, metadataExtends);\r\n    }\r\n\r\n    factory.toString = () => metaName;\r\n    (<any>factory).decoratorType = DecoratorType.All;\r\n    return factory;\r\n}\r\n\r\nfunction argsToMetadata<T>(args: any[], adapter?: MetadataAdapter): T {\r\n    let metadata: T = null;\r\n    if (args.length) {\r\n        if (adapter) {\r\n            let iterator = new ArgsIterator(args);\r\n            adapter(iterator);\r\n            metadata = iterator.getMetadata() as T;\r\n        } else if (args.length === 1 && isMetadataObject(args[0])) {\r\n            metadata = args[0];\r\n        }\r\n    }\r\n    return metadata;\r\n}\r\n\r\n\r\nfunction storeMetadata<T>(name: string, metaName: string, args: any[], metadata?: any, metadataExtends?: MetadataExtends<T>) {\r\n    let target;\r\n    switch (args.length) {\r\n        case 1:\r\n            target = args[0];\r\n            if (isClass(target) || isAbstractDecoratorClass(target)) {\r\n                setTypeMetadata(name, metaName, target, metadata, metadataExtends);\r\n                return target;\r\n            }\r\n            break;\r\n        case 2:\r\n            target = args[0];\r\n            let propertyKey = args[1];\r\n            setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            break;\r\n        case 3:\r\n            if (isNumber(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let parameterIndex = args[2];\r\n                setParamMetadata(name, metaName, target, propertyKey, parameterIndex, metadata, metadataExtends);\r\n            } else if (isUndefined(args[2])) {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                setPropertyMetadata(name, metaName, target, propertyKey, metadata, metadataExtends);\r\n            } else {\r\n                target = args[0];\r\n                let propertyKey = args[1];\r\n                let descriptor = args[2];\r\n                setMethodMetadata(name, metaName, target, propertyKey, descriptor, metadata, metadataExtends);\r\n                return descriptor;\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`Invalid @${name} Decorator declaration.`);\r\n    }\r\n}\r\n\r\n/**\r\n * get all class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * get own class metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns\r\n */\r\nexport function getOwnTypeMetadata<T>(decorator: string | Function, target: Type<any> | AbstractType<T>): T[] {\r\n    let annotations = Reflect.getOwnMetadata(isFunction(decorator) ? decorator.toString() : decorator, target);\r\n    annotations = isArray(annotations) ? annotations : [];\r\n    return annotations;\r\n}\r\n\r\n/**\r\n * has class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name, target);\r\n}\r\n\r\n\r\n\r\n/**\r\n * has own class decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnClassMetadata(decorator: string | Function, target: Type<any> | object): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name, target);\r\n}\r\n\r\n\r\nfunction setTypeMetadata<T extends ClassMetadata>(name: string, metaName: string, target: Type<T> | AbstractType<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let annotations = getOwnTypeMetadata(metaName, target).slice(0);\r\n    // let designParams = Reflect.getMetadata('design:paramtypes', target) || [];\r\n    let typeMetadata = (metadata || {}) as T;\r\n    if (!typeMetadata.type) {\r\n        typeMetadata.type = target;\r\n    }\r\n    typeMetadata.decorator = name;\r\n\r\n    if (metadataExtends) {\r\n        typeMetadata = metadataExtends(typeMetadata);\r\n    }\r\n    annotations.unshift(typeMetadata);\r\n\r\n    setParamerterNames(target);\r\n    Reflect.defineMetadata(metaName, annotations, target);\r\n}\r\n\r\nlet methodMetadataExt = '__method';\r\n/**\r\n * get all method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own method metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnMethodMetadata<T extends MethodMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + methodMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + methodMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * has own method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getOwnMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasOwnMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\n/**\r\n * has method decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasMethodMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getMethodMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + methodMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setMethodMetadata<T extends MethodMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, descriptor: TypedPropertyDescriptor<T>, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnMethodMetadata(metaName, target));\r\n    meta[propertyKey] = meta[propertyKey] || [];\r\n\r\n    let methodMeadata = (metadata || {}) as T;\r\n    methodMeadata.decorator = name;\r\n    methodMeadata.propertyKey = propertyKey;\r\n    // methodMeadata.descriptor = descriptor;\r\n\r\n    if (metadataExtends) {\r\n        methodMeadata = metadataExtends(methodMeadata);\r\n    }\r\n    meta[propertyKey].unshift(methodMeadata);\r\n    Reflect.defineMetadata(metaName + methodMetadataExt, meta, target.constructor);\r\n}\r\n\r\nlet propertyMetadataExt = '__props';\r\n/**\r\n * get all property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n/**\r\n * get own property metadata of one specail decorator in target type.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @returns {ObjectMap<T[]>}\r\n */\r\nexport function getOwnPropertyMetadata<T extends PropertyMetadata>(decorator: string | Function, target: Type<any>): ObjectMap<T[]> {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(name + propertyMetadataExt, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n\r\n/**\r\n * has property decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {Type<any>} target\r\n * @param {(string | symbol)} [propertyKey]\r\n * @returns {boolean}\r\n */\r\nexport function hasPropertyMetadata(decorator: string | Function, target: Type<any>, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    if (propertyKey) {\r\n        let meta = getPropertyMetadata<any>(name, target);\r\n        return meta && meta.hasOwnProperty(propertyKey);\r\n    } else {\r\n        return Reflect.hasMetadata(name + propertyMetadataExt, target);\r\n    }\r\n}\r\n\r\nfunction setPropertyMetadata<T extends PropertyMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n    let meta = lang.assign({}, getOwnPropertyMetadata(metaName, target));\r\n    let propmetadata = (metadata || {}) as T;\r\n\r\n    propmetadata.propertyKey = propertyKey;\r\n    propmetadata.decorator = name;\r\n    if (!propmetadata.type) {\r\n        let t = Reflect.getMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        propmetadata.type = t;\r\n    }\r\n\r\n    if (metadataExtends) {\r\n        propmetadata = metadataExtends(propmetadata);\r\n    }\r\n\r\n    if (!meta[propertyKey] || !isArray(meta[propertyKey])) {\r\n        meta[propertyKey] = [];\r\n    }\r\n\r\n    meta[propertyKey].unshift(propmetadata);\r\n    Reflect.defineMetadata(metaName + propertyMetadataExt, meta, target.constructor);\r\n}\r\n\r\n\r\nlet paramsMetadataExt = '__params';\r\n/**\r\n * get paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * get own paramerter metadata of one specail decorator in target method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {T[][]}\r\n */\r\nexport function getOwnParamMetadata<T extends ParameterMetadata>(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): T[][] {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    let parameters = Reflect.getOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n    parameters = isArray(parameters) ? parameters : [];\r\n    return parameters;\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n/**\r\n * has param decorator metadata.\r\n *\r\n * @export\r\n * @param {(string | Function)} decorator\r\n * @param {(Type<any> | object)} target\r\n * @param {(string | symbol)} propertyKey\r\n * @returns {boolean}\r\n */\r\nexport function hasOwnParamMetadata(decorator: string | Function, target: Type<any> | object, propertyKey?: string | symbol): boolean {\r\n    let name = isFunction(decorator) ? decorator.toString() : decorator;\r\n    return Reflect.hasOwnMetadata(name + paramsMetadataExt, target, propertyKey);\r\n}\r\n\r\n\r\nfunction setParamMetadata<T extends ParameterMetadata>(name: string, metaName: string, target: Type<T>, propertyKey: string, parameterIndex: number, metadata?: T, metadataExtends?: MetadataExtends<any>) {\r\n\r\n    let parameters: any[][] = getOwnParamMetadata(metaName, target, propertyKey).slice(0);\r\n    // there might be gaps if some in between parameters do not have annotations.\r\n    // we pad with nulls.\r\n    while (parameters.length <= parameterIndex) {\r\n        parameters.push(null);\r\n    }\r\n\r\n    parameters[parameterIndex] = parameters[parameterIndex] || [];\r\n\r\n    let paramMeadata = (metadata || {}) as ParameterMetadata;\r\n\r\n    if (!paramMeadata.type) {\r\n        let t = Reflect.getOwnMetadata('design:type', target, propertyKey);\r\n        if (!t) {\r\n            // Needed to support react native inheritance\r\n            t = Reflect.getOwnMetadata('design:type', target.constructor, propertyKey);\r\n        }\r\n        paramMeadata.type = t;\r\n    }\r\n    paramMeadata.propertyKey = propertyKey;\r\n    paramMeadata.decorator = name;\r\n    paramMeadata.index = parameterIndex;\r\n    if (metadataExtends) {\r\n        paramMeadata = metadataExtends(paramMeadata);\r\n    }\r\n    parameters[parameterIndex].unshift(paramMeadata);\r\n    Reflect.defineMetadata(metaName + paramsMetadataExt, parameters, target, propertyKey);\r\n}\r\n\r\n\r\n\r\nexport function getParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\nexport function getOwnParamerterNames(target: Type<any> | AbstractType<any>): ObjectMap<string[]> {\r\n    let meta = Reflect.getOwnMetadata(ParamerterName, target);\r\n    if (!meta || isArray(meta) || !lang.hasField(meta)) {\r\n        meta = Reflect.getOwnMetadata(ParamerterName, target.constructor);\r\n    }\r\n    return isArray(meta) ? {} : (meta || {});\r\n}\r\n\r\n\r\nexport function setParamerterNames(target: Type<any> | AbstractType<any>) {\r\n    let meta = lang.assign({}, getParamerterNames(target));\r\n    let descriptors = Object.getOwnPropertyDescriptors(target.prototype);\r\n    let isUglify = /^[a-z]/.test(target.name);\r\n    let anName = '';\r\n    if (target.classAnnations && target.classAnnations.params) {\r\n        anName = target.classAnnations.name;\r\n        meta = lang.assign(meta, target.classAnnations.params);\r\n    }\r\n    if (!isUglify && target.name !== anName) {\r\n        lang.forIn(descriptors, (item, name) => {\r\n            if (name !== 'constructor') {\r\n                if (item.value) {\r\n                    meta[name] = getParamNames(item.value)\r\n                }\r\n                if (item.set) {\r\n                    meta[name] = getParamNames(item.set);\r\n                }\r\n            }\r\n        });\r\n        meta['constructor'] = getParamNames(target.prototype.constructor);\r\n    }\r\n\r\n    Reflect.defineMetadata(ParamerterName, meta, target);\r\n}\r\n\r\nconst STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\nconst ARGUMENT_NAMES = /([^\\s,]+)/g;\r\nfunction getParamNames(func) {\r\n    if (!isFunction(func)) {\r\n        return [];\r\n    }\r\n    let fnStr = func.toString().replace(STRIP_COMMENTS, '');\r\n    let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\r\n    if (result === null) {\r\n        result = [];\r\n    }\r\n    return result;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { Type } from '../../types';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { Registration } from '../../Registration';\r\nimport { isString, isSymbol, isObject, isNumber, isBoolean } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\n\r\n/**\r\n * Type decorator.\r\n *\r\n * @export\r\n * @interface ITypeDecorator\r\n * @template T\r\n */\r\nexport interface ITypeDecorator<T extends ClassMetadata> {\r\n    /**\r\n     * define class decorator setting with metadata map.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): ClassDecorator;\r\n    /**\r\n     * not allow abstract to decorator with out metadata.\r\n     */\r\n    (target: Type<any>): void;\r\n}\r\n\r\n/**\r\n * class decorator.\r\n *\r\n * @export\r\n * @interface IClassDecorator\r\n */\r\nexport interface IClassDecorator<T extends ClassMetadata> extends ITypeDecorator<T> {\r\n    /**\r\n     * define class decorator setting with params.\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string, singlton?: boolean, cache?: number): ClassDecorator;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * create class decorator\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {*}\r\n */\r\nexport function createClassDecorator<T extends ClassMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassDecorator<T> {\r\n\r\n    let classAdapter = ((args: ArgsIterator) => {\r\n        let metadata;\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            // isMetadata: (arg) => isClassMetadata(arg),\r\n            match: (arg) => arg && (isSymbol(arg) || isString(arg) || (isObject(arg) && arg instanceof Registration)),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provide = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isString(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.alias = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isBoolean(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.singleton = arg;\r\n            }\r\n        });\r\n\r\n        args.next<T>({\r\n            match: (arg) => isNumber(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.expires = arg;\r\n            }\r\n        });\r\n    });\r\n    let decorator = createDecorator<T>(name, classAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Class;\r\n    return decorator;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { MethodMetadata } from '../metadatas';\r\nimport { Providers} from '../../types';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { isArray } from '../../utils';\r\n\r\n\r\n/**\r\n * Method decorator.\r\n *\r\n * @export\r\n * @interface IMethodDecorator\r\n */\r\nexport interface IMethodDecorator<T extends MethodMetadata> {\r\n    /**\r\n     * create method decorator with providers.\r\n     *\r\n     * @param  {Providers[]} [providers]\r\n     */\r\n    (providers?: Providers[]): MethodDecorator;\r\n    /**\r\n     * create method decorator with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodDecorator;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n\r\n/**\r\n * create method decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createMethodDecorator<T extends MethodMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodDecorator<T> {\r\n\r\n    let methodAdapter = (args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n\r\n        args.next<T>({\r\n            match: (arg) => isArray(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.providers = arg;\r\n            }\r\n        });\r\n    }\r\n\r\n    let decorator = createDecorator<T>(name, methodAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method;\r\n    return decorator;\r\n}\r\n","import 'reflect-metadata';\r\nimport { ParameterMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isParamMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * Parameter decorator.\r\n *\r\n * @export\r\n * @interface IParameterDecorator\r\n */\r\nexport interface IParameterDecorator<T extends ParameterMetadata> {\r\n    /**\r\n     * define parameter decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter.\r\n     */\r\n    (provider: Token<T>): ParameterDecorator;\r\n    /**\r\n     * define parameter decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter.\r\n     */\r\n    (metadata?: T): ParameterDecorator;\r\n    (target: object, propertyKey: string | symbol, parameterIndex: number): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * create parameter decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createParamDecorator<T extends ParameterMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParameterDecorator<T> {\r\n\r\n    let paramAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isParamMetadata(arg),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n","import { PropertyMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isPropertyMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n/**\r\n * property decorator.\r\n *\r\n * @export\r\n * @interface IPropertyDecorator\r\n */\r\nexport interface IPropertyDecorator<T extends PropertyMetadata> {\r\n    /**\r\n     * define property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the property.\r\n     */\r\n    (provider: Token<any>): PropertyDecorator;\r\n    /**\r\n     * define property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the property.\r\n     */\r\n    (metadata?: T): PropertyDecorator;\r\n    (target: object, propertyKey: string | symbol): void;\r\n}\r\n\r\n\r\n/**\r\n * create property decorator.\r\n *\r\n * @export\r\n * @template T metadata type.\r\n * @param {string} name decorator name.\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns\r\n */\r\nexport function createPropDecorator<T extends PropertyMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IPropertyDecorator<T> {\r\n    let propPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isPropertyMetadata(arg),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, propPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property;\r\n    return decorator;\r\n}\r\n\r\n","import 'reflect-metadata';\r\nimport { ParamPropMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\nimport { isToken, isParamPropMetadata } from '../../utils';\r\nimport { ArgsIterator } from './ArgsIterator';\r\nimport { Token } from '../../types';\r\n\r\n\r\n\r\nexport type PropParamDecorator = (target: Object, propertyKey: string | symbol, parameterIndex?: number) => void;\r\n/**\r\n * Parameter and Property decorator.\r\n *\r\n * @export\r\n * @interface IParamPropDecorator\r\n */\r\nexport interface IParamPropDecorator<T extends ParamPropMetadata> {\r\n    /**\r\n     * define parameter or property decorator with param.\r\n     *\r\n     * @param {Token<T>} provider define provider to resolve value to the parameter or property.\r\n     */\r\n    (provider: Token<any>): PropParamDecorator;\r\n    /**\r\n     * define parameter or property decorator with metadata map.\r\n     * @param {T} [metadata] define matadata map to resolve value to the parameter or property.\r\n     */\r\n    (metadata?: T): PropParamDecorator;\r\n    (target: object, propertyKey: string | symbol, parameterIndex?: number): void;\r\n}\r\n\r\n/**\r\n * create parameter or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IParamPropDecorator<T>}\r\n */\r\nexport function createParamPropDecorator<T extends ParamPropMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IParamPropDecorator<T> {\r\n    let paramPropAdapter = ((args: ArgsIterator) => {\r\n        if (adapter) {\r\n            adapter(args);\r\n        }\r\n        args.next<T>({\r\n            isMetadata: (arg) => isParamPropMetadata(arg),\r\n            match: (arg) => isToken(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.provider = arg;\r\n            }\r\n        });\r\n        // args.next<T>({\r\n        //     match: (arg) => isString(arg),\r\n        //     setMetadata: (metadata, arg) => {\r\n        //         metadata.alias = arg;\r\n        //     }\r\n        // });\r\n    });\r\n    let decorator = createDecorator<T>(name, paramPropAdapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Property | DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n\r\n","import { Type } from '../../types';\r\nimport { TypeMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory'\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\nexport type ClassMethodDecorator = (target: Object | Type<any>, propertyKey?: string | symbol, descriptor?: TypedPropertyDescriptor<any>) => void;\r\n\r\n/**\r\n * class method decorator\r\n *\r\n * @export\r\n * @interface IClassMethodDecorator\r\n * @template T\r\n */\r\nexport interface IClassMethodDecorator<T extends TypeMetadata> {\r\n    /**\r\n     * create decorator with metadata map. for class or method decorator.\r\n     *\r\n     * @param {T} [metadata] metadata map.\r\n     */\r\n    (metadata?: T): ClassMethodDecorator;\r\n\r\n    (target: Type<any>): void;\r\n    (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create decorator for class and method.\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IClassMethodDecorator<T>}\r\n */\r\nexport function createClassMethodDecorator<T extends TypeMetadata>(name: string, adapter?: MetadataAdapter, metadataExtends?: MetadataExtends<T>): IClassMethodDecorator<T> {\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Class | DecoratorType.Method;\r\n    return decorator;\r\n}\r\n\r\n","import { MethodPropMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\n\r\nexport type MethodPropDecorator = (target: Object, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<any>) => void;\r\n/**\r\n * method and Property decorator.\r\n *\r\n * @export\r\n * @interface IMethodPropDecorator\r\n */\r\nexport interface IMethodPropDecorator<T extends MethodPropMetadata> {\r\n    /**\r\n     * create method decorator with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodPropDecorator;\r\n    (target: object, propertyKey: string | symbol, descriptor?: TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * create method or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IMethodPropDecorator<T>}\r\n */\r\nexport function createMethodPropDecorator<T extends MethodPropMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodPropDecorator<T> {\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method | DecoratorType.Property;\r\n    return decorator;\r\n}\r\n\r\n","import { TypeMetadata } from '../metadatas';\r\nimport { createDecorator, MetadataAdapter, MetadataExtends } from './DecoratorFactory';\r\nimport { DecoratorType } from './DecoratorType';\r\n\r\n\r\n\r\nexport type MethodPropParamDecorator = (target: Object, propertyKey: string | symbol, descriptor?: number | TypedPropertyDescriptor<any>) => void;\r\n/**\r\n * method and Property decorator.\r\n *\r\n * @export\r\n * @interface IMethodPropParamDecorator\r\n */\r\nexport interface IMethodPropParamDecorator<T extends TypeMetadata> {\r\n    /**\r\n     * define method or property decorator with metadata map.\r\n     * @param {T} [metadata] metadata map\r\n     */\r\n    (metadata?: T): MethodPropParamDecorator;\r\n    (target: object, propertyKey: string | symbol, descriptor?: number | TypedPropertyDescriptor<any>): void;\r\n}\r\n\r\n/**\r\n * define method or property decorator\r\n *\r\n * @export\r\n * @template T\r\n * @param {string} name\r\n * @param {MetadataAdapter} [adapter]  metadata adapter\r\n * @param {MetadataExtends<T>} [metadataExtends] add extents for metadata.\r\n * @returns {IMethodPropParamDecorator<T>}\r\n */\r\nexport function createMethodPropParamDecorator<T extends TypeMetadata>(\r\n    name: string,\r\n    adapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IMethodPropParamDecorator<T> {\r\n\r\n    let decorator = createDecorator<T>(name, adapter, metadataExtends);\r\n    decorator.decoratorType = DecoratorType.Method | DecoratorType.Property | DecoratorType.Parameter;\r\n    return decorator;\r\n}\r\n\r\n","export * from './ArgsIterator';\r\nexport * from './DecoratorType';\r\nexport * from './DecoratorFactory';\r\n\r\nexport * from './ClassDecoratorFactory';\r\nexport * from './MethodDecoratorFactory';\r\nexport * from './ParamDecoratorFactory';\r\nexport * from './PropertyDecoratorFactory';\r\nexport * from './ParamPropDecoratorFactory';\r\nexport * from './ClassMethodDecoratorFactory';\r\nexport * from './MethodPropDecoratorFactory';\r\nexport * from './MethodPropParamDecoratorFactory';\r\n\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnTypeMetadata, hasOwnClassMetadata } from '../factories';\r\nimport { IContainer } from '../../IContainer';\r\nimport { Token } from '../../types';\r\nimport { ClassMetadata } from '../metadatas';\r\n\r\n/**\r\n * bind provider action data.\r\n *\r\n * @export\r\n * @interface BindProviderActionData\r\n * @extends {ActionData<Token<any>[]>}\r\n */\r\nexport interface BindProviderActionData extends ActionData<Token<any>[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind provider action. for binding a factory to an token.\r\n *\r\n * @export\r\n * @class BindProviderAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindProviderAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindProvider)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindProviderActionData) {\r\n        let type = data.targetType;\r\n        let lifeScope = container.getLifeScope();\r\n\r\n        let matchs = lifeScope.getClassDecorators(surm => surm.actions.includes(CoreActions.bindProvider) && hasOwnClassMetadata(surm.name, type));\r\n\r\n        let provides = [];\r\n        let raiseContainer = data.raiseContainer || container;\r\n        matchs.forEach(surm => {\r\n            let metadata = getOwnTypeMetadata<ClassMetadata>(surm.name, type);\r\n            if (Array.isArray(metadata) && metadata.length > 0) {\r\n                // bind all provider.\r\n                metadata.forEach(c => {\r\n                    if (c && c.provide) {\r\n                        let provideKey = raiseContainer.getTokenKey(c.provide, c.alias);\r\n                        provides.push(provideKey);\r\n                        raiseContainer.bindProvider(provideKey, c.type);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        data.execResult = provides;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BindProviderAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getParamMetadata, getOwnParamMetadata, hasParamMetadata, hasOwnParamMetadata } from '../factories';\r\nimport { ParameterMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { Token } from '../../types';\r\nimport { isArray } from '../../utils';\r\n\r\n/**\r\n * bind parameter type action data.\r\n *\r\n * @export\r\n * @interface BindParameterTypeActionData\r\n * @extends {ActionData<Token<any>[]>}\r\n */\r\nexport interface BindParameterTypeActionData extends ActionData<Token<any>[]> {\r\n}\r\n\r\n/**\r\n * bind parameter type action.\r\n *\r\n * @export\r\n * @class BindParameterTypeAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindParameterTypeAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindParameterType)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ActionData<Token<any>[]>) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let target = data.target\r\n        let type = data.targetType;\r\n        let propertyKey = data.propertyKey;\r\n        let lifeScope = container.getLifeScope();\r\n        let designParams: Token<any>[];\r\n\r\n        if (target && propertyKey) {\r\n            designParams = Reflect.getMetadata('design:paramtypes', target, propertyKey) || [];\r\n        } else {\r\n            designParams = Reflect.getMetadata('design:paramtypes', type) || [];\r\n        }\r\n\r\n        designParams = designParams.slice(0);\r\n        designParams.forEach(dtype => {\r\n            if (lifeScope.isVaildDependence(dtype)) {\r\n                if (!container.has(dtype)) {\r\n                    container.register(dtype);\r\n                }\r\n            }\r\n        });\r\n\r\n\r\n        let matchs = lifeScope.getParameterDecorators((surm => {\r\n            return surm.actions.includes(CoreActions.bindParameterType) && ((target || propertyKey !== 'constructor') ? hasParamMetadata(surm.name, target, propertyKey)\r\n                : hasOwnParamMetadata(surm.name, type));\r\n        }));\r\n\r\n        matchs.forEach(surm => {\r\n            let parameters = (target || propertyKey !== 'constructor') ? getParamMetadata<ParameterMetadata>(surm.name, target, propertyKey) : getOwnParamMetadata<ParameterMetadata>(surm.name, type);\r\n            if (isArray(parameters) && parameters.length) {\r\n                parameters.forEach(params => {\r\n                    let parm = (isArray(params) && params.length > 0) ? params[0] : null;\r\n                    if (parm && parm.index >= 0) {\r\n                        if (lifeScope.isVaildDependence(parm.provider)) {\r\n                            if (!container.has(parm.provider, parm.alias)) {\r\n                                container.register(container.getToken(parm.provider, parm.alias));\r\n                            }\r\n                        }\r\n                        if (lifeScope.isVaildDependence(parm.type)) {\r\n                            if (!container.has(parm.type)) {\r\n                                container.register(parm.type);\r\n                            }\r\n                        }\r\n                        let token = parm.provider ? container.getTokenKey(parm.provider, parm.alias) : parm.type;\r\n                        if (token) {\r\n                            designParams[parm.index] = token;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        data.execResult = designParams;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BindParameterTypeAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getPropertyMetadata, hasPropertyMetadata } from '../factories';\r\nimport { PropertyMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\n\r\n/**\r\n * bind property type action data.\r\n *\r\n * @export\r\n * @interface BindPropertyTypeActionData\r\n * @extends {ActionData<PropertyMetadata[]>}\r\n */\r\nexport interface BindPropertyTypeActionData extends ActionData<PropertyMetadata[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind property type action. to get the property autowride token of Type calss.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindPropertyTypeAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindPropertyType)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindPropertyTypeActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let type = data.targetType;\r\n        let lifeScope = container.getLifeScope();\r\n\r\n        let matchs = lifeScope.getPropertyDecorators(surm => surm.actions.includes(CoreActions.bindPropertyType) && hasPropertyMetadata(surm.name, type));\r\n        let list: PropertyMetadata[] = [];\r\n        matchs.forEach(surm => {\r\n            let propMetadata = getPropertyMetadata<PropertyMetadata>(surm.name, type);\r\n\r\n            for (let n in propMetadata) {\r\n                list = list.concat(propMetadata[n]);\r\n            }\r\n            list = list.filter(n => !!n);\r\n            list.forEach(prop => {\r\n                if (lifeScope.isVaildDependence(prop.provider)) {\r\n                    if (!container.has(prop.provider, prop.alias)) {\r\n                        container.register(container.getToken(prop.provider, prop.alias));\r\n                    }\r\n                }\r\n                if (lifeScope.isVaildDependence(prop.type)) {\r\n                    if (!container.has(prop.type)) {\r\n                        container.register(prop.type);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        data.execResult = list;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BindPropertyTypeAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { BindPropertyTypeActionData } from './BindPropertyTypeAction';\r\nimport { IContainer } from '../../IContainer';\r\nimport { CoreActions } from './CoreActions';\r\nimport { ActionComposite } from './ActionComposite';\r\n\r\n\r\n/**\r\n * inject property action data.\r\n *\r\n * @export\r\n * @interface InjectPropertyActionData\r\n * @extends {BindPropertyTypeActionData}\r\n */\r\nexport interface InjectPropertyActionData extends BindPropertyTypeActionData {\r\n\r\n}\r\n\r\n/**\r\n * inject property value action, to inject property value for resolve instance.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class InjectPropertyAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.injectProperty)\r\n    }\r\n\r\n    protected working(container: IContainer, data: InjectPropertyActionData) {\r\n        if (!data.execResult) {\r\n            this.parent.find(act => act.name === CoreActions.bindPropertyType).execute(container, data);\r\n        }\r\n\r\n        if (data.target && data.execResult && data.execResult.length) {\r\n            let providerMap = data.providerMap;\r\n            data.execResult.reverse().forEach((prop, idx) => {\r\n                if (prop) {\r\n                    let token = prop.provider ? container.getToken(prop.provider, prop.alias) : prop.type;\r\n                    if (providerMap && providerMap.has(token)) {\r\n                        data.target[prop.propertyKey] = providerMap.resolve(token, providerMap);\r\n                    } else if (container.has(token)) {\r\n                        data.target[prop.propertyKey] = container.resolve(token, providerMap);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InjectPropertyAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionComposite } from './ActionComposite';\r\nimport { ActionData } from '../ActionData';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnMethodMetadata, hasOwnMethodMetadata } from '../factories';\r\nimport { MethodMetadata } from '../metadatas';\r\nimport { IContainer } from '../../IContainer';\r\nimport { Providers } from '../../types';\r\nimport { isArray } from '../../utils';\r\n\r\n/**\r\n * bind parameter provider action data.\r\n *\r\n * @export\r\n * @interface BindParameterProviderActionData\r\n * @extends {ActionData<Providers[]>}\r\n */\r\nexport interface BindParameterProviderActionData extends ActionData<Providers[]> {\r\n\r\n}\r\n\r\n/**\r\n * bind parameters action.\r\n *\r\n * @export\r\n * @class BindParameterProviderAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindParameterProviderAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.bindParameterProviders)\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindParameterProviderActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        let type = data.targetType;\r\n        let propertyKey = data.propertyKey;\r\n        let lifeScope = container.getLifeScope();\r\n\r\n        let matchs = lifeScope.getMethodDecorators(surm => surm.actions.includes(CoreActions.bindParameterProviders) && hasOwnMethodMetadata(surm.name, type));\r\n\r\n        let providers: Providers[] = [];\r\n        matchs.forEach(surm => {\r\n            let methodmtas = getOwnMethodMetadata<MethodMetadata>(surm.name, type);\r\n            let metadatas = methodmtas[propertyKey];\r\n            if (metadatas && isArray(metadatas) && metadatas.length > 0) {\r\n                metadatas.forEach(meta => {\r\n                    if (meta.providers && meta.providers.length > 0) {\r\n                        providers = providers.concat(meta.providers);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        data.execResult = providers;\r\n\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BindParameterProviderAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { BeforeInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\n\r\n\r\n\r\n/**\r\n * component before init action data.\r\n *\r\n * @export\r\n * @interface ComponentBeforeInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentBeforeInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component before init action, to run @Component decorator class before init hooks.\r\n *\r\n * @export\r\n * @class ComponentBeforeInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentBeforeInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentBeforeInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentBeforeInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            let component = data.target as BeforeInit;\r\n            if (isFunction(component.beforeInit)) {\r\n                container.syncInvoke(data.targetType, 'beforeInit', data.target);\r\n            }\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ComponentBeforeInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { OnInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\n\r\n\r\n\r\n/**\r\n * component init action data.\r\n *\r\n * @export\r\n * @interface ComponentInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component before init action, to run @Component decorator class before init hooks.\r\n *\r\n * @export\r\n * @class ComponentInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            let component = data.target as OnInit;\r\n            if (isFunction(component.onInit)) {\r\n                container.syncInvoke(data.targetType, 'onInit', data.target);\r\n            }\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ComponentInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { AfterInit } from '../ComponentLifecycle';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\n\r\n\r\n/**\r\n * component after init action data.\r\n *\r\n * @export\r\n * @interface ComponentAfterInitActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface ComponentAfterInitActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * component after init action, to run @Component decorator class after init hooks.\r\n *\r\n * @export\r\n * @class ComponentAfterInitAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ComponentAfterInitAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.componentAfterInit)\r\n    }\r\n\r\n    protected working(container: IContainer, data: ComponentAfterInitActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.targetType && data.target) {\r\n            let component = data.target as AfterInit;\r\n            if (isFunction(component.afterInit)) {\r\n                container.syncInvoke(data.targetType, 'afterInit', data.target);\r\n            }\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ComponentAfterInitAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { Type } from './types';\r\nimport { InjectToken } from './InjectToken';\r\n\r\n/**\r\n * ICacheManager interface token.\r\n * it is a token id, you can register yourself ICacheManager for this.\r\n */\r\nexport const CacheManagerToken = new InjectToken<ICacheManager>('DI_ICacheManager');\r\n\r\n/**\r\n * cache manager inteface.\r\n *\r\n * @export\r\n * @interface ICacheManager\r\n */\r\nexport interface ICacheManager {\r\n    /**\r\n     * has cache\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @returns {boolean}\r\n     * @memberof ICacheManager\r\n     */\r\n    hasCache(targetType: Type<any>): boolean;\r\n    /**\r\n     * cache target.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {*} target\r\n     * @param {number} expires\r\n     * @memberof ICacheManager\r\n     */\r\n    cache(targetType: Type<any>, target: any, expires: number);\r\n    /**\r\n     * get cache target, if set expires will refresh cache timeout.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {number} [expires] if set number will reset cache timeout.\r\n     * @returns {*}\r\n     * @memberof ICacheManager\r\n     */\r\n    get(targetType: Type<any>, expires?: number): any;\r\n\r\n    /**\r\n     * is check expires or not.\r\n     *\r\n     * @returns {boolean}\r\n     * @memberof ICacheManager\r\n     */\r\n    isChecking(): boolean;\r\n    /**\r\n     * run check expires.\r\n     *\r\n     * @memberof ICacheManager\r\n     */\r\n    checkExpires();\r\n    /**\r\n     * destory cache\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @param {*} [target]\r\n     * @memberof ICacheManager\r\n     */\r\n    destroy(targetType: Type<any>, target?: any);\r\n}\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { isNumber, isClass } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { getOwnTypeMetadata, hasOwnClassMetadata } from '../factories';\r\nimport { CacheManagerToken } from '../../ICacheManager';\r\n\r\n\r\n/**\r\n * cache action data.\r\n *\r\n * @export\r\n * @interface CacheActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface CacheActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * cache action. To cache instance of Token. define cache expires in decorator.\r\n *\r\n * @export\r\n * @class CacheAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class CacheAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.cache)\r\n    }\r\n\r\n    protected working(container: IContainer, data: CacheActionData) {\r\n\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return data;\r\n        }\r\n\r\n        if (data.singleton || !data.targetType || !isClass(data.targetType)) {\r\n            return data;\r\n        }\r\n        let cacheManager = container.get(CacheManagerToken);\r\n\r\n        if (data.target) {\r\n            if (!cacheManager.hasCache(data.targetType)) {\r\n                let cacheMetadata = this.getCacheMetadata(container, data);\r\n                if (cacheMetadata) {\r\n                    cacheManager.cache(data.targetType, data.target, cacheMetadata.expires);\r\n                }\r\n            }\r\n        } else {\r\n            let target = cacheManager.get(data.targetType);\r\n            if (target) {\r\n                let cacheMetadata = this.getCacheMetadata(container, data);\r\n                if (cacheMetadata) {\r\n                    cacheManager.cache(data.targetType, target, cacheMetadata.expires);\r\n                    data.execResult = target;\r\n                }\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    getCacheMetadata(container: IContainer, data: CacheActionData): ClassMetadata {\r\n        let lifeScope = container.getLifeScope();\r\n        let matchs = lifeScope.getClassDecorators(surm => hasOwnClassMetadata(surm.name, data.targetType));\r\n        let cacheMetadata: ClassMetadata;\r\n        for (let i = 0; i < matchs.length; i++) {\r\n            let surm = matchs[i];\r\n            let metadata = getOwnTypeMetadata<ClassMetadata>(surm.name, data.targetType);\r\n            if (Array.isArray(metadata) && metadata.length > 0) {\r\n                cacheMetadata = metadata.find(c => c && isNumber(c.expires) && c.expires > 0);\r\n                if (cacheMetadata) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return cacheMetadata;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"CacheAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"],\"getCacheMetadata\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { ActionData } from '../ActionData';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { CoreActions } from './CoreActions';\r\n\r\n\r\n\r\n/**\r\n * singleton action data.\r\n *\r\n * @export\r\n * @interface SingletionActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface SingletionActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * singleton action, to set the factory of Token as singleton.\r\n *\r\n * @export\r\n * @class SingletionAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class SingletionAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.singletion)\r\n    }\r\n\r\n    protected working(container: IContainer, data: SingletionActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.tokenKey && data.target && data.singleton) {\r\n            container.registerValue(data.tokenKey, data.target);\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"SingletionAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { InjectableMetadata } from '../metadatas';\r\nimport { Registration } from '../../Registration';\r\n\r\n/**\r\n * Component decorator\r\n *\r\n * @export\r\n * @interface IInjectableDecorator\r\n * @extends {IClassDecorator<InjectableMetadata>}\r\n */\r\nexport interface IComponentDecorator extends ITypeDecorator<InjectableMetadata> {\r\n    /**\r\n     * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\r\n     *\r\n     * @Component\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string, singlton?: boolean, cache?: number): ClassDecorator;\r\n\r\n    /**\r\n     * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\r\n     *\r\n     * @Component\r\n     *\r\n     * @param {InjectableMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: InjectableMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Component decorator, define for class. use to define the class. it can setting provider to some token, singleton or not. it will execute  [`ComponentLifecycle`]\r\n *\r\n * @Component\r\n */\r\nexport const Component: IComponentDecorator = createClassDecorator<InjectableMetadata>('Component');\r\n\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { InjectableMetadata } from '../metadatas';\r\nimport { Registration } from '../../Registration';\r\n\r\n/**\r\n * Injectable decorator\r\n *\r\n * @export\r\n * @interface IInjectableDecorator\r\n * @extends {IClassDecorator<InjectableMetadata>}\r\n */\r\nexport interface IInjectableDecorator extends ITypeDecorator<InjectableMetadata> {\r\n    /**\r\n     * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n     *\r\n     * @Injectable\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string, singlton?: boolean, cache?: number): ClassDecorator;\r\n\r\n    /**\r\n     * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n     *\r\n     * @Injectable\r\n     *\r\n     * @param {InjectableMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: InjectableMetadata): ClassDecorator;\r\n}\r\n\r\n\r\n/**\r\n * Injectable decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n *\r\n * @Injectable\r\n */\r\nexport const Injectable: IInjectableDecorator = createClassDecorator<InjectableMetadata>('Injectable');\r\n\r\n","import { IParamPropDecorator, createParamPropDecorator } from '../factories';\r\nimport { InjectMetadata } from '../metadatas';\r\n\r\n/**\r\n * Inject decorator, for property or param, use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @Inject\r\n */\r\nexport const Inject: IParamPropDecorator<InjectMetadata> = createParamPropDecorator<InjectMetadata>('Inject');\r\n","import { IParamPropDecorator, createParamPropDecorator } from '../factories';\r\nimport { AutoWiredMetadata } from '../metadatas';\r\n\r\n/**\r\n * AutoWired decorator, for property or param. use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @AutoWired\r\n */\r\nexport const AutoWired: IParamPropDecorator<AutoWiredMetadata> = createParamPropDecorator<AutoWiredMetadata>('AutoWired');\r\n\r\n","import { ParameterMetadata } from '../metadatas';\r\nimport { createParamDecorator, IParameterDecorator } from '../factories';\r\n\r\n/**\r\n * param decorator, define for parameter. use to auto wried type instance or value to the instance of one class with the decorator.\r\n *\r\n * @Param\r\n */\r\nexport const Param: IParameterDecorator<ParameterMetadata> = createParamDecorator<ParameterMetadata>('Param');\r\n","import { MethodMetadata } from '../metadatas';\r\nimport { createMethodDecorator, IMethodDecorator } from '../factories';\r\n\r\n/**\r\n * method decorator.\r\n *\r\n * @Method\r\n */\r\nexport const Method: IMethodDecorator<MethodMetadata> = createMethodDecorator<MethodMetadata>('Method');\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { ClassMetadata } from '../metadatas';\r\nimport { Registration } from '../../Registration';\r\n\r\n/**\r\n * Singleton decorator, for class. use to define the class is singleton.\r\n *\r\n * @Singleton\r\n *\r\n * @export\r\n * @interface ISingletonDecorator\r\n * @extends {IClassDecorator<ClassMetadata>}\r\n */\r\nexport interface ISingletonDecorator extends ITypeDecorator<ClassMetadata> {\r\n    /**\r\n     * Singleton decorator, for class. use to define the class is singleton.\r\n     *\r\n     * @Singleton\r\n     *\r\n     * @param {(Registration<any> | symbol | string)} provide define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     */\r\n    (provide: Registration<any> | symbol | string, alias?: string): ClassDecorator;\r\n\r\n    /**\r\n     * Singleton decorator, for class. use to define the class is singleton.\r\n     *\r\n     * @Singleton\r\n     *\r\n     * @param {ClassMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: ClassMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * Singleton decorator, for class. use to define the class is singleton.\r\n *\r\n * @Singleton\r\n */\r\nexport const Singleton: ISingletonDecorator = createClassDecorator<ClassMetadata>('Singleton', null, (metadata) => {\r\n    metadata.singleton = true;\r\n    return metadata;\r\n}) as ISingletonDecorator;\r\n\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { ClassMetadata } from '../metadatas';\r\n\r\n\r\n\r\n/**\r\n * Abstract decorator. define for class.\r\n *\r\n * @Abstract\r\n */\r\nexport const Abstract: ITypeDecorator<ClassMetadata> = createClassDecorator<ClassMetadata>('Abstract');\r\n\r\n","import { IClassMethodDecorator, createClassMethodDecorator, ClassMethodDecorator } from '../factories';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { isClassMetadata, isString, isNumber } from '../../utils';\r\n\r\n\r\n/**\r\n * autorun decorator inteface\r\n *\r\n * @export\r\n * @interface IAutorunDecorator\r\n * @extends {IClassMethodDecorator<AutorunMetadata>}\r\n */\r\nexport interface IAutorunDecorator extends IClassMethodDecorator<AutorunMetadata> {\r\n    /**\r\n     * Autorun decorator, for class.  use to define the class auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {string} [autorun] the special method name when define to class.\r\n     */\r\n    (autorun: string): ClassDecorator;\r\n\r\n    /**\r\n     * Autorun decorator, for method.  use to define the method auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {string} [autorun] the special method name when define to class.\r\n     */\r\n    (order: number): MethodDecorator;\r\n\r\n    /**\r\n     * Autorun decorator, for class or method. use to define the class auto run (via a method or not) after registered.\r\n     * @Autorun\r\n     *\r\n     * @param {AutorunMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: AutorunMetadata): ClassMethodDecorator;\r\n}\r\n\r\n/**\r\n * Autorun decorator, for class or method.  use to define the class auto run (via a method or not) after registered.\r\n *\r\n * @Autorun\r\n */\r\nexport const Autorun: IAutorunDecorator = createClassMethodDecorator<AutorunMetadata>('Autorun', args => {\r\n    args.next<AutorunMetadata>({\r\n        isMetadata: (arg) => isClassMetadata(arg, ['autorun']),\r\n        match: (arg) => isString(arg) || isNumber(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            if (isString(arg)) {\r\n                metadata.autorun = arg;\r\n            } else {\r\n                metadata.order = arg;\r\n            }\r\n        }\r\n    });\r\n}, (metadata) => {\r\n    metadata.singleton = true;\r\n    return metadata;\r\n}) as IAutorunDecorator;\r\n","import { createClassDecorator, ITypeDecorator } from '../factories';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { isClassMetadata, isString } from '../../utils';\r\n\r\n/**\r\n * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n *\r\n * @IocExt\r\n */\r\nexport interface IocExtDecorator extends ITypeDecorator<AutorunMetadata> {\r\n    /**\r\n     * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n     *\r\n     * @IocExt\r\n     *\r\n     * @param {string} [autorun] auto run special method.\r\n     */\r\n    (autorun?: string): ClassDecorator;\r\n\r\n    /**\r\n     * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n     *\r\n     * @IocExt\r\n     *\r\n     * @param {AutorunMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: AutorunMetadata): ClassDecorator;\r\n}\r\n\r\n/**\r\n * IocExt decorator. define for class, use to define the class is Ioc extends module. it will auto run after registered to helper your to setup module.\r\n *\r\n * @IocExt\r\n */\r\nexport const IocExt: IocExtDecorator = createClassDecorator<AutorunMetadata>('IocExt',\r\n    args => {\r\n        args.next<AutorunMetadata>({\r\n            isMetadata: (arg) => isClassMetadata(arg, ['autorun']),\r\n            match: (arg) => isString(arg),\r\n            setMetadata: (metadata, arg) => {\r\n                metadata.autorun = arg;\r\n            }\r\n        })\r\n    }, (metadata) => {\r\n        metadata.singleton = true;\r\n        return metadata;\r\n    }) as IocExtDecorator;\r\n\r\nexport const IocModule = IocExt;\r\n","export * from './Component';\r\nexport * from './Injectable';\r\nexport * from './Inject';\r\nexport * from './AutoWried';\r\nexport * from './Param';\r\nexport * from './Method';\r\nexport * from './Singleton';\r\nexport * from './Abstract';\r\nexport * from './AutoRun';\r\nexport * from './IocExt';\r\n","import { ActionData } from '../ActionData';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { isFunction } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { hasClassMetadata, getTypeMetadata } from '../factories';\r\nimport { Autorun, IocExt } from '../decorators';\r\n\r\n\r\n\r\n\r\n/**\r\n * auto run action data.\r\n *\r\n * @export\r\n * @interface AutorunActionData\r\n * @extends {ActionData<AutorunMetadata>}\r\n */\r\nexport interface AutorunActionData extends ActionData<AutorunMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * Inject DrawType action.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class AutorunAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.autorun)\r\n    }\r\n\r\n    protected getDecorator(): Function[] {\r\n        return [IocExt, Autorun];\r\n    }\r\n\r\n    protected working(container: IContainer, data: AutorunActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.tokenKey && data.targetType) {\r\n            let decorators = this.getDecorator();\r\n            decorators.forEach(decorator => {\r\n                if (hasClassMetadata(decorator, data.targetType)) {\r\n                    let metas = getTypeMetadata<AutorunMetadata>(decorator, data.targetType);\r\n                    let meta = metas.find(it => !!it.autorun);\r\n                    if (!meta && metas.length) {\r\n                        meta = metas[0]\r\n                    }\r\n                    if (meta) {\r\n                        let instance = container.get(data.tokenKey);\r\n                        if (instance && meta.autorun && isFunction(instance[meta.autorun])) {\r\n                            container.syncInvoke(data.tokenKey, meta.autorun, instance);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AutorunAction\",\"params\":{\"constructor\":[],\"getDecorator\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","export * from './ActionComponent';\r\nexport * from './ActionComposite';\r\nexport * from './LifeState';\r\nexport * from './CoreActions';\r\n\r\nexport * from './NullAction';\r\nexport * from './BindProviderAction'\r\nexport * from './BindParameterTypeAction';\r\nexport * from './BindPropertyTypeAction';\r\nexport * from './InjectPropertyAction';\r\nexport * from './BindParameterProviderAction';\r\nexport * from './ComponentBeforeInitAction';\r\nexport * from './ComponentInitAction';\r\nexport * from './ComponentAfterInitAction';\r\nexport * from './CacheAction';\r\nexport * from './SingletonAction';\r\nexport * from './AutorunAction';\r\n\r\n","import { MapSet, isToken, isNumber, isFunction, isUndefined } from '../../utils';\r\nimport { Token, Factory, Providers, ToInstance, Express2 } from '../../types';\r\nimport { IContainer } from '../../IContainer';\r\nimport { InjectToken } from '../../InjectToken';\r\n\r\nexport const ProviderMapToken = new InjectToken<ProviderMap>('DI_ProviderMap');\r\n\r\n/**\r\n * Provider Map\r\n *\r\n * @export\r\n * @class Providers\r\n */\r\nexport class ProviderMap {\r\n    private maps: MapSet<Token<any> | number, Factory<any>>;\r\n    constructor(private container: IContainer) {\r\n        this.maps = new MapSet<Token<any> | number, Factory<any>>();\r\n    }\r\n\r\n    has(provide: Token<any> | number): boolean {\r\n        return this.maps.has(provide);\r\n    }\r\n\r\n    get<T>(provide: Token<T> | number): Token<T> | Factory<T> {\r\n        return this.maps.get(provide);\r\n    }\r\n\r\n    add<T>(provide: Token<T> | number, provider: Token<T> | Factory<T>): this {\r\n        if (isUndefined(provide)) {\r\n            return this;\r\n        }\r\n        let factory;\r\n        if (isToken(provider) && this.container.has(provider)) {\r\n            factory = (...providers: Providers[]) => {\r\n                return this.container.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = (...providers: Providers[]) => {\r\n                    return (<ToInstance<any>>provider)(this.container, ...providers);\r\n                };\r\n            } else {\r\n                factory = () => {\r\n                    return provider;\r\n                };\r\n            }\r\n        }\r\n        this.maps.set(provide, factory);\r\n        return this;\r\n    }\r\n\r\n    remove<T>(provide: Token<T> | number): this {\r\n        if (this.maps.has(provide)) {\r\n            this.maps.delete(provide);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    resolve<T>(provide: Token<T> | number, ...providers: Providers[]): T {\r\n        if (!this.maps.has(provide)) {\r\n            return (!isNumber(provide) && this.container.has(provide)) ? this.container.resolve(provide, ...providers) : null;\r\n        }\r\n\r\n        let provider = this.maps.get(provide);\r\n        return isToken(provider) ? this.container.resolve(provider, ...providers) : provider(...providers);\r\n    }\r\n\r\n    forEach(express: Express2<Factory<any>, Token<any> | number, void | boolean>) {\r\n        this.maps.forEach(express);\r\n    }\r\n\r\n    copy(map: ProviderMap) {\r\n        if (!map) {\r\n            return;\r\n        }\r\n        map.forEach((val, token) => {\r\n            this.maps.set(token, val);\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ProviderMap\",\"params\":{\"constructor\":[\"container\"],\"has\":[\"provide\"],\"get\":[\"provide\"],\"add\":[\"provide\",\"provider\"],\"remove\":[\"provide\"],\"resolve\":[\"provide\",\"providers\"],\"forEach\":[\"express\"],\"copy\":[\"map\"]}};\n                   }\r\n","import { Token, Providers, Express2, Type } from '../../types';\r\nimport { IContainer } from '../../IContainer';\r\nimport { isFunction, isObject, isUndefined } from '../../utils';\r\n\r\n\r\nexport interface TypeProvider extends Type<any> {\r\n\r\n}\r\n\r\nexport interface IProvider {\r\n    /**\r\n     * this type provider to.\r\n     *\r\n     * @type {SymbolType<any>}\r\n     * @memberof Provider\r\n     */\r\n    provide: Token<any>;\r\n}\r\n\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * @Injectable()\r\n * class MyService {}\r\n *\r\n * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return an instance of `useClass` for a token.\r\n *\r\n */\r\nexport interface ClassProvider extends IProvider {\r\n\r\n    useClass: Type<any>;\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\nexport interface ValueProvider extends IProvider {\r\n    useValue: any;\r\n}\r\n\r\n/**\r\n * @usageNotes\r\n * ```\r\n * function serviceFactory() { ... }\r\n *\r\n * const provider: FactoryProvider = {provide: 'someToken', useFactory: serviceFactory, deps: []};\r\n * ```\r\n *\r\n * @description\r\n * Configures the `Injector` to return a value by invoking a `useFactory` function.\r\n *\r\n *\r\n */\r\nexport interface FactoryProvider extends IProvider {\r\n    /**\r\n   * A function to invoke to create a value for this `token`. The function is invoked with\r\n   * resolved values of `token`s in the `deps` field.\r\n   */\r\n    useFactory: Function;\r\n\r\n    /**\r\n     * A list of `token`s which need to be resolved by the injector. The list of values is then\r\n     * used as arguments to the `useFactory` function.\r\n     */\r\n    deps?: any[];\r\n}\r\n\r\nexport interface ExistingProvider extends IProvider {\r\n    useExisting: Token<any>\r\n}\r\n\r\nexport type ProviderType =\r\n    TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | Provider;\r\n\r\n\r\n/**\r\n *  provider, to dynamic resovle instance of params in run time.\r\n *\r\n * @export\r\n * @class Provider\r\n */\r\nexport class Provider {\r\n    /**\r\n     * service provider is value or value factory.\r\n     *\r\n     * @memberof Provider\r\n     */\r\n    protected value?: any\r\n    /**\r\n     * service is instance of type.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof Provider\r\n     */\r\n    type?: Token<any>;\r\n\r\n    constructor(type?: Token<any>, value?: any) {\r\n        this.type = type;\r\n        this.value = value;\r\n    }\r\n\r\n    /**\r\n     * resolve provider value.\r\n     *\r\n     * @template T\r\n     * @param {IContainer} container\r\n     * @param {Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof Provider\r\n     */\r\n    resolve<T>(container: IContainer, ...providers: Providers[]): T {\r\n        if (isUndefined(this.value)) {\r\n            return container.has(this.type) ? container.resolve(this.type, ...providers) : null;\r\n        } else {\r\n            return this.value; // isFunction(this.value) ? this.value(container) : this.value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * create provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} type\r\n     * @param {(any)} value\r\n     * @returns Provider\r\n     * @memberof Provider\r\n     */\r\n    static create(type: Token<any>, value: any): Provider {\r\n        return new Provider(type, value);\r\n    }\r\n\r\n    /**\r\n     * create extends provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {Express2<any, ExtendsProvider, void>} [extendsTarget]\r\n     * @returns {ExtendsProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createExtends(token: Token<any>, value: any, extendsTarget?: Express2<any, ExtendsProvider, void>): ExtendsProvider {\r\n        return new ExtendsProvider(token, value, extendsTarget);\r\n    }\r\n\r\n    // /**\r\n    //  * create custom provider.\r\n    //  *\r\n    //  * @static\r\n    //  * @param {Token<any>} [type]\r\n    //  * @param {ToInstance<any>} [toInstance]\r\n    //  * @param {*} [value]\r\n    //  * @returns {CustomProvider}\r\n    //  * @memberof Provider\r\n    //  */\r\n    // static createCustom(type?: Token<any>, toInstance?: ToInstance<any>, value?: any): CustomProvider {\r\n    //     return new CustomProvider(type, toInstance, value);\r\n    // }\r\n\r\n    /**\r\n     * create invoked provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {string} method\r\n     * @param {(any)} [value]\r\n     * @returns {InvokeProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createInvoke(token: Token<any>, method: string, value?: any): InvokeProvider {\r\n        return new InvokeProvider(token, method, value);\r\n    }\r\n\r\n    /**\r\n     * create param provider.\r\n     *\r\n     * @static\r\n     * @param {Token<any>} token\r\n     * @param {(any)} value\r\n     * @param {number} [index]\r\n     * @param {string} [method]\r\n     * @returns {ParamProvider}\r\n     * @memberof Provider\r\n     */\r\n    static createParam(token: Token<any>, value: any, index?: number, method?: string): ParamProvider {\r\n        return new ParamProvider(token, value, index, method);\r\n    }\r\n\r\n    // /**\r\n    //  * create async param provider.\r\n    //  *\r\n    //  * @static\r\n    //  * @param {(string | string[])} files\r\n    //  * @param {Token<any>} token\r\n    //  * @param {number} [index]\r\n    //  * @param {string} [method]\r\n    //  * @param {(any)} [value]\r\n    //  * @returns {AsyncParamProvider}\r\n    //  * @memberof Provider\r\n    //  */\r\n    // static createAsyncParam(files: string | string[], token: Token<any>, index?: number, method?: string, value?: any): AsyncParamProvider {\r\n    //     return new AsyncParamProvider(files, token, index, method, value)\r\n    // }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"Provider\",\"params\":{\"constructor\":[\"type\",\"value\"],\"resolve\":[\"container\",\"providers\"],\"create\":[\"type\",\"value\"],\"createExtends\":[\"token\",\"value\",\"extendsTarget\"],\"createInvoke\":[\"token\",\"method\",\"value\"],\"createParam\":[\"token\",\"value\",\"index\",\"method\"]}};\n                   }\r\n\r\n/**\r\n * InvokeProvider\r\n *\r\n * @export\r\n * @class InvokeProvider\r\n * @extends {Provider}\r\n */\r\nexport class InvokeProvider extends Provider {\r\n    /**\r\n     * service value is the result of type instance invoke the method return value.\r\n     *\r\n     * @type {string}\r\n     * @memberof Provider\r\n     */\r\n    protected method?: string;\r\n\r\n    constructor(type?: Token<any>, method?: string, value?: any) {\r\n        super(type, value);\r\n        this.method = method;\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: Providers[]): T {\r\n        if (this.method) {\r\n            return container.syncInvoke<T>(this.type, this.method, ...providers);\r\n        }\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InvokeProvider\",\"params\":{\"constructor\":[\"type\",\"method\",\"value\"],\"resolve\":[\"container\",\"providers\"]}};\n                   }\r\n\r\n\r\n/**\r\n * param provider.\r\n *\r\n * @export\r\n * @interface ParamProvider\r\n */\r\nexport class ParamProvider extends InvokeProvider {\r\n    /**\r\n     * param index, param name.\r\n     *\r\n     * @type {number}\r\n     * @memberof ParamProvider\r\n     */\r\n    index?: number;\r\n\r\n    constructor(token?: Token<any>, value?: any, index?: number, method?: string) {\r\n        super(token, method, value);\r\n        this.index = index;\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: Providers[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ParamProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"index\",\"method\"],\"resolve\":[\"container\",\"providers\"]}};\n                   }\r\n\r\n/**\r\n * Provider enable exntends target with provider in dynamic.\r\n *\r\n * @export\r\n * @class ExtendsProvider\r\n * @extends {Provider}\r\n */\r\nexport class ExtendsProvider extends Provider {\r\n\r\n\r\n    constructor(token: Token<any>, value?: any, private extendsTarget?: Express2<any, ExtendsProvider, void>) {\r\n        super(token, value);\r\n    }\r\n\r\n    resolve<T>(container: IContainer, ...providers: Providers[]): T {\r\n        return super.resolve(container, ...providers);\r\n    }\r\n\r\n    extends(target: any) {\r\n        if (isObject(target) && isFunction(this.extendsTarget)) {\r\n            this.extendsTarget(target, this);\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ExtendsProvider\",\"params\":{\"constructor\":[\"token\",\"value\",\"extendsTarget\"],\"resolve\":[\"container\",\"providers\"],\"extends\":[\"target\"]}};\n                   }\r\n","import { isObject } from '../../utils';\r\nimport { ProviderMap } from './ProviderMap';\r\n\r\nexport * from './Provider';\r\n// export * from './ExtendsProvider';\r\nexport * from './ProviderMap';\r\n// export * from './InvokeProvider';\r\n// export * from './ParamProvider';\r\n// export * from './AsyncParamProvider';\r\n\r\n\r\n/**\r\n * object is provider map or not.\r\n *\r\n * @export\r\n * @param {object} target\r\n * @returns {target is ProviderMap}\r\n */\r\nexport function isProviderMap(target: object): target is ProviderMap {\r\n    if (!isObject(target)) {\r\n        return false;\r\n    }\r\n    return target instanceof ProviderMap;\r\n}\r\n","import { InjectToken } from '../InjectToken';\r\n/**\r\n * IRecognizer interface token.\r\n * it is a token id, you can register yourself IRecognizer for this.\r\n */\r\nexport const RecognizerToken = new InjectToken<IRecognizer>('DI_IRecognizer');\r\n\r\n/**\r\n * recognize the vaule is special alias for registor to container.\r\n *\r\n * @export\r\n * @interface IRecognizer\r\n */\r\nexport interface IRecognizer {\r\n\r\n    /**\r\n     * recognize the special alias of value.\r\n     *\r\n     * @param {*} value\r\n     * @returns {string}\r\n     * @memberof IRecognizer\r\n     */\r\n    recognize(value: any): string;\r\n}\r\n","import { IParameter } from '../IParameter';\r\nimport { Providers } from '../types';\r\nimport { ProviderMap } from './providers';\r\nimport { InjectToken } from '../InjectToken';\r\n\r\n/**\r\n * Providers match interface symbol.\r\n * it is a symbol id, you can register yourself MethodAccessor for this.\r\n */\r\nexport const ProviderMatcherToken = new InjectToken<IProviderMatcher>('DI_IProviderMatcher');\r\n\r\n/**\r\n * Providers Convert\r\n *\r\n * @export\r\n * @interface IProviderMatcher\r\n */\r\nexport interface IProviderMatcher {\r\n\r\n    /**\r\n     * convert to provider map.\r\n     *\r\n     * @param {...Providers[]} providers\r\n     * @returns {ProviderMap}\r\n     * @memberof IProviderMatcher\r\n     */\r\n    toProviderMap(...providers: Providers[]): ProviderMap;\r\n\r\n    /**\r\n     * math params providers.\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {ProviderMap} providerMap\r\n     * @returns {ProviderMap}\r\n     * @memberof IProviderMatcher\r\n     */\r\n    match(params: IParameter[], providerMap: ProviderMap): ProviderMap;\r\n\r\n    /**\r\n     * math params providers.\r\n     *\r\n     * @param {IParameter[]} params\r\n     * @param {...Providers[]} providers\r\n     * @returns {ProviderMap}\r\n     * @memberof IProviderMatcher\r\n     */\r\n    matchProviders(params: IParameter[], ...providers: Providers[]): ProviderMap;\r\n}\r\n","import { ActionData } from '../ActionData';\r\nimport { AutorunMetadata } from '../metadatas';\r\nimport { ActionComposite } from './ActionComposite';\r\nimport { IContainer } from '../../IContainer';\r\nimport { lang, isNumber } from '../../utils';\r\nimport { CoreActions } from './CoreActions';\r\nimport { hasMethodMetadata, getMethodMetadata } from '../factories';\r\nimport { Autorun } from '../decorators';\r\n\r\n\r\n\r\n/**\r\n * auto run action data.\r\n *\r\n * @export\r\n * @interface AutorunActionData\r\n * @extends {ActionData<AutorunMetadata>}\r\n */\r\nexport interface MethodAutorunActionData extends ActionData<AutorunMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * Inject DrawType action.\r\n *\r\n * @export\r\n * @class SetPropAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class MethodAutorun extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(CoreActions.methodAutorun)\r\n    }\r\n\r\n\r\n    protected working(container: IContainer, data: MethodAutorunActionData) {\r\n        if (data.raiseContainer && data.raiseContainer !== container) {\r\n            return;\r\n        }\r\n        if (data.target && data.targetType) {\r\n            if (hasMethodMetadata(Autorun, data.targetType)) {\r\n                let metas = getMethodMetadata<AutorunMetadata>(Autorun, data.targetType);\r\n                let lastmetas: AutorunMetadata[] = [];\r\n                let idx = lang.keys(metas).length;\r\n                lang.forIn(metas, (mm, key: string) => {\r\n                    if (mm && mm.length) {\r\n                        let m = mm[0];\r\n                        m.autorun = key;\r\n                        idx++;\r\n                        if (!isNumber(m.order)) {\r\n                            m.order = idx;\r\n                        }\r\n                        lastmetas.push(m);\r\n                    }\r\n                });\r\n\r\n                lastmetas.sort((au1, au2) => {\r\n                    return au1.order - au1.order;\r\n                }).forEach(aut => {\r\n                    container.syncInvoke(data.targetType, aut.autorun, data.target);\r\n                });\r\n            }\r\n\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"MethodAutorun\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n\r\n","import {\r\n    ActionComponent, ActionComposite,\r\n    CoreActions, BindParameterTypeAction,\r\n    BindPropertyTypeAction, InjectPropertyAction,\r\n    BindParameterProviderAction, BindProviderAction,\r\n    ComponentInitAction, ComponentBeforeInitAction, ComponentAfterInitAction,\r\n    CacheAction, SingletionAction, AutorunAction\r\n} from './actions';\r\nimport { MethodAutorun } from './actions/MethodAutorun';\r\n\r\n\r\n/**\r\n * action factory.\r\n *\r\n * @export\r\n * @class ActionFactory\r\n */\r\nexport class ActionFactory {\r\n\r\n    /**\r\n     * create action by action type. type in 'CoreActions'\r\n     *\r\n     * @param {string} type\r\n     * @returns {ActionComponent}\r\n     * @memberof ActionFactory\r\n     */\r\n    create(type: string): ActionComponent {\r\n        let action: ActionComponent;\r\n        switch (type) {\r\n            case CoreActions.bindParameterType:\r\n                action = new BindParameterTypeAction();\r\n                break;\r\n\r\n            case CoreActions.bindPropertyType:\r\n                action = new BindPropertyTypeAction();\r\n                break;\r\n\r\n            case CoreActions.injectProperty:\r\n                action = new InjectPropertyAction();\r\n                break;\r\n\r\n            case CoreActions.bindProvider:\r\n                action = new BindProviderAction();\r\n                break;\r\n\r\n            case CoreActions.bindParameterProviders:\r\n                action = new BindParameterProviderAction();\r\n                break;\r\n\r\n            case CoreActions.componentInit:\r\n                action = new ComponentInitAction();\r\n                break;\r\n\r\n            case CoreActions.componentBeforeInit:\r\n                action = new ComponentBeforeInitAction();\r\n                break;\r\n\r\n            case CoreActions.componentAfterInit:\r\n                action = new ComponentAfterInitAction();\r\n                break;\r\n\r\n            case CoreActions.cache:\r\n                action = new CacheAction();\r\n                break;\r\n\r\n            case CoreActions.singletion:\r\n                action = new SingletionAction();\r\n                break;\r\n\r\n            case CoreActions.autorun:\r\n                action = new AutorunAction();\r\n                break;\r\n            case CoreActions.methodAutorun:\r\n                action = new MethodAutorun();\r\n                break;\r\n            default:\r\n                action = new ActionComposite(type);\r\n                break;\r\n\r\n        }\r\n\r\n        return action;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ActionFactory\",\"params\":{\"create\":[\"type\"]}};\n                   }\r\n","import { LifeScope, DecorSummary } from '../LifeScope';\r\nimport { Type, ObjectMap, Token, IocState, Express } from '../types';\r\nimport { isClass, isAbstractDecoratorClass, isArray, lang } from '../utils';\r\nimport { Singleton } from './decorators';\r\nimport { ClassMetadata, MethodMetadata } from './metadatas';\r\nimport { IContainer } from '../IContainer';\r\nimport { CoreActions, ActionComponent, LifeState } from './actions';\r\nimport { DecoratorType, getOwnTypeMetadata, getOwnParamerterNames, getOwnMethodMetadata, hasOwnClassMetadata } from './factories';\r\nimport { ActionData } from './ActionData';\r\nimport { ActionFactory } from './ActionFactory';\r\nimport { IParameter } from '../IParameter';\r\n\r\n\r\n/**\r\n * default implement life scope.\r\n *\r\n * @export\r\n * @class DefaultLifeScope\r\n * @implements {LifeScope}\r\n */\r\nexport class DefaultLifeScope implements LifeScope {\r\n\r\n    decorators: DecorSummary[];\r\n    action: ActionComponent;\r\n    constructor(private container: IContainer) {\r\n        this.decorators = [];\r\n        this.buildAction();\r\n    }\r\n\r\n\r\n    addAction(action: ActionComponent, ...nodepaths: string[]): this {\r\n        let parent = this.action;\r\n        nodepaths.forEach(pathname => {\r\n            parent = parent.find(act => act.name === pathname);\r\n        });\r\n        if (parent) {\r\n            parent.add(action);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    registerDecorator(decorator: Function, ...actions: string[]): this {\r\n        let type = this.getDecoratorType(decorator);\r\n        return this.registerCustomDecorator(decorator, type, ...actions);\r\n    }\r\n\r\n    registerCustomDecorator(decorator: Function, type: DecoratorType, ...actions: string[]): this {\r\n        let types = this.toActionName(type);\r\n        let name = decorator.toString();\r\n        if (!this.decorators.some(d => d.name === name)) {\r\n            this.decorators.push({\r\n                name: name,\r\n                types: types,\r\n                actions: actions\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    execute<T>(data: ActionData<T>, ...names: string[]) {\r\n        names = names.filter(n => !!n);\r\n        let act: ActionComponent = this.action;\r\n        names.forEach(name => {\r\n            act = act.find(itm => itm.name === name);\r\n        });\r\n        if (act) {\r\n            act.execute(this.container, data);\r\n        }\r\n    }\r\n\r\n    routeExecute<T>(data: ActionData<T>, ...names: string[]) {\r\n        this.execute(data, ...names);\r\n        let container = this.container.parent;\r\n        while (container) {\r\n            container.getLifeScope().execute(lang.assign({}, data), ...names);\r\n            container = container.parent;\r\n        }\r\n    }\r\n\r\n    getClassDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.getTypeDecorators(this.toActionName(DecoratorType.Class), match);\r\n    }\r\n\r\n    getMethodDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.getTypeDecorators(this.toActionName(DecoratorType.Method), match);\r\n    }\r\n\r\n    getPropertyDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.getTypeDecorators(this.toActionName(DecoratorType.Property), match);\r\n    }\r\n\r\n    getParameterDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.getTypeDecorators(this.toActionName(DecoratorType.Parameter), match);\r\n    }\r\n\r\n    getDecoratorType(decirator: any): DecoratorType {\r\n        return decirator.decoratorType || DecoratorType.All;\r\n    }\r\n\r\n    /**\r\n     * is vaildate dependence type or not. dependence type must with class decorator.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} target\r\n     * @returns {boolean}\r\n     * @memberof Container\r\n     */\r\n    isVaildDependence<T>(target: Type<T>): boolean {\r\n        if (!target) {\r\n            return false;\r\n        }\r\n        if (!isClass(target)) {\r\n            return false;\r\n        }\r\n\r\n        if (isAbstractDecoratorClass(target)) {\r\n            return false;\r\n        }\r\n        return this.getClassDecorators().some(act => hasOwnClassMetadata(act.name, target));\r\n\r\n    }\r\n\r\n    getAtionByName(name: string): ActionComponent {\r\n        return this.action.find(action => action.name === name) as ActionComponent;\r\n    }\r\n\r\n    getClassAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Class));\r\n    }\r\n    getMethodAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Method));\r\n    }\r\n\r\n    getPropertyAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Property));\r\n    }\r\n    getParameterAction(): ActionComponent {\r\n        return this.getAtionByName(this.toActionName(DecoratorType.Parameter));\r\n    }\r\n\r\n    /**\r\n     * get constructor parameters metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getConstructorParameters<T>(type: Type<T>): IParameter[] {\r\n        return this.getParameters(type);\r\n    }\r\n\r\n    /**\r\n     * get method params metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {T} instance\r\n     * @param {(string | symbol)} propertyKey\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getMethodParameters<T>(type: Type<T>, instance: T, propertyKey: string): IParameter[] {\r\n        return this.getParameters(type, instance, propertyKey);\r\n    }\r\n\r\n    /**\r\n     * get paramerter names.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {string} propertyKey\r\n     * @returns {string[]}\r\n     * @memberof DefaultLifeScope\r\n     */\r\n    getParamerterNames<T>(type: Type<T>, propertyKey: string): string[] {\r\n        let metadata = getOwnParamerterNames(type);\r\n        let paramNames = [];\r\n        if (metadata && metadata.hasOwnProperty(propertyKey)) {\r\n            paramNames = metadata[propertyKey]\r\n        }\r\n        if (!isArray(paramNames)) {\r\n            paramNames = [];\r\n        }\r\n        return paramNames;\r\n    }\r\n\r\n    isSingletonType<T>(type: Type<T>): boolean {\r\n        if (hasOwnClassMetadata(Singleton, type)) {\r\n            return true;\r\n        }\r\n\r\n        return this.getClassDecorators().some(surm => {\r\n            let metadatas = getOwnTypeMetadata(surm.name, type) as ClassMetadata[] || [];\r\n            if (isArray(metadatas)) {\r\n                return metadatas.some(m => m.singleton === true);\r\n            }\r\n            return false;\r\n        })\r\n    }\r\n\r\n    getMethodMetadatas<T>(type: Type<T>, propertyKey: string): MethodMetadata[] {\r\n        let metadatas = [];\r\n        this.getMethodDecorators().forEach(dec => {\r\n            let metas: ObjectMap<MethodMetadata[]> = getOwnMethodMetadata<MethodMetadata>(dec.name, type);\r\n            if (metas.hasOwnProperty(propertyKey)) {\r\n                metadatas = metadatas.concat(metas[propertyKey] || []);\r\n            }\r\n        });\r\n        return metadatas;\r\n    }\r\n\r\n\r\n\r\n    filerDecorators(express?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.decorators.filter(express);\r\n    }\r\n\r\n    protected getParameters<T>(type: Type<T>, instance?: T, propertyKey?: string): IParameter[] {\r\n        propertyKey = propertyKey || 'constructor';\r\n        let data = {\r\n            target: instance,\r\n            targetType: type,\r\n            propertyKey: propertyKey\r\n        } as ActionData<Token<any>[]>;\r\n        this.execute(data, LifeState.onInit, CoreActions.bindParameterType);\r\n\r\n        let paramNames = this.getParamerterNames(type, propertyKey);\r\n\r\n        if (data.execResult.length) {\r\n            return data.execResult.map((typ, idx) => {\r\n                return {\r\n                    type: typ,\r\n                    name: paramNames[idx]\r\n                }\r\n            });\r\n        } else {\r\n            return paramNames.map(name => {\r\n                return {\r\n                    name: name,\r\n                    type: undefined\r\n                }\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    protected getTypeDecorators(decType: string, match?: Express<DecorSummary, boolean>): DecorSummary[] {\r\n        return this.filerDecorators(value => {\r\n            let flag = (value.types || '').indexOf(decType) >= 0;\r\n            if (flag && match) {\r\n                flag = match(value);\r\n            }\r\n            return flag;\r\n        });\r\n    }\r\n\r\n    protected buildAction() {\r\n        let factory = new ActionFactory();\r\n\r\n        let action = factory.create('');\r\n        action\r\n            .add(factory.create(IocState.design)\r\n                .add(factory.create(CoreActions.bindProvider))\r\n                .add(factory.create(CoreActions.autorun))\r\n            )\r\n            .add(factory.create(IocState.runtime)\r\n                .add(factory.create(LifeState.beforeCreateArgs))\r\n                .add(factory.create(LifeState.beforeConstructor))\r\n                .add(factory.create(LifeState.afterConstructor))\r\n                .add(factory.create(LifeState.onInit)\r\n                    .add(factory.create(CoreActions.componentBeforeInit))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Class)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Method)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Property))\r\n                        .add(factory.create(CoreActions.bindPropertyType))\r\n                        .add(factory.create(CoreActions.injectProperty)))\r\n                    .add(factory.create(this.toActionName(DecoratorType.Parameter))\r\n                        .add(factory.create(CoreActions.bindParameterType))\r\n                        .add(factory.create(CoreActions.bindParameterProviders)))\r\n                    .add(factory.create(CoreActions.componentInit))\r\n                )\r\n                .add(factory.create(LifeState.AfterInit)\r\n                    .add(factory.create(CoreActions.singletion))\r\n                    .add(factory.create(CoreActions.componentAfterInit))\r\n                    .add(factory.create(CoreActions.methodAutorun)))\r\n            )\r\n            .add(factory.create(CoreActions.cache));\r\n\r\n        this.action = action;\r\n    }\r\n\r\n\r\n    toActionName(type: DecoratorType): string {\r\n        let types = [];\r\n        if (type & DecoratorType.Class) {\r\n            types.push('ClassDecorator');\r\n        }\r\n        if (type & DecoratorType.Method) {\r\n            types.push('MethodDecorator');\r\n        }\r\n        if (type & DecoratorType.Property) {\r\n            types.push('PropertyDecorator');\r\n        }\r\n        if (type & DecoratorType.Parameter) {\r\n            types.push('ParameterDecorator');\r\n        }\r\n\r\n        return types.join(',');\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"DefaultLifeScope\",\"params\":{\"constructor\":[\"container\"],\"addAction\":[\"action\",\"nodepaths\"],\"registerDecorator\":[\"decorator\",\"actions\"],\"registerCustomDecorator\":[\"decorator\",\"type\",\"actions\"],\"execute\":[\"data\",\"names\"],\"routeExecute\":[\"data\",\"names\"],\"getClassDecorators\":[\"match\"],\"getMethodDecorators\":[\"match\"],\"getPropertyDecorators\":[\"match\"],\"getParameterDecorators\":[\"match\"],\"getDecoratorType\":[\"decirator\"],\"isVaildDependence\":[\"target\"],\"getAtionByName\":[\"name\"],\"getClassAction\":[],\"getMethodAction\":[],\"getPropertyAction\":[],\"getParameterAction\":[],\"getConstructorParameters\":[\"type\"],\"getMethodParameters\":[\"type\",\"instance\",\"propertyKey\"],\"getParamerterNames\":[\"type\",\"propertyKey\"],\"isSingletonType\":[\"type\"],\"getMethodMetadatas\":[\"type\",\"propertyKey\"],\"filerDecorators\":[\"express\"],\"getParameters\":[\"type\",\"instance\",\"propertyKey\"],\"getTypeDecorators\":[\"decType\",\"match\"],\"buildAction\":[],\"toActionName\":[\"type\"]}};\n                   }\r\n","import { Providers } from '../types';\r\nimport { Provider, ProviderMap, ParamProvider, isProviderMap, ProviderMapToken } from './providers';\r\nimport { isString, isClass, isArray, isFunction, isNumber, isUndefined, isNull, isToken, isBaseObject, lang } from '../utils';\r\nimport { IParameter } from '../IParameter';\r\nimport { IProviderMatcher } from './IProviderMatcher';\r\nimport { IContainer } from '../IContainer';\r\n\r\n/**\r\n * provider matcher. use to find custome providers in resolve.\r\n *\r\n * @export\r\n * @class ProviderMatcher\r\n * @implements {IProviderMatcher}\r\n */\r\nexport class ProviderMatcher implements IProviderMatcher {\r\n\r\n    constructor(private container: IContainer) {\r\n\r\n    }\r\n\r\n    toProviderMap(...providers: Providers[]): ProviderMap {\r\n        if (providers.length === 1 && isProviderMap(providers[0])) {\r\n            return providers[0] as ProviderMap;\r\n        }\r\n        let map = this.container.resolve(ProviderMapToken);\r\n        providers.forEach((p, index) => {\r\n            if (isUndefined(p) || isNull(p)) {\r\n                return;\r\n            }\r\n            if (isProviderMap(p)) {\r\n                map.copy(p);\r\n            } else if (p instanceof Provider) {\r\n                if (p instanceof ParamProvider) {\r\n                    if (!p.type && isNumber(p.index)) {\r\n                        map.add(p.index, (...providers: Providers[]) => p.resolve(this.container, ...providers));\r\n                    } else {\r\n                        map.add(p.type, (...providers: Providers[]) => p.resolve(this.container, ...providers));\r\n                    }\r\n\r\n                } else {\r\n                    map.add(p.type, (...providers: Providers[]) => p.resolve(this.container, ...providers));\r\n                }\r\n            } else if (isClass(p)) {\r\n                if (!this.container.has(p)) {\r\n                    this.container.register(p);\r\n                }\r\n                map.add(p, p);\r\n            } else if (isBaseObject(p)) {\r\n                let pr: any = p;\r\n                let isobjMap = false;\r\n                if (isToken(pr.provide)) {\r\n                    if (isArray(pr.deps) && pr.deps.length) {\r\n                        pr.deps.forEach(d => {\r\n                            if (isClass(d) && !this.container.has(d)) {\r\n                                this.container.register(d);\r\n                            }\r\n                        });\r\n                    }\r\n                    if (!isUndefined(pr.useValue)) {\r\n                        map.add(pr.provide, () => pr.useValue);\r\n                    } else if (isClass(pr.useClass)) {\r\n                        if (!this.container.has(pr.useClass)) {\r\n                            this.container.register(pr.useClass);\r\n                        }\r\n                        map.add(pr.provide, pr.useClass);\r\n                    } else if (isFunction(pr.useFactory)) {\r\n                        map.add(pr.provide, () => {\r\n                            let args = [];\r\n                            if (isArray(pr.deps) && pr.deps.length) {\r\n                                args = pr.deps.map(d => {\r\n                                    if (isClass(d)) {\r\n                                        return this.container.get(d);\r\n                                    } else {\r\n                                        return d;\r\n                                    }\r\n                                });\r\n                            }\r\n                            return pr.useFactory.apply(pr, args);\r\n                        });\r\n                    } else if (isToken(pr.useExisting)) {\r\n                        if (this.container.has(pr.useExisting)) {\r\n                            map.add(pr.provide, () => this.container.resolve(pr.useExisting));\r\n                        } else {\r\n                            console.log('has not register:', pr.useExisting);\r\n                        }\r\n                    } else {\r\n                        isobjMap = true;\r\n                    }\r\n                } else {\r\n                    isobjMap = true;\r\n                }\r\n\r\n                if (isobjMap) {\r\n                    lang.forIn<any>(p, (val, name) => {\r\n                        if (!isUndefined(val)) {\r\n                            if (isClass(val)) {\r\n                                map.add(name, val);\r\n                            } else if (isFunction(val) || isString(val)) {\r\n                                map.add(name, () => val);\r\n                            } else {\r\n                                map.add(name, val);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n\r\n            } else if (isFunction(p)) {\r\n                map.add(name, () => p);\r\n            } else {\r\n                map.add(index, p);\r\n            }\r\n\r\n        });\r\n\r\n        return map;\r\n    }\r\n\r\n    matchProviders(params: IParameter[], ...providers: Providers[]): ProviderMap {\r\n        return this.match(params, this.toProviderMap(...providers));\r\n    }\r\n\r\n    match(params: IParameter[], providers: ProviderMap): ProviderMap {\r\n        let map = this.container.resolve(ProviderMapToken);\r\n        if (!params.length) {\r\n            return map;\r\n        }\r\n        params.forEach((param, index) => {\r\n            if (!param.name) {\r\n                return;\r\n            }\r\n            if (providers.has(param.name)) {\r\n                map.add(param.name, providers.get(param.name));\r\n            } else if (isToken(param.type)) {\r\n                if (providers.has(param.type)) {\r\n                    map.add(param.name, providers.get(param.type));\r\n                } else if (this.container.has(param.type)) {\r\n                    map.add(param.name, param.type);\r\n                }\r\n            } else if (providers.has(index)) {\r\n                map.add(param.name, providers.get(index));\r\n            }\r\n        });\r\n\r\n        return map;\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"ProviderMatcher\",\"params\":{\"constructor\":[\"container\"],\"toProviderMap\":[\"providers\"],\"matchProviders\":[\"params\",\"providers\"],\"match\":[\"params\",\"providers\"]}};\n                   }\r\n","import { IContainer } from '../IContainer';\r\nimport { IMethodAccessor } from '../IMethodAccessor';\r\nimport { BindParameterProviderActionData, CoreActions, LifeState } from './actions';\r\nimport { isToken, isFunction } from '../utils';\r\nimport { Token, Providers } from '../types';\r\nimport { IParameter } from '../IParameter';\r\nimport { IProviderMatcher, ProviderMatcherToken } from './IProviderMatcher';\r\n\r\n/**\r\n * method accessor\r\n *\r\n * @export\r\n * @class MethodAccessor\r\n * @implements {IMethodAccessor}\r\n */\r\nexport class MethodAccessor implements IMethodAccessor {\r\n\r\n    constructor(private container: IContainer) {\r\n\r\n    }\r\n\r\n    getMatcher(): IProviderMatcher {\r\n        return this.container.get(ProviderMatcherToken);\r\n    }\r\n\r\n    async invoke<T>(token: Token<any>, propertyKey: string, target?: any, ...providers: Providers[]): Promise<T> {\r\n        if (!target) {\r\n            target = this.container.resolve(token, ...providers);\r\n        }\r\n\r\n        let targetClass = this.container.getTokenImpl(token);\r\n        if (!targetClass) {\r\n            throw Error(token.toString() + ' is not implements by any class.');\r\n        }\r\n        if (target && isFunction(target[propertyKey])) {\r\n            let actionData = {\r\n                target: target,\r\n                targetType: targetClass,\r\n                propertyKey: propertyKey,\r\n            } as BindParameterProviderActionData;\r\n            let lifeScope = this.container.getLifeScope();\r\n            lifeScope.execute(actionData, LifeState.onInit, CoreActions.bindParameterProviders);\r\n            providers = providers.concat(actionData.execResult);\r\n\r\n            let parameters = lifeScope.getMethodParameters(targetClass, target, propertyKey);\r\n\r\n            let paramInstances = await this.createParams(parameters, ...providers);\r\n\r\n            return target[propertyKey](...paramInstances) as T;\r\n        } else {\r\n            throw new Error(`type: ${targetClass} has no method ${propertyKey.toString()}.`)\r\n        }\r\n    }\r\n\r\n    syncInvoke<T>(token: Token<any>, propertyKey: string, target?: any, ...providers: Providers[]): T {\r\n        if (!target) {\r\n            target = this.container.resolve(token, ...providers);\r\n        }\r\n        let targetClass = this.container.getTokenImpl(token);\r\n        if (!targetClass) {\r\n            throw Error(token.toString() + ' is not implements by any class.')\r\n        }\r\n\r\n        if (target && isFunction(target[propertyKey])) {\r\n            let actionData = {\r\n                target: target,\r\n                targetType: targetClass,\r\n                propertyKey: propertyKey,\r\n            } as BindParameterProviderActionData;\r\n            let lifeScope = this.container.getLifeScope();\r\n            lifeScope.execute(actionData, LifeState.onInit, CoreActions.bindParameterProviders);\r\n\r\n\r\n            providers = providers.concat(actionData.execResult);\r\n            let parameters = lifeScope.getMethodParameters(targetClass, target, propertyKey);\r\n            let paramInstances = this.createSyncParams(parameters, ...providers);\r\n\r\n            return target[propertyKey](...paramInstances) as T;\r\n        } else {\r\n            throw new Error(`type: ${targetClass} has no method ${propertyKey.toString()}.`)\r\n        }\r\n    }\r\n\r\n    createSyncParams(params: IParameter[], ...providers: Providers[]): any[] {\r\n        let providerMap = this.getMatcher().matchProviders(params, ...providers);\r\n        return params.map((param, index) => {\r\n            if (param.name && providerMap.has(param.name)) {\r\n                return providerMap.resolve(param.name);\r\n            } else if (isToken(param.type)) {\r\n                return this.container.resolve(param.type, ...providers);\r\n            } else {\r\n                return undefined;\r\n            }\r\n        });\r\n    }\r\n\r\n    createParams(params: IParameter[], ...providers: Providers[]): Promise<any[]> {\r\n        let providerMap = this.getMatcher().matchProviders(params, ...providers);\r\n        return Promise.all(params.map((param, index) => {\r\n            if (param.name && providerMap.has(param.name)) {\r\n                return providerMap.resolve(param.name);\r\n            } else if (isToken(param.type)) {\r\n                return this.container.resolve(param.type, ...providers);\r\n            } else {\r\n                return undefined;\r\n            }\r\n        }));\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"MethodAccessor\",\"params\":{\"constructor\":[\"container\"],\"getMatcher\":[],\"invoke\":[\"token\",\"propertyKey\",\"target\",\"providers\"],\"syncInvoke\":[\"token\",\"propertyKey\",\"target\",\"providers\"],\"createSyncParams\":[\"params\",\"providers\"],\"createParams\":[\"params\",\"providers\"]}};\n                   }\r\n","import { isFunction, isNumber, MapSet } from '../utils';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { OnDestroy } from './ComponentLifecycle';\r\nimport { ICacheManager } from '../ICacheManager';\r\n\r\n/**\r\n * cache target.\r\n *\r\n * @export\r\n * @interface CacheTarget\r\n */\r\nexport interface CacheTarget {\r\n    target: any;\r\n    expires: number;\r\n}\r\n\r\n/**\r\n * cache manager.\r\n *\r\n * @export\r\n * @class CacheManager\r\n * @implements {ICacheManager}\r\n */\r\nexport class CacheManager implements ICacheManager {\r\n    cacheTokens: MapSet<Type<any>, CacheTarget>;\r\n    constructor(private container: IContainer) {\r\n        this.cacheTokens = new MapSet();\r\n    }\r\n\r\n    isChecking() {\r\n        return !!this.timeout;\r\n    }\r\n\r\n    hasCache(targetType: Type<any>) {\r\n        return this.cacheTokens.has(targetType);\r\n    }\r\n\r\n    cache(targetType: Type<any>, target: any, expires: number) {\r\n        let cache: CacheTarget;\r\n        if (this.hasCache(targetType)) {\r\n            cache = this.cacheTokens.get(targetType)\r\n            cache.expires = Date.now() + expires;\r\n        } else {\r\n            cache = {\r\n                target: target,\r\n                expires: Date.now() + expires\r\n            }\r\n        }\r\n        this.cacheTokens.set(targetType, cache);\r\n        if (!this.isChecking()) {\r\n            this.checkExpires();\r\n        }\r\n    }\r\n\r\n    get(targetType: Type<any>, expires?: number) {\r\n        let result = null;\r\n        if (!this.cacheTokens.has(targetType)) {\r\n            return null;\r\n        }\r\n        let cache = this.cacheTokens.get(targetType);\r\n        if (cache.expires <= Date.now()) {\r\n            result = cache.target;\r\n            if (isNumber(expires) && expires > 0) {\r\n                cache.expires = Date.now() + expires;\r\n                this.cacheTokens.set(targetType, cache);\r\n            }\r\n        } else {\r\n            this.destroy(targetType, cache.target);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private timeout;\r\n    checkExpires() {\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n            this.timeout = 0;\r\n        }\r\n        if (this.cacheTokens.size > 0) {\r\n            let timeoutCaches = [];\r\n            this.cacheTokens.forEach((cache, targetType) => {\r\n                if (cache.expires >= Date.now()) {\r\n                    timeoutCaches.push(targetType);\r\n                }\r\n            });\r\n\r\n            if (timeoutCaches.length) {\r\n                timeoutCaches.forEach(targetType => {\r\n                    this.destroy(targetType, this.cacheTokens.get(targetType).target);\r\n                });\r\n            }\r\n\r\n            this.timeout = setTimeout(() => {\r\n                this.checkExpires();\r\n            }, 60000);\r\n        }\r\n    }\r\n\r\n    destroy(targetType: Type<any>, target?: any) {\r\n\r\n        if (!this.hasCache(targetType)) {\r\n            return;\r\n        }\r\n        if (!target) {\r\n            target = this.cacheTokens.get(targetType).target;\r\n        }\r\n\r\n        try {\r\n            let component = target as OnDestroy;\r\n            if (isFunction(component.onDestroy)) {\r\n                this.container.syncInvoke(targetType, 'onDestroy', target);\r\n            }\r\n            this.cacheTokens.delete(targetType);\r\n        } catch (err) {\r\n            console.error && console.error(err);\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"CacheManager\",\"params\":{\"constructor\":[\"container\"],\"isChecking\":[],\"hasCache\":[\"targetType\"],\"cache\":[\"targetType\",\"target\",\"expires\"],\"get\":[\"targetType\",\"expires\"],\"checkExpires\":[],\"destroy\":[\"targetType\",\"target\"]}};\n                   }\r\n","\r\nexport * from './actions';\r\nexport * from './decorators';\r\nexport * from './metadatas';\r\nexport * from './factories';\r\nexport * from './providers';\r\n\r\nexport * from './IRecognizer';\r\nexport * from './IProviderMatcher';\r\nexport * from './ActionData';\r\nexport * from './ActionFactory';\r\nexport * from './DefaultLifeScope';\r\nexport * from './IExecutable';\r\nexport * from './ProviderMatcher';\r\nexport * from './MethodAccessor';\r\nexport * from './ComponentLifecycle';\r\nexport * from './CacheManager';\r\n","import { MethodMetadata, ActionComponent, ActionData, DecoratorType } from './core';\r\nimport { Type, Express } from './types';\r\nimport { IParameter } from './IParameter';\r\nimport { InjectToken } from './InjectToken';\r\n\r\n/**\r\n * Decorator summary.\r\n *\r\n * @export\r\n * @interface DecorSummary\r\n */\r\nexport interface DecorSummary {\r\n    /**\r\n     * decorator name.\r\n     *\r\n     * @type {string}\r\n     * @memberof DecorSummary\r\n     */\r\n    name: string;\r\n    /**\r\n     * decorator types.\r\n     *\r\n     * @type {string}\r\n     * @memberof DecorSummary\r\n     */\r\n    types: string;\r\n    /**\r\n     * decorator registed actions.\r\n     *\r\n     * @type {string[]}\r\n     * @memberof DecorSummary\r\n     */\r\n    actions: string[];\r\n}\r\n\r\n/**\r\n * life scope interface symbol.\r\n * it is a symbol id, you can register yourself MethodAccessor for this.\r\n */\r\nexport const LifeScopeToken = new InjectToken<LifeScope>('DI_LifeScope');\r\n\r\n/**\r\n * life scope of decorator.\r\n *\r\n * @export\r\n * @interface LifeScope\r\n */\r\nexport interface LifeScope {\r\n\r\n    /**\r\n     * execute the action work.\r\n     *\r\n     * @template T\r\n     * @param {ActionData<T>} data execute data;\r\n     * @param {string} names execute action name.\r\n     * @memberof ActionComponent\r\n     */\r\n    execute<T>(data: ActionData<T>, ...names: string[]);\r\n\r\n    /**\r\n     * execute the action work route with parent container.\r\n     *\r\n     * @template T\r\n     * @param {ActionData<T>} data\r\n     * @param {...string[]} names\r\n     * @memberof LifeScope\r\n     */\r\n    routeExecute<T>(data: ActionData<T>, ...names: string[]);\r\n\r\n    /**\r\n     * register action.\r\n     *\r\n     * @param {ActionComponent} action the action.\r\n     * @param {...string[]} express the path  of action point to add the action.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    addAction(action: ActionComponent, ...nodepaths: string[]): this;\r\n\r\n    /**\r\n     * register decorator.\r\n     *\r\n     * @param {Function} decorator decorator\r\n     * @param {...string[]} actions action names.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    registerDecorator(decorator: Function, ...actions: string[]): this;\r\n\r\n    /**\r\n     * register decorator.\r\n     *\r\n     * @param {Function} decorator decorator\r\n     * @param {DecoratorType} type  custom set decorator type.\r\n     * @param {...string[]} actions action names.\r\n     * @returns {this}\r\n     * @memberof LifeScope\r\n     */\r\n    registerCustomDecorator(decorator: Function, type: DecoratorType, ...actions: string[]): this;\r\n\r\n    /**\r\n     * filter match decorators.\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} express\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    filerDecorators(express: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n\r\n    /**\r\n     * get class decorators\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getClassDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get method decorators\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get property decorators\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getPropertyDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n    /**\r\n     * get parameter decorators\r\n     *\r\n     * @param {Express<DecorSummary, boolean>} [match]\r\n     * @returns {DecorSummary[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getParameterDecorators(match?: Express<DecorSummary, boolean>): DecorSummary[];\r\n\r\n\r\n    /**\r\n     * get decorator type.\r\n     *\r\n     * @param {*} decorator\r\n     * @returns {DecoratorType}\r\n     * @memberof LifeScope\r\n     */\r\n    getDecoratorType(decorator: any): DecoratorType;\r\n\r\n    /**\r\n     * is vaildate dependence type or not. dependence type must with class decorator.\r\n     *\r\n     * @template T\r\n     * @param {any} target\r\n     * @returns {boolean}\r\n     * @memberof LifeScope\r\n     */\r\n    isVaildDependence<T>(target: any): boolean;\r\n\r\n    /**\r\n     * is singleton or not.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {boolean}\r\n     * @memberof LifeScope\r\n     */\r\n    isSingletonType<T>(type: Type<T>): boolean;\r\n\r\n    /**\r\n     * get action by name.\r\n     *\r\n     * @param {string} name\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getAtionByName(name: string): ActionComponent;\r\n\r\n    /**\r\n     * get class action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getClassAction(): ActionComponent;\r\n\r\n    /**\r\n     * get method action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodAction(): ActionComponent;\r\n\r\n    /**\r\n     * get propert action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getPropertyAction(): ActionComponent;\r\n\r\n    /**\r\n     * get parameter action.\r\n     *\r\n     * @returns {ActionComponent}\r\n     * @memberof LifeScope\r\n     */\r\n    getParameterAction(): ActionComponent;\r\n\r\n    /**\r\n     * get paramerter names.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {string} propertyKey\r\n     * @returns {string[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getParamerterNames<T>(type: Type<T>, propertyKey: string): string[];\r\n\r\n    /**\r\n     * get constructor parameters metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getConstructorParameters<T>(type: Type<T>): IParameter[];\r\n\r\n    /**\r\n     * get method params metadata.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {T} instance\r\n     * @param {string} propertyKey\r\n     * @returns {IParameter[]}\r\n     * @memberof IContainer\r\n     */\r\n    getMethodParameters<T>(type: Type<T>, instance: T, propertyKey: string): IParameter[];\r\n\r\n\r\n    /**\r\n     * get method metadatas\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} type\r\n     * @param {(string | symbol)} propertyKey\r\n     * @returns {MethodMetadata[]}\r\n     * @memberof LifeScope\r\n     */\r\n    getMethodMetadatas<T>(type: Type<T>, propertyKey: string | symbol): MethodMetadata[];\r\n\r\n    /**\r\n     * convert decorator type to action name.\r\n     *\r\n     * @param {DecoratorType} type\r\n     * @returns {string}\r\n     * @memberof LifeScope\r\n     */\r\n    toActionName(type: DecoratorType): string;\r\n}\r\n","import { IContainer } from './IContainer';\r\nimport { Type, Modules, LoadType } from './types';\r\nimport { InjectToken } from './InjectToken';\r\nimport { IModuleLoader, IModuleInjectorChain } from './injectors';\r\n\r\n/**\r\n * ContainerBuilder interface token.\r\n * it is a token id, you can register yourself IContainerBuilder for this.\r\n */\r\nexport const ContainerBuilderToken = new InjectToken<IContainerBuilder>('DI_IContainerBuilder');\r\n\r\n/**\r\n * container builder.\r\n *\r\n * @export\r\n * @interface IContainerBuilder\r\n */\r\nexport interface IContainerBuilder {\r\n\r\n    /**\r\n     * loader\r\n     *\r\n     * @type {IModuleLoader}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    readonly loader: IModuleLoader;\r\n\r\n    /**\r\n     * create a new container.\r\n     *\r\n     * @returns {IContainer}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    create(): IContainer;\r\n    /**\r\n     * create a new container and load module via options.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @param {string} [basePath]\r\n     * @returns {Promise<IContainer>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    build(...modules: LoadType[]): Promise<IContainer>;\r\n\r\n    /**\r\n     * build container in sync.\r\n     *\r\n     * @param {LoadOptions} options\r\n     * @returns {IContainer}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    syncBuild(...modules: Modules[]): IContainer;\r\n\r\n    /**\r\n     * load modules for container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    loadModule(container: IContainer, ...modules: LoadType[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * sync load modules\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...Modules[]} modules\r\n     * @memberof IContainerBuilder\r\n     */\r\n    syncLoadModule(container: IContainer, ...modules: Modules[]);\r\n\r\n    /**\r\n     * get moduleInjector chain.\r\n     *\r\n     * @param {IContainer} container\r\n     * @returns {IModuleInjectorChain}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    getInjectorChain(container: IContainer): IModuleInjectorChain;\r\n\r\n}\r\n","import { SymbolType, Providers, Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { ResolverType } from './ResolverType';\r\nimport { Container } from '../Container';\r\nimport { isClass } from '../utils';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { IResolver } from '../IResolver';\r\n\r\n\r\nexport const ResolverChainToken = new InjectToken<ResolverChain>('di_ResolverChain');\r\n\r\nexport class ResolverChain implements IResolver {\r\n\r\n    protected resolvers: ResolverType[];\r\n    constructor(protected container: IContainer) {\r\n        this.resolvers = [];\r\n    }\r\n\r\n    next(resolver: ResolverType) {\r\n        if (!this.hasResolver(resolver)) {\r\n            this.resolvers.push(resolver);\r\n        }\r\n    }\r\n\r\n    toArray(): ResolverType[] {\r\n        return [<ResolverType>this.container].concat(this.resolvers);\r\n    }\r\n\r\n    hasResolver(resolver: ResolverType) {\r\n        if (resolver instanceof Container) {\r\n            return this.resolvers.indexOf(resolver) >= 0;\r\n        } else {\r\n            return this.resolvers.some(a => {\r\n                if (a instanceof Container) {\r\n                    return false;\r\n                } else {\r\n                    if (!a.type || !resolver.type) {\r\n                        return false;\r\n                    }\r\n                    return a.type === resolver.type;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    hasToken<T>(resolver: ResolverType, token: SymbolType<T>): boolean {\r\n        if (!token) {\r\n            return false;\r\n        }\r\n        if (resolver instanceof Container) {\r\n            return resolver.hasRegister(token);\r\n        } else {\r\n            if (resolver.type === token || this.container.getTokenKey(resolver.token) === token) {\r\n                return true;\r\n            }\r\n            let exps = resolver.exports || [];\r\n            return exps.concat(resolver.providers || []).some(t => {\r\n                if (this.container.getTokenKey(t) === token) {\r\n                    return true;\r\n                } else if (!isClass(token)) {\r\n                    if (resolver.container.hasRegister(token)) {\r\n                        let type = resolver.container.getTokenImpl(token);\r\n                        return exps.indexOf(type) >= 0\r\n                    }\r\n                }\r\n                return false;\r\n            });\r\n        }\r\n    }\r\n\r\n    resolve<T>(token: SymbolType<T>, ...providers: Providers[]): T {\r\n        let resolver = this.toArray().find(r => this.hasToken(r, token));\r\n        if (!resolver && !this.container.parent) {\r\n            console.log('have not register', token);\r\n            return null;\r\n        }\r\n        if (resolver) {\r\n            if (resolver instanceof Container) {\r\n                return resolver.resolveValue(token, ...providers);\r\n            } else {\r\n                return resolver.container.resolveValue(token, ...providers);\r\n            }\r\n        } else {\r\n            return this.container.parent.resolve(token, ...providers);\r\n        }\r\n    }\r\n\r\n    unregister<T>(token: SymbolType<T>) {\r\n        let resolver = this.toArray().find(r => this.hasToken(r, token));\r\n        if (resolver) {\r\n            if (resolver instanceof Container) {\r\n                resolver.unregister(token, false);\r\n            } else {\r\n                let idx = this.resolvers.indexOf(resolver);\r\n                if (idx >= 0 && idx < this.resolvers.length) {\r\n                    this.resolvers.splice(idx, 1);\r\n                }\r\n            }\r\n        } else if (this.container.parent) {\r\n            this.container.parent.unregister(token);\r\n        }\r\n    }\r\n\r\n    getTokenImpl<T>(token: SymbolType<T>): Type<T> {\r\n        let resolver = this.toArray().find(r => this.hasToken(r, token));\r\n        if (resolver) {\r\n            if (resolver instanceof Container) {\r\n                return resolver.getTokenImpl(token, false);\r\n            } else {\r\n                return resolver.container.getTokenImpl(token, false);\r\n            }\r\n        } else if (this.container.parent) {\r\n            return this.container.parent.getTokenImpl(token);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    hasRegister<T>(token: SymbolType<T>): boolean {\r\n        if (this.container.hasRegister(token)) {\r\n            return true;\r\n        }\r\n        if (this.resolvers.length) {\r\n            return this.resolvers.some(r => this.hasToken(r, token));\r\n        }\r\n        return false;\r\n    }\r\n\r\n    has<T>(token: SymbolType<T>): boolean {\r\n        if (this.hasRegister(token)) {\r\n            return true;\r\n        }\r\n        if (this.container.parent) {\r\n            return this.container.parent.has(token);\r\n        }\r\n        return false;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ResolverChain\",\"params\":{\"constructor\":[\"container\"],\"next\":[\"resolver\"],\"toArray\":[],\"hasResolver\":[\"resolver\"],\"hasToken\":[\"resolver\",\"token\"],\"resolve\":[\"token\",\"providers\"],\"unregister\":[\"token\"],\"getTokenImpl\":[\"token\"],\"hasRegister\":[\"token\"],\"has\":[\"token\"]}};\n                   }\r\n","export * from './ResolverType';\r\nexport * from './ResolverChain';\r\n","import { IContainer } from './IContainer';\r\nimport { Injectable, Component, AutoWired, Inject, Singleton, Param, Method, Abstract, Autorun, IocExt } from './core/decorators';\r\nimport { CoreActions } from './core/actions';\r\nimport { DefaultLifeScope } from './core/DefaultLifeScope';\r\nimport { LifeScopeToken } from './LifeScope';\r\nimport { MethodAccessor } from './core/MethodAccessor';\r\nimport { CacheManager, ProviderMap, ProviderMapToken, ProviderMatcher, ProviderMatcherToken } from './core';\r\nimport { CacheManagerToken } from './ICacheManager';\r\nimport { MethodAccessorToken } from './IMethodAccessor';\r\nimport { ResolverChain, ResolverChainToken } from './resolves';\r\n\r\n/**\r\n * register core for container.\r\n *\r\n * @export\r\n * @param {IContainer} container\r\n */\r\nexport function registerCores(container: IContainer) {\r\n\r\n    container.registerSingleton(LifeScopeToken, () => new DefaultLifeScope(container));\r\n    container.registerSingleton(CacheManagerToken, () => new CacheManager(container));\r\n    container.registerSingleton(ResolverChainToken, () => new ResolverChain(container));\r\n    container.register(ProviderMapToken, () => new ProviderMap(container));\r\n    container.bindProvider(ProviderMap, ProviderMapToken);\r\n    container.registerSingleton(ProviderMatcherToken, () => new ProviderMatcher(container));\r\n    container.registerSingleton(MethodAccessorToken, () => new MethodAccessor(container));\r\n\r\n    let lifeScope = container.get(LifeScopeToken);\r\n\r\n    lifeScope.registerDecorator(Injectable, CoreActions.bindProvider, CoreActions.cache);\r\n    lifeScope.registerDecorator(Component, CoreActions.bindProvider, CoreActions.cache, CoreActions.componentBeforeInit, CoreActions.componentInit, CoreActions.componentAfterInit);\r\n    lifeScope.registerDecorator(Singleton, CoreActions.bindProvider);\r\n    lifeScope.registerDecorator(Abstract, CoreActions.bindProvider, CoreActions.cache);\r\n    lifeScope.registerDecorator(AutoWired, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Inject, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Param, CoreActions.bindParameterType, CoreActions.bindPropertyType);\r\n    lifeScope.registerDecorator(Method, CoreActions.bindParameterProviders);\r\n\r\n    lifeScope.registerDecorator(Autorun, CoreActions.autorun, CoreActions.methodAutorun);\r\n    lifeScope.registerDecorator(IocExt, CoreActions.autorun, CoreActions.componentBeforeInit, CoreActions.componentInit, CoreActions.componentAfterInit);\r\n\r\n    container.register(Date, () => new Date());\r\n    container.register(String, () => '');\r\n    container.register(Number, () => Number.NaN);\r\n    container.register(Boolean, () => undefined);\r\n\r\n}\r\n","import 'reflect-metadata';\r\nimport { IContainer, ContainerToken } from './IContainer';\r\nimport { Type, Token, Factory, SymbolType, ToInstance, IocState, Providers, Modules, LoadType } from './types';\r\nimport { Registration } from './Registration';\r\nimport { isClass, isFunction, isSymbol, isToken, isString, isUndefined, MapSet, lang } from './utils';\r\n\r\nimport { MethodAccessorToken } from './IMethodAccessor';\r\nimport { ActionComponent, CoreActions, CacheActionData, LifeState, ProviderMatcherToken } from './core';\r\nimport { LifeScope, LifeScopeToken } from './LifeScope';\r\nimport { IParameter } from './IParameter';\r\nimport { CacheManagerToken } from './ICacheManager';\r\nimport { IContainerBuilder, ContainerBuilderToken } from './IContainerBuilder';\r\nimport { registerCores } from './registerCores';\r\nimport { ResolverChain, ResolverChainToken } from './resolves';\r\n\r\n/**\r\n * Container\r\n *\r\n * @export\r\n * @class Container\r\n * @implements {IContainer}\r\n */\r\nexport class Container implements IContainer {\r\n    protected provideTypes: MapSet<Token<any>, Type<any>>;\r\n    protected factories: MapSet<Token<any>, Function>;\r\n    protected singleton: MapSet<Token<any>, any>;\r\n\r\n    /**\r\n     * parent container.\r\n     *\r\n     * @type {IContainer}\r\n     * @memberof Container\r\n     */\r\n    parent: IContainer;\r\n\r\n    constructor() {\r\n        this.init();\r\n    }\r\n\r\n    getRoot(): IContainer {\r\n        let root: IContainer = this;\r\n        while (root.parent) {\r\n            root = root.parent;\r\n        }\r\n        return root;\r\n    }\r\n\r\n    getBuilder(): IContainerBuilder {\r\n        return this.resolveValue(ContainerBuilderToken);\r\n    }\r\n\r\n    /**\r\n     * Retrieves an instance from the container based on the provided token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    get<T>(token: Token<T>, alias?: string, ...providers: Providers[]): T {\r\n        return this.resolve(alias ? this.getTokenKey<T>(token, alias) : token, ...providers);\r\n    }\r\n\r\n     /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    get resolvers(): ResolverChain {\r\n        return this.resolveValue(ResolverChainToken);\r\n    }\r\n\r\n    /**\r\n     * resolve type instance with token and param provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [notFoundValue]\r\n     * @param {...Providers[]} providers\r\n     * @memberof Container\r\n     */\r\n    resolve<T>(token: Token<T>, ...providers: Providers[]): T {\r\n        let key = this.getTokenKey<T>(token);\r\n        return this.resolvers.resolve(key, ...providers);\r\n    }\r\n\r\n    /**\r\n     * resolve token value in this container only.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof IContainer\r\n     */\r\n    resolveValue<T>(token: Token<T>, ...providers: Providers[]): T {\r\n        let key = this.getTokenKey(token);\r\n        if (!this.hasRegister(key)) {\r\n            return null;\r\n        }\r\n        let factory = this.factories.get(key);\r\n        return factory(...providers) as T;\r\n    }\r\n\r\n    /**\r\n     * clear cache.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @memberof IContainer\r\n     */\r\n    clearCache(targetType: Type<any>) {\r\n        this.resolveValue(CacheManagerToken).destroy(targetType);\r\n    }\r\n\r\n    /**\r\n     * get token.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {Token<T>}\r\n     * @memberof Container\r\n     */\r\n    getToken<T>(token: Token<T>, alias?: string): Token<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias);\r\n        }\r\n        return token;\r\n    }\r\n\r\n\r\n    /**\r\n     * get tocken key.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {SymbolType<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenKey<T>(token: Token<T>, alias?: string): SymbolType<T> {\r\n        if (alias) {\r\n            return new Registration(token, alias).toString();\r\n        } else if (token instanceof Registration) {\r\n            return token.toString();\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * register type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    register<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * has register the token or not.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {string} [alias]\r\n     * @returns {boolean}\r\n     * @memberof Container\r\n     */\r\n    has<T>(token: Token<T>, alias?: string): boolean {\r\n        let key = this.getTokenKey(token, alias);\r\n        return this.resolvers.has(key);\r\n    }\r\n\r\n    /**\r\n     * has register type.\r\n     *\r\n     * @template T\r\n     * @param {SymbolType<T>} key\r\n     * @returns\r\n     * @memberof Container\r\n     */\r\n    hasRegister<T>(key: SymbolType<T>) {\r\n        return this.factories.has(key);\r\n    }\r\n\r\n    /**\r\n     * unregister the token\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    unregister<T>(token: Token<T>, inchain?: boolean): this {\r\n        let key = this.getTokenKey(token);\r\n        if (inchain === false) {\r\n            if (this.hasRegister(key)) {\r\n                this.factories.delete(key);\r\n                if (this.provideTypes.has(key)) {\r\n                    this.provideTypes.delete(key);\r\n                }\r\n                if (isClass(key)) {\r\n                    this.clearCache(key);\r\n                }\r\n            }\r\n        } else {\r\n            this.resolvers.unregister(key);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register stingleton type.\r\n     * @abstract\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {Factory<T>} [value]\r\n     * @returns {this}\r\n     * @memberOf Container\r\n     */\r\n    registerSingleton<T>(token: Token<T>, value?: Factory<T>): this {\r\n        this.registerFactory(token, value, true);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * register value.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {T} value\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    registerValue<T>(token: Token<T>, value: T): this {\r\n        let key = this.getTokenKey(token);\r\n\r\n        this.singleton.set(key, value);\r\n        if (!this.factories.has(key)) {\r\n            this.factories.set(key, () => {\r\n                return this.singleton.get(key);\r\n            });\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * bind provider.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} provide\r\n     * @param {Token<T>} provider\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    bindProvider<T>(provide: Token<T>, provider: Token<T> | Factory<T>): this {\r\n        let provideKey = this.getTokenKey(provide);\r\n        let factory;\r\n        if (isToken(provider)) {\r\n            factory = (...providers: Providers[]) => {\r\n                return this.resolve(provider, ...providers);\r\n            };\r\n        } else {\r\n            if (isFunction(provider)) {\r\n                factory = (...providers: Providers[]) => {\r\n                    return (<ToInstance<any>>provider)(this, ...providers);\r\n                };\r\n            } else {\r\n                factory = () => {\r\n                    return provider\r\n                };\r\n            }\r\n        }\r\n        if (isClass(provider)) {\r\n            if (!this.has(provider)) {\r\n                this.register(provider);\r\n            }\r\n            this.provideTypes.set(provideKey, provider);\r\n        } else if (isToken(provider)) {\r\n            let token = provider;\r\n            while (this.provideTypes.has(token) && !isClass(token)) {\r\n                token = this.provideTypes.get(token);\r\n                if (isClass(token)) {\r\n                    this.provideTypes.set(provideKey, token);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.factories.set(provideKey, factory);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * get token implements class type.\r\n     *\r\n     * @template T\r\n     * @param {Token<T>} token\r\n     * @param {boolean} [inchain]\r\n     * @returns {Type<T>}\r\n     * @memberof Container\r\n     */\r\n    getTokenImpl<T>(token: Token<T>, inchain?: boolean): Type<T> {\r\n        let tokenKey = this.getTokenKey(token);\r\n        if (inchain === false) {\r\n            if (isClass(token)) {\r\n                return token;\r\n            }\r\n            if (this.provideTypes.has(tokenKey)) {\r\n                return this.provideTypes.get(tokenKey);\r\n            }\r\n            return null;\r\n        } else {\r\n            return this.resolvers.getTokenImpl(tokenKey);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get token implement class and base classes.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @returns {Token<any>[]}\r\n     * @memberof Container\r\n     */\r\n    getTokenExtendsChain(token: Token<any>): Token<any>[] {\r\n        if (isClass(token)) {\r\n            return this.getBaseClasses(token);\r\n        } else {\r\n            return this.getBaseClasses(this.getTokenImpl(token)).concat([token]);\r\n        }\r\n    }\r\n\r\n    protected getBaseClasses(target: Function): Token<any>[] {\r\n        let types: Type<any>[] = [];\r\n        while (isClass(target) && target !== Object) {\r\n            types.push(target);\r\n            target = lang.getParentClass(target);\r\n        }\r\n        return types;\r\n    }\r\n\r\n    /**\r\n    * get life scope of container.\r\n    *\r\n    * @returns {LifeScope}\r\n    * @memberof IContainer\r\n    */\r\n    getLifeScope(): LifeScope {\r\n        return this.get(LifeScopeToken);\r\n    }\r\n\r\n    /**\r\n     * use modules.\r\n     *\r\n     * @param {...Modules[]} modules\r\n     * @returns {this}\r\n     * @memberof Container\r\n     */\r\n    use(...modules: Modules[]): this {\r\n        this.getBuilder().syncLoadModule(this, ...modules);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * async use modules.\r\n     *\r\n     * @param {...LoadType[]} modules load modules.\r\n     * @returns {Promise<Type<any>[]>}  types loaded.\r\n     * @memberof IContainer\r\n     */\r\n    loadModule(...modules: LoadType[]): Promise<Type<any>[]> {\r\n        return this.getBuilder().loadModule(this, ...modules);\r\n    }\r\n\r\n    /**\r\n     * invoke method async.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} token\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...Providers[]} providers\r\n     * @returns {Promise<T>}\r\n     * @memberof Container\r\n     */\r\n    invoke<T>(token: Token<any>, propertyKey: string, instance?: any, ...providers: Providers[]): Promise<T> {\r\n        return this.resolveValue(MethodAccessorToken).invoke(token, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    /**\r\n     * invoke method.\r\n     *\r\n     * @template T\r\n     * @param {Token<any>} token\r\n     * @param {string} propertyKey\r\n     * @param {*} [instance]\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof Container\r\n     */\r\n    syncInvoke<T>(token: Token<any>, propertyKey: string, instance?: any, ...providers: Providers[]): T {\r\n        return this.resolveValue(MethodAccessorToken).syncInvoke(token, propertyKey, instance, ...providers);\r\n    }\r\n\r\n    createSyncParams(params: IParameter[], ...providers: Providers[]): any[] {\r\n        return this.resolveValue(MethodAccessorToken).createSyncParams(params, ...providers);\r\n    }\r\n\r\n    createParams(params: IParameter[], ...providers: Providers[]): Promise<any[]> {\r\n        return this.resolveValue(MethodAccessorToken).createParams(params, ...providers);\r\n    }\r\n\r\n    protected cacheDecorator<T>(map: MapSet<string, ActionComponent>, action: ActionComponent) {\r\n        if (!map.has(action.name)) {\r\n            map.set(action.name, action);\r\n        }\r\n    }\r\n\r\n    protected init() {\r\n        this.factories = new MapSet<Token<any>, Function>();\r\n        this.singleton = new MapSet<Token<any>, any>();\r\n        this.provideTypes = new MapSet<Token<any>, Type<any>>();\r\n        this.bindProvider(ContainerToken, () => this);\r\n\r\n        registerCores(this);\r\n    }\r\n\r\n    protected registerFactory<T>(token: Token<T>, value?: Factory<T>, singleton?: boolean) {\r\n        let key = this.getTokenKey(token);\r\n\r\n        if (this.factories.has(key)) {\r\n            return;\r\n        }\r\n\r\n        let classFactory;\r\n        if (!isUndefined(value)) {\r\n            if (isFunction(value)) {\r\n                if (isClass(value)) {\r\n                    this.bindTypeFactory(key, value as Type<T>, singleton);\r\n                } else {\r\n                    classFactory = this.createCustomFactory(key, value as ToInstance<T>, singleton);\r\n                }\r\n            } else if (singleton && value !== undefined) {\r\n                classFactory = this.createCustomFactory(key, () => value, singleton);\r\n            }\r\n\r\n        } else if (!isString(token) && !isSymbol(token)) {\r\n            let ClassT = (token instanceof Registration) ? token.getClass() : token;\r\n            if (isClass(ClassT)) {\r\n                this.bindTypeFactory(key, ClassT as Type<T>, singleton);\r\n            }\r\n        }\r\n\r\n        if (classFactory) {\r\n            this.factories.set(key, classFactory);\r\n        }\r\n    }\r\n\r\n    protected createCustomFactory<T>(key: SymbolType<T>, factory?: ToInstance<T>, singleton?: boolean) {\r\n        return singleton ?\r\n            (...providers: Providers[]) => {\r\n                if (this.singleton.has(key)) {\r\n                    return this.singleton.get(key);\r\n                }\r\n                let instance = factory(this, ...providers);\r\n                this.singleton.set(key, instance);\r\n                return instance;\r\n            }\r\n            : (...providers: Providers[]) => factory(this, ...providers);\r\n    }\r\n\r\n    protected bindTypeFactory<T>(key: SymbolType<T>, ClassT?: Type<T>, singleton?: boolean) {\r\n        if (!Reflect.isExtensible(ClassT)) {\r\n            return;\r\n        }\r\n\r\n        let lifeScope = this.getLifeScope();\r\n        let parameters = lifeScope.getConstructorParameters(ClassT);\r\n\r\n        if (!singleton) {\r\n            singleton = lifeScope.isSingletonType<T>(ClassT);\r\n        }\r\n\r\n        let factory = (...providers: Providers[]) => {\r\n            if (singleton && this.singleton.has(key)) {\r\n                return this.singleton.get(key);\r\n            }\r\n\r\n            if (providers.length < 1) {\r\n                let lifecycleData: CacheActionData = {\r\n                    tokenKey: key,\r\n                    targetType: ClassT,\r\n                    // raiseContainer: this,\r\n                    singleton: singleton\r\n                };\r\n                lifeScope.execute(lifecycleData, CoreActions.cache);\r\n                if (lifecycleData.execResult && lifecycleData.execResult instanceof ClassT) {\r\n                    return lifecycleData.execResult;\r\n                }\r\n            }\r\n\r\n            let providerMap = this.get(ProviderMatcherToken).toProviderMap(...providers);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeCreateArgs);\r\n\r\n            let args = this.createSyncParams(parameters, providerMap);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.beforeConstructor);\r\n\r\n            let instance = new ClassT(...args);\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.afterConstructor);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.onInit);\r\n\r\n\r\n            lifeScope.routeExecute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this,\r\n                args: args,\r\n                params: parameters,\r\n                providers: providers,\r\n                providerMap: providerMap,\r\n                singleton: singleton\r\n            }, IocState.runtime, LifeState.AfterInit);\r\n\r\n            lifeScope.execute({\r\n                tokenKey: key,\r\n                target: instance,\r\n                targetType: ClassT,\r\n                raiseContainer: this\r\n            }, CoreActions.cache);\r\n\r\n            return instance;\r\n        };\r\n\r\n        this.factories.set(key, factory);\r\n\r\n        lifeScope.routeExecute({\r\n            tokenKey: key,\r\n            targetType: ClassT,\r\n            raiseContainer: this\r\n        }, IocState.design);\r\n\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"Container\",\"params\":{\"constructor\":[],\"getRoot\":[],\"getBuilder\":[],\"get\":[\"token\",\"alias\",\"providers\"],\"resolve\":[\"token\",\"providers\"],\"resolveValue\":[\"token\",\"providers\"],\"clearCache\":[\"targetType\"],\"getToken\":[\"token\",\"alias\"],\"getTokenKey\":[\"token\",\"alias\"],\"register\":[\"token\",\"value\"],\"has\":[\"token\",\"alias\"],\"hasRegister\":[\"key\"],\"unregister\":[\"token\",\"inchain\"],\"registerSingleton\":[\"token\",\"value\"],\"registerValue\":[\"token\",\"value\"],\"bindProvider\":[\"provide\",\"provider\"],\"getTokenImpl\":[\"token\",\"inchain\"],\"getTokenExtendsChain\":[\"token\"],\"getBaseClasses\":[\"target\"],\"getLifeScope\":[],\"use\":[\"modules\"],\"loadModule\":[\"modules\"],\"invoke\":[\"token\",\"propertyKey\",\"instance\",\"providers\"],\"syncInvoke\":[\"token\",\"propertyKey\",\"instance\",\"providers\"],\"createSyncParams\":[\"params\",\"providers\"],\"createParams\":[\"params\",\"providers\"],\"cacheDecorator\":[\"map\",\"action\"],\"init\":[],\"registerFactory\":[\"token\",\"value\",\"singleton\"],\"createCustomFactory\":[\"key\",\"factory\",\"singleton\"],\"bindTypeFactory\":[\"key\",\"ClassT\",\"singleton\"]}};\n                   }\r\n\r\n\r\n","import { Type, Modules, LoadType } from '../types';\r\nimport { InjectToken } from '../InjectToken';\r\n\r\n/**\r\n * module loader token.\r\n */\r\nexport const ModuleLoaderToken = new InjectToken<IModuleLoader>('DI_ModuleLoader');\r\n\r\n\r\n/**\r\n * module loader interface for ioc.\r\n *\r\n * @export\r\n * @interface IModuleLoader\r\n */\r\nexport interface IModuleLoader {\r\n    /**\r\n     * load modules by files patterns, module name or modules.\r\n     *\r\n     * @param {LoadType[]} modules\r\n     * @returns {Promise<Modules[]>}\r\n     * @memberof IModuleLoader\r\n     */\r\n    load(modules: LoadType[]): Promise<Modules[]>;\r\n\r\n    /**\r\n     * load all class types in modules\r\n     *\r\n     * @param {LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IModuleLoader\r\n     */\r\n    loadTypes(modules: LoadType[]): Promise<Type<any>[][]>;\r\n\r\n    /**\r\n     * get all class type in modules.\r\n     *\r\n     * @param {Modules[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleLoader\r\n     */\r\n    getTypes(modules: Modules[]): Type<any>[][];\r\n\r\n}\r\n\r\n","import { Type, Modules, LoadType, PathModules } from '../types';\r\nimport { IModuleLoader } from './IModuleLoader';\r\nimport { isString, isClass, isObject, isArray } from '../utils';\r\n\r\ndeclare let require: any;\r\n\r\n/**\r\n * default module loader.\r\n *\r\n * @export\r\n * @class DefaultModuleLoader\r\n * @implements {IModuleLoader}\r\n */\r\nexport class DefaultModuleLoader implements IModuleLoader {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    private _loader: (modulepath: string) => Promise<Modules[]>;\r\n    getLoader() {\r\n        if (!this._loader) {\r\n            this._loader = this.createLoader();\r\n        }\r\n        return this._loader;\r\n    }\r\n\r\n    /**\r\n     * load module.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Modules[]>}\r\n     * @memberof DefaultModuleLoader\r\n     */\r\n    load(modules: LoadType[]): Promise<Modules[]> {\r\n        if (modules.length) {\r\n            return Promise.all(modules.map(mdty => {\r\n                if (isString(mdty)) {\r\n                    return this.isFile(mdty) ? this.loadFile(mdty) : this.loadModule(mdty);\r\n                } else if (isObject(mdty) && (mdty['modules'] || mdty['files'])) {\r\n                    return this.loadPathModule(mdty as PathModules);\r\n                } else {\r\n                    return mdty ? [mdty] : [];\r\n                }\r\n            }))\r\n                .then(allms => {\r\n                    let rmodules: Modules[] = [];\r\n                    allms.forEach(ms => {\r\n                        rmodules = rmodules.concat(ms);\r\n                    })\r\n                    return rmodules;\r\n                });\r\n        } else {\r\n            return Promise.resolve([]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * load types from module.\r\n     *\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof IContainerBuilder\r\n     */\r\n    async loadTypes(modules: LoadType[]): Promise<Type<any>[][]> {\r\n        let mdls = await this.load(modules);\r\n        return this.getTypes(mdls);\r\n    }\r\n\r\n    /**\r\n     * get all class type in modules.\r\n     *\r\n     * @param {Modules[]} modules\r\n     * @param {...Express<Type<any>, boolean>[]} filters\r\n     * @returns {Type<any>[]}\r\n     * @memberof DefaultModuleLoader\r\n     */\r\n    getTypes(modules: Modules[]): Type<any>[][] {\r\n        let regModules: Type<any>[][] = [];\r\n\r\n        modules.forEach(m => {\r\n            let types = this.getContentTypes(m);\r\n            regModules.push(types);\r\n        });\r\n\r\n        return regModules;\r\n    }\r\n\r\n    protected loadFile(files: string | string[], basePath?: string): Promise<Modules[]> {\r\n        let loader = this.getLoader();\r\n        let fRes: Promise<Modules[]>;\r\n        if (isArray(files)) {\r\n            fRes = Promise.all(files.map(f => loader(f)))\r\n                .then(allms => {\r\n                    let rms = [];\r\n                    allms.forEach(ms => {\r\n                        rms = rms.concat(ms);\r\n                    });\r\n                    return rms;\r\n                });\r\n        } else {\r\n            fRes = loader(files);\r\n        }\r\n        return fRes.then(ms => ms.filter(it => !!it));\r\n    }\r\n\r\n    protected isFile(str: string) {\r\n        return str && /\\/((\\w|%|\\.))+\\.\\w+$/.test(str.replace(/\\\\\\\\/gi, '/'));\r\n    }\r\n\r\n\r\n    protected loadModule(moduleName: string): Promise<Modules[]> {\r\n        let loader = this.getLoader();\r\n        return loader(moduleName).then(ms => ms.filter(it => !!it));\r\n    }\r\n\r\n    protected async loadPathModule(pmd: PathModules): Promise<Modules[]> {\r\n        let modules: Modules[] = [];\r\n        if (pmd.files) {\r\n            await this.loadFile(pmd.files, pmd.basePath)\r\n                .then(allmoduls => {\r\n                    allmoduls.forEach(ms => {\r\n                        modules = modules.concat(ms);\r\n                    });\r\n                    return modules;\r\n                })\r\n        }\r\n        if (pmd.modules) {\r\n            await Promise.all(pmd.modules.map(nmd => {\r\n                return isString(nmd) ? this.loadModule(nmd) : nmd;\r\n            })).then(ms => {\r\n                modules = modules.concat(ms);\r\n                return modules;\r\n            });\r\n        }\r\n\r\n        return modules;\r\n    }\r\n\r\n    protected createLoader(): (modulepath: string) => Promise<Modules[]> {\r\n        if (typeof require !== 'undefined') {\r\n            return (modulepath: string) => {\r\n                return new Promise<Modules[]>((resolve, reject) => {\r\n                    require([modulepath], (mud) => {\r\n                        resolve(mud);\r\n                    }, err => {\r\n                        reject(err);\r\n                    })\r\n                });\r\n            }\r\n        } else {\r\n            throw new Error('has not module loader');\r\n        }\r\n    }\r\n\r\n    protected getContentTypes(regModule: Modules): Type<any>[] {\r\n        let regModules: Type<any>[] = [];\r\n\r\n        if (isClass(regModule)) {\r\n            regModules.push(regModule);\r\n        } else {\r\n            let rmodules = regModule['exports'] ? regModule['exports'] : regModule;\r\n            for (let p in rmodules) {\r\n                let type = rmodules[p];\r\n                if (isClass(type)) {\r\n                    regModules.push(type);\r\n                }\r\n            }\r\n        }\r\n\r\n        return regModules;\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"DefaultModuleLoader\",\"params\":{\"constructor\":[],\"getLoader\":[],\"load\":[\"modules\"],\"loadTypes\":[\"modules\"],\"getTypes\":[\"modules\"],\"loadFile\":[\"files\",\"basePath\"],\"isFile\":[\"str\"],\"loadModule\":[\"moduleName\"],\"loadPathModule\":[\"pmd\"],\"createLoader\":[],\"getContentTypes\":[\"regModule\"]}};\n                   }\r\n","import { Type, Token } from '../types';\r\nimport { InjectToken } from '../InjectToken';\r\nimport { Registration } from '../Registration';\r\nimport { IAnnotationMetadata, IMetaAccessor } from './IMetaAccessor';\r\nimport { IContainer } from '../IContainer';\r\n\r\n/**\r\n * module validate.\r\n *\r\n * @export\r\n * @interface IModuleValidate\r\n */\r\nexport interface IModuleValidate {\r\n    /**\r\n     * is right module or not.\r\n     *\r\n     * @param {Type<any>} type\r\n     * @returns {boolean}\r\n     * @memberof IModuleValidate\r\n     */\r\n    validate(type: Type<any>): boolean;\r\n\r\n    /**\r\n     * get module metadata config.\r\n     *\r\n     * @param {Token<any>} token\r\n     * @param {IContainer} container\r\n     * @returns {ClassMetadata}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getMetaConfig(token: Token<any>, container: IContainer): IAnnotationMetadata<any>;\r\n\r\n    /**\r\n     * get meta accessor.\r\n     *\r\n     * @param {IContainer} container\r\n     * @returns {IMetaAccessor<any>}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getMetaAccessor(container: IContainer): IMetaAccessor<any>;\r\n    /**\r\n     * decorator of the module.\r\n     *\r\n     * @returns {(string | string[])}\r\n     * @memberof IModuleValidate\r\n     */\r\n    getDecorator(): string | string[];\r\n}\r\n\r\n/**\r\n * inject module validate token.\r\n *\r\n * @export\r\n * @class InjectModuleValidateToken\r\n * @extends {Registration<T>}\r\n * @template T\r\n */\r\nexport class InjectModuleValidateToken<T extends IModuleValidate> extends Registration<T> {\r\n    constructor(desc: string) {\r\n        super('DI_ModuleValidate', desc)\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InjectModuleValidateToken\",\"params\":{\"constructor\":[\"desc\"]}};\n                   }\r\n\r\n/**\r\n * Module Validate Token\r\n */\r\nexport const ModuleValidateToken = new InjectToken<IModuleValidate>('DI_ModuleValidate');\r\n","import { ClassMetadata } from '../core';\r\nimport { Token, Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { Registration } from '../Registration';\r\n\r\n/**\r\n * annotation metadata.\r\n *\r\n * @export\r\n * @interface IAnnotationMetadata\r\n * @extends {ClassMetadata}\r\n * @template T\r\n */\r\nexport interface IAnnotationMetadata<T> extends ClassMetadata {\r\n\r\n    /**\r\n     * annotation for the type.\r\n     *\r\n     * @type {Token<T>}\r\n     * @memberof AnnotationConfigure\r\n     */\r\n    token?: Token<T>;\r\n    /**\r\n     * Annotation class Type.\r\n     *\r\n     * @type {Type<T>}\r\n     * @memberof IAnnotationMetadata\r\n     */\r\n    type?: Type<T>;\r\n}\r\n\r\n/**\r\n * module metadata accessor\r\n *\r\n * @export\r\n * @interface IMetaAccessor\r\n * @template T\r\n */\r\nexport interface IMetaAccessor<T> {\r\n    /**\r\n     * get then first decorator metadata contain via decorators in order.\r\n     *\r\n     * @returns {(string | string[])}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getDecorators(): string[];\r\n    /**\r\n     * get metadata config of target type. via decorators in order.\r\n     *\r\n     * @param {Token<T>} type\r\n     * @param {IContainer} container\r\n     * @returns {IAnnotationMetadata<T>}\r\n     * @memberof IMetaAccessor\r\n     */\r\n    getMetadata(type: Token<T>, container: IContainer): IAnnotationMetadata<T>;\r\n}\r\n\r\n/**\r\n * application service token.\r\n *\r\n * @export\r\n * @class InjectMetaAccessorToken\r\n * @extends {Registration<MetaAccessor<T>>}\r\n * @template T\r\n */\r\nexport class InjectMetaAccessorToken<T> extends Registration<IMetaAccessor<T>> {\r\n    constructor(type: Token<T>) {\r\n        super(type, 'boot__metaAccessor');\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InjectMetaAccessorToken\",\"params\":{\"constructor\":[\"type\"]}};\n                   }\r\n\r\n/**\r\n * default MetaAccessor token.\r\n */\r\nexport const DefaultMetaAccessorToken = new InjectMetaAccessorToken<any>('default');\r\n\r\n/**\r\n * Annotation MetaAccessor token.\r\n */\r\nexport const AnnotationMetaAccessorToken = new InjectMetaAccessorToken<any>('Annotation');\r\n","import { IModuleValidate, InjectModuleValidateToken } from './IModuleValidate';\r\nimport { Type, Token } from '../types';\r\nimport { isClass, isString, isArray, isToken } from '../utils';\r\nimport { hasOwnClassMetadata, IocExt } from '../core';\r\nimport { IMetaAccessor, IAnnotationMetadata, AnnotationMetaAccessorToken } from './IMetaAccessor';\r\nimport { IContainer } from '../IContainer';\r\n\r\n/**\r\n * base module validate.\r\n *\r\n * @export\r\n * @abstract\r\n * @class BaseModuelValidate\r\n * @implements {IModuleValidate}\r\n */\r\nexport abstract class BaseModuelValidate implements IModuleValidate {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    validate(type: Type<any>): boolean {\r\n        if (!isClass(type)) {\r\n            return false;\r\n        }\r\n        let decorator = this.getDecorator();\r\n        if (isString(decorator)) {\r\n            return hasOwnClassMetadata(decorator, type);\r\n        } else if (isArray(decorator)) {\r\n            if (decorator.length > 0) {\r\n                return decorator.some(decor => hasOwnClassMetadata(decor, type))\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getMetaConfig(token: Token<any>, container: IContainer): IAnnotationMetadata<any> {\r\n        if (isToken(token)) {\r\n            let accessor = this.getMetaAccessor(container);\r\n            return accessor.getMetadata(token, container);\r\n        }\r\n        return {};\r\n    }\r\n\r\n    getMetaAccessor(container: IContainer): IMetaAccessor<any> {\r\n        let decorator = this.getDecorator();\r\n        return container.resolve(AnnotationMetaAccessorToken, { decorator: decorator });\r\n    }\r\n\r\n    abstract getDecorator(): string | string[];\r\n\n                        static classAnnations:any  = {\"name\":\"BaseModuelValidate\",\"params\":{\"constructor\":[],\"validate\":[\"type\"],\"getMetaConfig\":[\"token\",\"container\"],\"getMetaAccessor\":[\"container\"],\"getDecorator\":[]}};\n                   }\r\n\r\n/**\r\n * IocExt module validate token.\r\n */\r\nexport const IocExtModuleValidateToken = new InjectModuleValidateToken(IocExt.toString());\r\n/**\r\n * IocExt module validate.\r\n *\r\n * @export\r\n * @class IocExtModuleValidate\r\n * @extends {BaseModuelValidate}\r\n * @implements {IModuleValidate}\r\n */\r\nexport class IocExtModuleValidate extends BaseModuelValidate implements IModuleValidate {\r\n    getDecorator(): string {\r\n        return IocExt.toString()\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"IocExtModuleValidate\",\"params\":{\"getDecorator\":[]}};\n                   }\r\n","\r\nimport { Injectable, getTypeMetadata, hasOwnClassMetadata } from '../core';\r\nimport { Token, Providers } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { isClass, isToken, isArray } from '../utils';\r\nimport { DefaultMetaAccessorToken, IMetaAccessor, IAnnotationMetadata, AnnotationMetaAccessorToken, InjectMetaAccessorToken } from './IMetaAccessor';\r\n\r\n@Injectable(DefaultMetaAccessorToken)\r\nexport class MetaAccessor implements IMetaAccessor<any> {\r\n\r\n    protected decorators: string[];\r\n    constructor(decorator: string | string[]) {\r\n        this.decorators = isArray(decorator) ? decorator : [decorator];\r\n    }\r\n\r\n    getDecorators(): string[] {\r\n        return this.decorators;\r\n    }\r\n\r\n    getMetadata(token: Token<any>, container: IContainer): IAnnotationMetadata<any> {\r\n        let type = isClass(token) ? token : container.getTokenImpl(token);\r\n        if (isClass(type)) {\r\n            let decorators = this.getDecorators();\r\n            let firstDecor = decorators.find(decor => hasOwnClassMetadata(decor, type));\r\n\r\n            let metas = getTypeMetadata<IAnnotationMetadata<any>>(firstDecor, type);\r\n            if (metas && metas.length) {\r\n                let meta = metas[0];\r\n                return meta;\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"MetaAccessor\",\"params\":{\"constructor\":[\"decorator\"],\"getDecorators\":[],\"getMetadata\":[\"token\",\"container\"]}};\n                   }\r\n\r\n\r\n\r\n/**\r\n * Annotation MetaAccessor.\r\n *\r\n * @export\r\n * @class AnnotationMetaAccessor\r\n * @implements {IMetaAccessor<any>}\r\n */\r\n@Injectable(AnnotationMetaAccessorToken)\r\nexport class AnnotationMetaAccessor implements IMetaAccessor<any> {\r\n\r\n    protected decorators: string[];\r\n    constructor(decorator: string | string[]) {\r\n        this.decorators = isArray(decorator) ? decorator : [decorator];\r\n    }\r\n\r\n    getDecorators(): string[] {\r\n        return this.decorators;\r\n    }\r\n\r\n    getMetadata(token: Token<any>, container: IContainer): IAnnotationMetadata<any> {\r\n        if (isToken(token)) {\r\n            let accessor: IMetaAccessor<any>;\r\n            let provider = { decorator: this.getDecorators() };\r\n            container.getTokenExtendsChain(token).forEach(tk => {\r\n                if (accessor) {\r\n                    return false;\r\n                }\r\n                let accToken = new InjectMetaAccessorToken<any>(tk);\r\n                if (container.has(accToken)) {\r\n                    accessor = container.resolve(accToken, provider);\r\n                }\r\n                return true;\r\n            });\r\n            if (!accessor) {\r\n                accessor = this.getDefaultMetaAccessor(container, provider);\r\n            }\r\n            if (accessor) {\r\n                return accessor.getMetadata(token, container);\r\n            } else {\r\n                return {};\r\n            }\r\n        }\r\n        return {};\r\n    }\r\n\r\n    protected getDefaultMetaAccessor(container: IContainer, ...providers: Providers[]) {\r\n        return container.resolve(DefaultMetaAccessorToken, ...providers);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AnnotationMetaAccessor\",\"params\":{\"constructor\":[\"decorator\"],\"getDecorators\":[],\"getMetadata\":[\"token\",\"container\"],\"getDefaultMetaAccessor\":[\"container\",\"providers\"]}};\n                   }\r\n","import { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { Registration } from '../Registration';\r\n\r\n/**\r\n *  InjectorResult\r\n *\r\n * @export\r\n * @interface InjectorResult\r\n */\r\nexport interface InjectorResult {\r\n    injected: Type<any>[];\r\n    next?: Type<any>[];\r\n}\r\n\r\n/**\r\n * module injector.\r\n *\r\n * @export\r\n * @interface IModuleInjector\r\n */\r\nexport interface IModuleInjector {\r\n    /**\r\n     * inject module to container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleInjector\r\n     */\r\n    inject(container: IContainer, modules: Type<any>[]): any;\r\n}\r\n\r\n/**\r\n *  inject module injector token.\r\n */\r\nexport class InjectModuleInjectorToken<T extends IModuleInjector> extends Registration<T> {\r\n    constructor(desc: string, sync = false) {\r\n        super(sync ? 'DI_SyncModuleInjector' : 'DI_ModuleInjector', desc)\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InjectModuleInjectorToken\",\"params\":{\"constructor\":[\"desc\",\"sync\"]}};\n                   }\r\n\r\n/**\r\n * async module injector token.\r\n */\r\nexport const ModuleInjectorToken = new InjectModuleInjectorToken<IModuleInjector>('');\r\n\r\n/**\r\n * Sync module injector token.\r\n */\r\nexport const SyncModuleInjectorToken = new InjectModuleInjectorToken<IModuleInjector>('', true);\r\n","import { IModuleInjector, SyncModuleInjectorToken, ModuleInjectorToken, InjectorResult } from './IModuleInjector';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { PromiseUtil } from '../utils';\r\nimport { IModuleValidate } from './IModuleValidate';\r\nimport { Injectable } from '../core';\r\n\r\n\r\n/**\r\n * base module injector. abstract class.\r\n *\r\n * @export\r\n * @abstract\r\n * @class BaseModuleInjector\r\n * @implements {IModuleInjector}\r\n */\r\nexport abstract class BaseModuleInjector implements IModuleInjector {\r\n\r\n    /**\r\n     *Creates an instance of BaseModuleInjector.\r\n     * @param {IModuleValidate} [validate]\r\n     * @param {boolean} [skipNext] skip next when has match module to injector.\r\n     * @memberof BaseModuleInjector\r\n     */\r\n    constructor(protected validate?: IModuleValidate, protected skipNext?: boolean) {\r\n    }\r\n\r\n    abstract inject(container: IContainer, modules: Type<any>[]): any;\r\n\r\n    protected filter(modules: Type<any>[]): Type<any>[] {\r\n        modules = modules || [];\r\n        return this.validate ? modules.filter(md => this.validate.validate(md)) : modules;\r\n    }\r\n\r\n    protected next(all: Type<any>[], filtered: Type<any>[]): Type<any>[] {\r\n        if (filtered.length === 0) {\r\n            return all;\r\n        }\r\n        if (this.skipNext) {\r\n            return null;\r\n        }\r\n        if (filtered.length === all.length) {\r\n            return null;\r\n        }\r\n        return all.filter(it => filtered.indexOf(it) < 0);\r\n    }\r\n\r\n    protected setup(container: IContainer, type: Type<any>) {\r\n        container.register(type);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BaseModuleInjector\",\"params\":{\"constructor\":[\"validate\",\"skipNext\"],\"inject\":[\"container\",\"modules\"],\"filter\":[\"modules\"],\"next\":[\"all\",\"filtered\"],\"setup\":[\"container\",\"type\"]}};\n                   }\r\n\r\n/**\r\n * sync module injector.\r\n *\r\n * @export\r\n * @class SyncModuleInjector\r\n * @extends {BaseModuleInjector}\r\n * @implements {IModuleInjector}\r\n */\r\n@Injectable(SyncModuleInjectorToken)\r\nexport class SyncModuleInjector extends BaseModuleInjector implements IModuleInjector {\r\n\r\n    constructor(protected validate: IModuleValidate, skipNext?: boolean) {\r\n        super(validate, skipNext)\r\n    }\r\n\r\n    inject(container: IContainer, modules: Type<any>[]): InjectorResult {\r\n        let types = this.filter(modules);\r\n        if (types.length) {\r\n            types.forEach(ty => {\r\n                this.setup(container, ty);\r\n            });\r\n        }\r\n        let next = this.next(modules, types);\r\n        return { injected: types, next: next };\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"SyncModuleInjector\",\"params\":{\"constructor\":[\"validate\",\"skipNext\"],\"inject\":[\"container\",\"modules\"]}};\n                   }\r\n\r\n/**\r\n * module injector.\r\n *\r\n * @export\r\n * @class ModuleInjector\r\n * @extends {BaseModuleInjector}\r\n * @implements {IModuleInjector}\r\n */\r\n@Injectable(ModuleInjectorToken)\r\nexport class ModuleInjector extends BaseModuleInjector implements IModuleInjector {\r\n\r\n    constructor(protected validate: IModuleValidate, skipNext?: boolean) {\r\n        super(validate, skipNext)\r\n    }\r\n\r\n    async inject(container: IContainer, modules: Type<any>[]): Promise<InjectorResult> {\r\n        let types = this.filter(modules);\r\n        if (types.length) {\r\n            await PromiseUtil.step(types.map(ty => {\r\n                return this.setup(container, ty);\r\n            }));\r\n        }\r\n        let next = this.next(modules, types);\r\n        return { injected: types, next: next };\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ModuleInjector\",\"params\":{\"constructor\":[\"validate\",\"skipNext\"],\"inject\":[\"container\",\"modules\"]}};\n                   }\r\n","import { InjectToken } from '../InjectToken';\r\nimport { IContainer } from '../IContainer';\r\nimport { Type } from '../types';\r\nimport { IModuleInjector } from './IModuleInjector';\r\n\r\n/**\r\n * module Injector chian interface.\r\n *\r\n * @export\r\n * @interface IModuleInjectorChain\r\n */\r\nexport interface IModuleInjectorChain {\r\n    /**\r\n     * injector chain.\r\n     *\r\n     * @type {IModuleInjector[]}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    readonly injectors: IModuleInjector[];\r\n\r\n    /**\r\n     * set first step.\r\n     *\r\n     * @param {IModuleInjector} injector\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    first(injector: IModuleInjector): this;\r\n\r\n    /**\r\n     * set next step.\r\n     *\r\n     * @param {IModuleInjector} injector\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    next(injector: IModuleInjector): this;\r\n\r\n    /**\r\n     * inject module via injector chain.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Promise(Type<any>[]>}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    inject(container: IContainer, modules: Type<any>[]): Promise<Type<any>[]>;\r\n\r\n    /**\r\n     * sync inject module.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {Type<any>[]} modules\r\n     * @returns {Type<any>[]}\r\n     * @memberof IModuleInjectorChain\r\n     */\r\n    syncInject(container: IContainer, modules: Type<any>[]): Type<any>[];\r\n}\r\n\r\n\r\n/**\r\n * module fileter token. mast use as singlton.\r\n */\r\nexport const ModuleInjectorChainToken = new InjectToken<IModuleInjectorChain>('DI_ModuleInjectorChain');\r\n","import { IModuleInjectorChain } from './IModuleInjectorChain';\r\nimport { IModuleInjector, InjectorResult } from './IModuleInjector';\r\nimport { SyncModuleInjector, ModuleInjector } from './ModuleInjector';\r\nimport { Type } from '../types';\r\nimport { IContainer } from '../IContainer';\r\nimport { PromiseUtil } from '../utils';\r\n\r\n/**\r\n * Module Injector chain, base injector chain.\r\n *\r\n * @export\r\n * @class ModuleInjectorChain\r\n * @implements {IModuleInjectorChain}\r\n */\r\nexport class ModuleInjectorChain implements IModuleInjectorChain {\r\n\r\n    protected _injectors: IModuleInjector[];\r\n    get injectors(): IModuleInjector[] {\r\n        return this._injectors;\r\n    }\r\n\r\n    constructor() {\r\n        this._injectors = [];\r\n    }\r\n\r\n    first(injector: IModuleInjector) {\r\n        if (this.isInjector(injector)) {\r\n            this._injectors.unshift(injector);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    next(injector: IModuleInjector) {\r\n        if (this.isInjector(injector)) {\r\n            this._injectors.push(injector);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected isInjector(injector: IModuleInjector) {\r\n        return injector instanceof ModuleInjector || injector instanceof SyncModuleInjector;\r\n    }\r\n\r\n    async inject(container: IContainer, modules: Type<any>[]): Promise<Type<any>[]> {\r\n        let types: Type<any>[] = [];\r\n        await PromiseUtil.forEach<InjectorResult>(this.injectors.map(jtor => (ijrt: InjectorResult) => jtor.inject(container, ijrt.next)), result => {\r\n            types = types.concat(result.injected || []);\r\n            return result.next && result.next.length > 0;\r\n        }, { injected: [], next: modules }).catch(err => []);\r\n        return types;\r\n    }\r\n\r\n    syncInject(container: IContainer, modules: Type<any>[]): Type<any>[] {\r\n        let types: Type<any>[] = [];\r\n        let completed = false;\r\n        this.injectors.forEach(jtor => {\r\n            if (completed) {\r\n                return false;\r\n            }\r\n            if (jtor instanceof SyncModuleInjector) {\r\n                let result = jtor.inject(container, modules);\r\n                types = types.concat(result.injected);\r\n                completed = (!result.next || result.next.length < 1);\r\n            }\r\n            return true;\r\n        });\r\n        return types;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ModuleInjectorChain\",\"params\":{\"constructor\":[],\"first\":[\"injector\"],\"next\":[\"injector\"],\"isInjector\":[\"injector\"],\"inject\":[\"container\",\"modules\"],\"syncInject\":[\"container\",\"modules\"]}};\n                   }\r\n\r\n","export * from './IModuleLoader';\r\nexport * from './DefaultModuleLoader';\r\nexport * from './IModuleValidate';\r\nexport * from './ModuleValidate';\r\nexport * from './IMetaAccessor';\r\nexport * from './MetaAccessor';\r\nexport * from './IModuleInjector';\r\nexport * from './ModuleInjector';\r\nexport * from './IModuleInjectorChain';\r\nexport * from './ModuleInjectorChain';\r\n","import { IContainer } from './IContainer';\r\nimport { Container } from './Container';\r\nimport { Type, Modules, LoadType, Express } from './types';\r\nimport { IContainerBuilder, ContainerBuilderToken } from './IContainerBuilder';\r\nimport { IModuleLoader, ModuleLoaderToken, DefaultModuleLoader, IModuleInjectorChain, ModuleInjectorChainToken, SyncModuleInjector, IocExtModuleValidateToken, SyncModuleInjectorToken, ModuleInjector, IocExtModuleValidate, ModuleInjectorChain, MetaAccessor, AnnotationMetaAccessor } from './injectors';\r\nimport { PromiseUtil } from './utils';\r\n\r\n/**\r\n * default container builder.\r\n *\r\n * @export\r\n * @class DefaultContainerBuilder\r\n * @implements {IContainerBuilder}\r\n */\r\nexport class DefaultContainerBuilder implements IContainerBuilder {\r\n\r\n    private _loader: IModuleLoader;\r\n    filter: Express<Type<any>, boolean>;\r\n    constructor(loader?: IModuleLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    get loader(): IModuleLoader {\r\n        if (!this._loader) {\r\n            this._loader = new DefaultModuleLoader();\r\n        }\r\n\r\n        return this._loader;\r\n    }\r\n\r\n\r\n    create(): IContainer {\r\n        let container = new Container();\r\n        container.bindProvider(ContainerBuilderToken, () => this);\r\n        container.bindProvider(ModuleLoaderToken, () => this.loader);\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * build container.\r\n     *\r\n     * @param {...LoadType[]} [modules]\r\n     * @returns\r\n     * @memberof DefaultContainerBuilder\r\n     */\r\n    async build(...modules: LoadType[]) {\r\n        let container: IContainer = this.create();\r\n        if (modules.length) {\r\n            await this.loadModule(container, ...modules);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    /**\r\n     * load modules for container.\r\n     *\r\n     * @param {IContainer} container\r\n     * @param {...LoadType[]} modules\r\n     * @returns {Promise<Type<any>[]>}\r\n     * @memberof DefaultContainerBuilder\r\n     */\r\n    async loadModule(container: IContainer, ...modules: LoadType[]): Promise<Type<any>[]> {\r\n        let regModules = await this.loader.loadTypes(modules);\r\n        let injTypes = [];\r\n        if (regModules && regModules.length) {\r\n            let injChain = this.getInjectorChain(container);\r\n            await PromiseUtil.step(regModules.map(async typs => {\r\n                let ityps = await injChain.inject(container, typs);\r\n                injTypes = injTypes.concat(ityps);\r\n            }));\r\n        }\r\n        return injTypes;\r\n    }\r\n\r\n\r\n    syncBuild(...modules: Modules[]): IContainer {\r\n        let container: IContainer = this.create();\r\n        if (modules.length) {\r\n            this.syncLoadModule(container, ...modules);\r\n        }\r\n        return container;\r\n    }\r\n\r\n    syncLoadModule(container: IContainer, ...modules: Modules[]) {\r\n        let regModules = this.loader.getTypes(modules);\r\n        let injTypes = [];\r\n        if (regModules && regModules.length) {\r\n            let injChain = this.getInjectorChain(container);\r\n            regModules.forEach(typs => {\r\n                let ityps = injChain.syncInject(container, typs);\r\n                injTypes = injTypes.concat(ityps);\r\n            });\r\n        }\r\n        return injTypes;\r\n    }\r\n\r\n    protected injectorChain: IModuleInjectorChain;\r\n    getInjectorChain(container: IContainer): IModuleInjectorChain {\r\n        if (!container.has(ModuleInjectorChainToken)) {\r\n            container.register(SyncModuleInjector)\r\n                .register(ModuleInjector)\r\n                .register(MetaAccessor)\r\n                .register(AnnotationMetaAccessor)\r\n                .bindProvider(IocExtModuleValidateToken, new IocExtModuleValidate())\r\n                .bindProvider(ModuleInjectorChainToken, new ModuleInjectorChain())\r\n        }\r\n        let currChain = container.get(ModuleInjectorChainToken);\r\n        if (this.injectorChain !== currChain) {\r\n            this.injectorChain = null;\r\n        }\r\n        if (!this.injectorChain) {\r\n            this.injectorChain = currChain;\r\n            this.injectorChain\r\n                .next(container.resolve(SyncModuleInjectorToken, { validate: container.get(IocExtModuleValidateToken), skipNext: true }))\r\n                .next(container.resolve(SyncModuleInjectorToken));\r\n        }\r\n\r\n        return this.injectorChain;\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"DefaultContainerBuilder\",\"params\":{\"constructor\":[\"loader\"],\"create\":[],\"build\":[\"modules\"],\"loadModule\":[\"container\",\"modules\"],\"syncBuild\":[\"modules\"],\"syncLoadModule\":[\"container\",\"modules\"],\"getInjectorChain\":[\"container\"]}};\n                   }\r\n","export * from './IResolver';\r\nexport * from './IContainer';\r\nexport * from './Container';\r\n\r\nexport * from './types';\r\nexport * from './Registration';\r\nexport * from './InjectToken';\r\nexport * from './IContainerBuilder';\r\nexport * from './IParameter';\r\nexport * from './IMethodAccessor';\r\nexport * from './ICacheManager';\r\n\r\nexport * from './LifeScope';\r\n\r\n\r\n\r\nexport * from './DefaultContainerBuilder';\r\n\r\nexport * from './utils';\r\nexport * from './components';\r\nexport * from './core';\r\nexport * from './injectors';\r\nexport * from './resolves';\r\n\r\n"],"names":["typeCheck_1","objAssign","utils_1","types_1","components_1","NullAction_1","DecoratorFactory_1","factories_1","ICacheManager_1","decorators_1","decorators","actions_1","actions","types","providers","providers_1","IProviderMatcher_1","LifeScope_1","core_1","resolves_1","IMethodAccessor_1","IContainerBuilder_1","IContainer_1","require","IMetaAccessor_1","IModuleValidate_1","IModuleInjector_1","injectors_1"],"mappings":"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"}