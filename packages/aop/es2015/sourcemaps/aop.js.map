{"version":3,"file":"../aop.js","sources":["actions/actions/AopActions.ts","IAdvisor.ts","actions/actions/RegistAspectAction.ts","decorators/decorators/Advice.ts","decorators/decorators/Aspect.ts","decorators/decorators/After.ts","decorators/decorators/AfterReturning.ts","decorators/decorators/AfterThrowing.ts","decorators/decorators/Around.ts","decorators/decorators/Before.ts","decorators/decorators/Pointcut.ts","decorators/decorators/NonePointcut.ts","decorators/decorators/index.ts","isValideAspectTarget.ts","access/access/IAdvisorChainFactory.ts","joinpoints/joinpoints/JoinpointState.ts","joinpoints/joinpoints/IJoinpoint.ts","joinpoints/joinpoints/Joinpoint.ts","joinpoints/joinpoints/index.ts","access/access/IAdvisorChain.ts","access/access/AdvisorChainFactory.ts","access/access/IAdvisorProceeding.ts","access/access/AdvisorChain.ts","access/access/IProxyMethod.ts","access/access/ProxyMethod.ts","access/access/ReturningType.ts","access/access/AsyncPromiseProceeding.ts","access/access/AsyncObservableProceeding.ts","access/access/ReturningRecognizer.ts","access/access/SyncProceeding.ts","access/access/index.ts","actions/actions/BindMethodPointcutAction.ts","actions/actions/InvokeBeforeConstructorAction.ts","actions/actions/InvokeAfterConstructorAction.ts","IAdviceMatcher.ts","actions/actions/MatchPointcutAction.ts","actions/actions/AopActionFactory.ts","actions/actions/ExetndsInstanceAction.ts","actions/actions/index.ts","Advisor.ts","AdviceMatcher.ts","AopModule.ts","index.ts"],"sourcesContent":["\r\n/**\r\n * aop actions.\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum AopActions {\r\n\r\n    /**\r\n     * register aspect service.\r\n     */\r\n    registAspect = 'registAspect',\r\n\r\n    /**\r\n     * extends intstance.\r\n     */\r\n    exetndsInstance = 'exetndsInstance',\r\n    /**\r\n     * match pointcut.\r\n     */\r\n    matchPointcut = 'matchPointcut',\r\n    /**\r\n     * bind property pointcut.\r\n     */\r\n    bindPropertyPointcut = 'bindPropertyPointcut',\r\n    /**\r\n     * bind method pointcut for instance.\r\n     */\r\n    bindMethodPointcut = 'bindMethodPointcut',\r\n\r\n    invokeBeforeConstructorAdvices = 'invokeBeforeConstructorAdvices',\r\n\r\n    invokeAfterConstructorAdvices = 'invokeAfterConstructorAdvices'\r\n\r\n}\r\n","import { AdviceMetadata } from './metadatas';\r\nimport { Type, ObjectMap, MapSet, InjectToken, IContainer, Providers } from '@ts-ioc/core';\r\nimport { Advices } from './advices';\r\n\r\n/**\r\n * Aop IAdvisor interface token.\r\n * it is a token id, you can register yourself IAdvisor for this.\r\n */\r\nexport const AdvisorToken = new InjectToken<IAdvisor>('DI_IAdvisor');\r\n\r\n/**\r\n * aspect and advices manager.\r\n *\r\n * @export\r\n * @interface IAdvisor\r\n */\r\nexport interface IAdvisor {\r\n    /**\r\n     * aspects\r\n     *\r\n     * @type {MapSet<Type<any>, ObjectMap<AdviceMetadata[]>>}\r\n     * @memberof IAdvisor\r\n     */\r\n    aspects: MapSet<Type<any>, ObjectMap<AdviceMetadata[]>>;\r\n    /**\r\n     * advices\r\n     *\r\n     * @type {MapSet<string, Advices>}\r\n     * @memberof IAdvisor\r\n     */\r\n    advices: MapSet<string, Advices>;\r\n\r\n    /**\r\n     * has register advices or not.\r\n     *\r\n     * @param {Type<any>} targetType\r\n     * @returns {boolean}\r\n     * @memberof IAdvisor\r\n     */\r\n    hasRegisterAdvices(targetType: Type<any>): boolean;\r\n    /**\r\n     * set advices.\r\n     *\r\n     * @param {string} key\r\n     * @param {Advices} advices\r\n     * @memberof IAdvisor\r\n     */\r\n    setAdvices(key: string, advices: Advices);\r\n    /**\r\n     * get advices.\r\n     *\r\n     * @param {string} key\r\n     * @returns {Advices}\r\n     * @memberof IAdvisor\r\n     */\r\n    getAdvices(key: string): Advices;\r\n\r\n    /**\r\n     * add aspect.\r\n     *\r\n     * @param {Type<any>} aspect\r\n     * @param {IContainer} raiseContainer\r\n     * @memberof IAdvisor\r\n     */\r\n    add(aspect: Type<any>, raiseContainer: IContainer);\r\n\r\n    /**\r\n     * get aspect registered container.\r\n     *\r\n     * @param {Type<any>} aspect\r\n     * @param {IContainer} [defaultContainer]\r\n     * @returns {IContainer}\r\n     * @memberof IAdvisor\r\n     */\r\n    getContainer(aspect: Type<any>, defaultContainer?: IContainer): IContainer;\r\n\r\n    /**\r\n     * resolve aspect.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} aspect\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof IAdvisor\r\n     */\r\n    resolve<T>(aspect: Type<T>, ...providers: Providers[]): T;\r\n}\r\n","import {\r\n    IContainer, ActionData, ClassMetadata,\r\n    ActionComposite, hasOwnClassMetadata, getOwnTypeMetadata, isClass\r\n} from '@ts-ioc/core';\r\nimport { IAdvisor, AdvisorToken } from '../IAdvisor';\r\nimport { AopActions } from './AopActions';\r\n\r\n/**\r\n * regist aspect action data.\r\n *\r\n * @export\r\n * @interface RegistAspectActionData\r\n * @extends {ActionData<ClassMetadata>}\r\n */\r\nexport interface RegistAspectActionData extends ActionData<ClassMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * regist aspect action.\r\n *\r\n * @export\r\n * @class RegistAspectAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class RegistAspectAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.registAspect);\r\n    }\r\n\r\n    protected working(container: IContainer, data: RegistAspectActionData) {\r\n        let type = data.targetType;\r\n        let lifeScope = container.getLifeScope();\r\n        let matchs = lifeScope.getClassDecorators(surm => surm.actions.includes(AopActions.registAspect) && hasOwnClassMetadata(surm.name, type));\r\n        let aspectMgr = container.get<IAdvisor>(AdvisorToken);\r\n        let raiseContainer = data.raiseContainer || container;\r\n        matchs.forEach(surm => {\r\n            let metadata = getOwnTypeMetadata<ClassMetadata>(surm.name, type);\r\n            if (Array.isArray(metadata) && metadata.length > 0) {\r\n                metadata.forEach(meta => {\r\n                    if (isClass(meta.type)) {\r\n                        aspectMgr.add(meta.type, raiseContainer);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"RegistAspectAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","\r\nimport { createMethodDecorator, IMethodDecorator, MetadataAdapter, MetadataExtends, isString, isRegExp  } from '@ts-ioc/core';\r\nimport { AdviceMetadata } from '../metadatas';\r\n\r\n/**\r\n * advice decorator for method.\r\n *\r\n * @export\r\n * @interface IAdviceDecorator\r\n * @extends {IMethodDecorator<T>}\r\n * @template T\r\n */\r\nexport interface IAdviceDecorator<T extends AdviceMetadata> extends IMethodDecorator<T> {\r\n    /**\r\n     * define advice with params.\r\n     *\r\n     * ### Usage\r\n     * - path or module name, match express.\r\n     *  - `execution(moduelName.*.*(..)) || @annotation(DecortorName) || @within(ClassName)`\r\n     *  - `execution(moduelName.*.*(..)) && @annotation(DecortorName) && @within(ClassName)`\r\n     *\r\n     * ```\r\n     * @Aspect()\r\n     * class AspectClass {\r\n     *   @Advice('\"execution(moduelName.*.*(..)\")')\r\n     *   process(joinPoint: JointPoint){\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * - match method with a decorator annotation.\r\n     *\r\n     * ```\r\n     * @Aspect()\r\n     * class AspectClass {\r\n     *   @Advice('@annotation(DecoratorName)')\r\n     *   process(joinPoint: JointPoint){\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @param {(string | RegExp)} [pointcut] define advice match express for pointcut.\r\n     * @param { string } [annotation] annotation name, special annotation metadata for annotation advices.\r\n     */\r\n    (pointcut?: string | RegExp, annotation?: string): MethodDecorator;\r\n\r\n    /**\r\n     * define advice with metadata map.\r\n     * @param {T} [metadata]\r\n     */\r\n    (metadata?: T): MethodDecorator;\r\n}\r\n\r\nexport function createAdviceDecorator<T extends AdviceMetadata>(adviceName: string,\r\n    adapter?: MetadataAdapter,\r\n    afterPointcutAdapter?: MetadataAdapter,\r\n    metadataExtends?: MetadataExtends<T>): IAdviceDecorator<T> {\r\n\r\n    return createMethodDecorator<AdviceMetadata>('Advice',\r\n        args => {\r\n            if (adapter) {\r\n                adapter(args);\r\n            }\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg) || isRegExp(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.pointcut = arg;\r\n                }\r\n            });\r\n            if (afterPointcutAdapter) {\r\n                afterPointcutAdapter(args);\r\n            }\r\n\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.annotationArgName = arg;\r\n                }\r\n            });\r\n\r\n            args.next<AdviceMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.annotationName = arg;\r\n                }\r\n            });\r\n        },\r\n        metadata => {\r\n            if (metadataExtends) {\r\n                metadata = metadataExtends(metadata as T);\r\n            }\r\n            metadata.adviceName = adviceName;\r\n            return metadata;\r\n        }) as IAdviceDecorator<T>;\r\n}\r\n\r\n/**\r\n * aop advice decorator.\r\n *\r\n * @Advice\r\n */\r\nexport const Advice: IAdviceDecorator<AdviceMetadata> = createAdviceDecorator('Advice');\r\n","import { createClassDecorator, ITypeDecorator, Registration, Type, isString, isClass, isArray } from '@ts-ioc/core';\r\nimport { AspectMetadata } from '../metadatas';\r\n\r\n/**\r\n * Aspect decorator\r\n *\r\n * @export\r\n * @interface IAspectDecorator\r\n * @extends {ITypeDecorator<AspectMetadata>}\r\n */\r\nexport interface IAspectDecorator extends ITypeDecorator<AspectMetadata> {\r\n    /**\r\n     * Aspect decorator, define for class.  use to define class as aspect. it can setting provider to some token, singleton or not.\r\n     *\r\n     * @Aspect\r\n     *\r\n     * @param {string} annotation set pointcut in the class with the annotation decorator only.\r\n     * @param {(Type<any> | Type<any>[])>} [within]  set pointcut in the class with the annotation decorator only.\r\n     * @param {(Registration<any> | symbol | string)} [provide] define this class provider for provide.\r\n     * @param {string} [alias] define this class provider with alias for provide.\r\n     * @param {boolean} [singlton] define this class as singlton.\r\n     * @param {number} [cache]  define class cahce expris when is not singlton.\r\n     */\r\n    (annotation: string, within?: Type<any> | Type<any>[], provide?: Registration<any> | symbol | string, alias?: string, singlton?: boolean, cache?: number): ClassDecorator;\r\n\r\n    /**\r\n     * Aspect decorator, define for class.  use to define the class. it can setting provider to some token, singleton or not.\r\n     *\r\n     * @Aspect\r\n     *\r\n     * @param {AspectMetadata} [metadata] metadata map.\r\n     */\r\n    (metadata?: AspectMetadata): ClassDecorator;\r\n}\r\n\r\n\r\n/**\r\n * Aspect decorator. define aspect service.\r\n *\r\n * @Aspect\r\n */\r\nexport const Aspect: IAspectDecorator = createClassDecorator<AspectMetadata>('Aspect', args => {\r\n    args.next<AspectMetadata>({\r\n        match: (arg) => isString(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.annotation = arg;\r\n        }\r\n    });\r\n\r\n    args.next<AspectMetadata>({\r\n        match: (arg) => isArray(arg) || isClass(arg),\r\n        setMetadata: (metadata, arg) => {\r\n            metadata.within = arg;\r\n        }\r\n    });\r\n}) as IAspectDecorator;\r\n\r\n","import { AdviceMetadata } from '../metadatas';\r\nimport { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\n\r\n/**\r\n * aop after advice decorator.\r\n *\r\n * @After\r\n */\r\nexport const After: IAdviceDecorator<AdviceMetadata> = createAdviceDecorator<AdviceMetadata>('After') as IAdviceDecorator<AdviceMetadata>;\r\n","import { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\nimport { AfterReturningMetadata } from '../metadatas';\r\nimport { isString } from '@ts-ioc/core';\r\n\r\n/**\r\n * aop after returning decorator.\r\n *\r\n * @export\r\n * @interface IAfterReturningDecorator\r\n * @extends {IAdviceDecorator<T>}\r\n * @template T\r\n */\r\nexport interface IAfterReturningDecorator<T extends AfterReturningMetadata> extends IAdviceDecorator<T> {\r\n    /**\r\n     * define aop after returning advice.\r\n     *\r\n     * @param {(string | RegExp)} [pointcut] define advice match express for pointcut.\r\n     * @param {string} [returning] set name provider of pointcut returing data for advices.\r\n     * @param { string } [annotation] annotation name, special annotation metadata for annotation advices.\r\n     */\r\n    (pointcut?: string | RegExp, returning?: string, annotation?: string): MethodDecorator;\r\n}\r\n\r\n/**\r\n * aop after returning advice decorator.\r\n *\r\n * @AfterReturning\r\n */\r\nexport const AfterReturning: IAfterReturningDecorator<AfterReturningMetadata> =\r\n    createAdviceDecorator<AfterReturningMetadata>(\r\n        'AfterReturning',\r\n        null,\r\n        args => {\r\n            args.next<AfterReturningMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.returning = arg;\r\n                }\r\n            })\r\n        }\r\n    ) as IAfterReturningDecorator<AfterReturningMetadata>;\r\n","import { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\nimport { isString } from '@ts-ioc/core';\r\nimport { AfterThrowingMetadata } from '../metadatas';\r\n\r\n/**\r\n * aop after throwing decorator.\r\n *\r\n * @export\r\n * @interface IAfterThrowingDecorator\r\n * @extends {IAdviceDecorator<T>}\r\n * @template T\r\n */\r\nexport interface IAfterThrowingDecorator<T extends AfterThrowingMetadata> extends IAdviceDecorator<T> {\r\n    /**\r\n     * define aop after throwing advice.\r\n     *\r\n     * @param {(string | RegExp)} [pointcut] define advice match express for pointcut.\r\n     * @param {string} [throwing] set name provider of pointcut throwing error for advices.\r\n     * @param { string } [annotation] annotation name, special annotation metadata for annotation advices.\r\n     */\r\n    (pointcut?: string | RegExp, throwing?: string, annotation?: string): MethodDecorator\r\n}\r\n\r\n/**\r\n * aop after throwing advice decorator.\r\n *\r\n * @AfterThrowing\r\n */\r\nexport const AfterThrowing: IAfterThrowingDecorator<AfterThrowingMetadata> =\r\n    createAdviceDecorator<AfterThrowingMetadata>(\r\n        'AfterThrowing',\r\n        null,\r\n        args => {\r\n            args.next<AfterThrowingMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.throwing = arg;\r\n                }\r\n            })\r\n        }\r\n    ) as IAfterThrowingDecorator<AfterThrowingMetadata>;\r\n","import { AroundMetadata } from '../metadatas';\r\nimport { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\nimport { isString } from '@ts-ioc/core';\r\n\r\n/**\r\n * aop around decorator.\r\n *\r\n * @export\r\n * @interface IAroundDecorator\r\n * @extends {IAdviceDecorator<T>}\r\n * @template T\r\n */\r\nexport interface IAroundDecorator<T extends AroundMetadata> extends IAdviceDecorator<T> {\r\n    /**\r\n     * define aop around advice.\r\n     *\r\n     * @param {(string | RegExp)} [pointcut] define advice match express for pointcut.\r\n     * @param {string} [returning] set name provider of pointcut returing data for advices.\r\n     * @param {string} [throwing] set name provider of pointcut throwing error for advices.\r\n     * @param {string} [annotation] annotation name, special annotation metadata for annotation advices.\r\n     */\r\n    (pointcut?: string | RegExp, args?: string, returning?: string, throwing?: string, annotation?: string): MethodDecorator\r\n}\r\n\r\n/**\r\n * aop Around advice decorator.\r\n *\r\n * @Around\r\n */\r\nexport const Around: IAroundDecorator<AroundMetadata> =\r\n    createAdviceDecorator<AroundMetadata>(\r\n        'Around',\r\n        null,\r\n        args => {\r\n            args.next<AroundMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.args = arg;\r\n                }\r\n            });\r\n\r\n            args.next<AroundMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.returning = arg;\r\n                }\r\n            });\r\n\r\n            args.next<AroundMetadata>({\r\n                match: (arg) => isString(arg),\r\n                setMetadata: (metadata, arg) => {\r\n                    metadata.throwing = arg;\r\n                }\r\n            });\r\n        }) as IAroundDecorator<AroundMetadata>;\r\n","import { AdviceMetadata } from '../metadatas';\r\nimport { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\n\r\n/**\r\n * aop Before advice decorator.\r\n *\r\n * @Before\r\n */\r\nexport const Before: IAdviceDecorator<AdviceMetadata> = createAdviceDecorator<AdviceMetadata>('Before') as IAdviceDecorator<AdviceMetadata>;\r\n","import { AdviceMetadata } from '../metadatas';\r\nimport { IAdviceDecorator, createAdviceDecorator } from './Advice';\r\n\r\n/**\r\n * aop Pointcut advice decorator.\r\n *\r\n * @Pointcut\r\n */\r\nexport const Pointcut: IAdviceDecorator<AdviceMetadata> =\r\n    createAdviceDecorator<AdviceMetadata>('Pointcut') as IAdviceDecorator<AdviceMetadata>;\r\n","import { createClassDecorator, ClassMetadata, ITypeDecorator, Type } from '@ts-ioc/core';\r\n\r\nexport interface INonePointcutDecorator extends ITypeDecorator<ClassMetadata> {\r\n    /**\r\n     * NonePointcut decorator, define class not work with aop.\r\n     *\r\n     * @NonePointcut\r\n     *\r\n     */\r\n    (): ClassDecorator;\r\n    /**\r\n     * NonePointcut decorator, define class not work with aop.\r\n     *\r\n     * @NonePointcut\r\n     */\r\n    (target: Type<any>): void;\r\n}\r\n\r\n/**\r\n * NonePointcut decorator, define class not work with aop.\r\n *\r\n * @NonePointcut\r\n */\r\nexport const NonePointcut: INonePointcutDecorator = createClassDecorator<ClassMetadata>('NonePointcut');\r\n","export * from './Advice';\r\nexport * from './Aspect';\r\nexport * from './After';\r\nexport * from './AfterReturning';\r\nexport * from './AfterThrowing';\r\nexport * from './Around';\r\nexport * from './Before';\r\nexport * from './Pointcut';\r\nexport * from './NonePointcut';\r\n\r\n","import { Type, hasOwnClassMetadata, isClass } from '@ts-ioc/core';\r\nimport { NonePointcut } from './decorators';\r\n\r\n/**\r\n * is target can aspect or not.\r\n *\r\n * @export\r\n * @param {Type<any>} targetType\r\n * @returns {boolean}\r\n */\r\nexport function isValideAspectTarget(targetType: Type<any>): boolean {\r\n\r\n    if (!isClass(targetType)\r\n        || targetType === Object\r\n        || targetType === String\r\n        || targetType === Date\r\n        || targetType === Boolean\r\n        || targetType === Number) {\r\n        return false;\r\n    }\r\n\r\n\r\n    if (hasOwnClassMetadata(NonePointcut, targetType)) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n","import { Joinpoint, JoinpointState } from '../joinpoints';\r\nimport { Advicer } from '../advices';\r\nimport { InjectToken } from '@ts-ioc/core';\r\n\r\n\r\n/**\r\n * Aop IAdvisorChainFactory interface token.\r\n * it is a token id, you can register yourself IAdvisorChainFactory for this.\r\n */\r\nexport const AdvisorChainFactoryToken = new InjectToken<IAdvisorChainFactory>('DI_IAdvisorChainFactory');\r\n\r\n/**\r\n * advice advisor chain factory for proxy method invoke.\r\n *\r\n * @export\r\n * @interface IAdvisorChainFactory\r\n */\r\nexport interface IAdvisorChainFactory {\r\n\r\n    /**\r\n     * get advices config.\r\n     *\r\n     * @param {string} adviceType\r\n     * @returns {Advicer[]}\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    getAdvicers(adviceType: string): Advicer[];\r\n\r\n    /**\r\n     * invoke advives via state.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @param {JoinpointState} state\r\n     * @param {*} [valueOrthrowing]\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    invoaction(joinPoint: Joinpoint, state: JoinpointState, valueOrthrowing?: any): void;\r\n\r\n    /**\r\n     * invoke before advices.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    before(joinPoint: Joinpoint): void;\r\n\r\n    /**\r\n     * invoke pointcut advives.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    pointcut(joinPoint: Joinpoint): void;\r\n\r\n    /**\r\n     * invoke after advives.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    after(joinPoint: Joinpoint): void;\r\n\r\n    /**\r\n     * invoke throwing advives.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    afterThrowing(joinPoint: Joinpoint): void;\r\n\r\n    /**\r\n     * invoke returning advives.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @memberof IAdvisorChainFactory\r\n     */\r\n    afterReturning(joinPoint: Joinpoint): void;\r\n}\r\n","export enum JoinpointState {\r\n    Before = 'Before',\r\n    Pointcut = 'Pointcut',\r\n    After = 'After',\r\n    AfterReturning = 'AfterReturning',\r\n    AfterThrowing = 'AfterThrowing'\r\n}\r\n","import { IPointcut } from './IPointcut';\r\nimport { JoinpointState } from './JoinpointState';\r\nimport { Advicer } from '../advices';\r\nimport { IParameter, MethodMetadata, Type, InjectToken } from '@ts-ioc/core';\r\n\r\n /**\r\n * Aop IJoinpoint interface token.\r\n * it is a token id, you can register yourself IJoinpoint for this.\r\n */\r\nexport const JoinpointToken = new InjectToken<IJoinpoint>('DI_IJoinpoint');\r\n\r\n/**\r\n * Joinpoint interface\r\n *\r\n * @export\r\n * @interface IJoinpoint\r\n * @extends {IPointcut}\r\n */\r\nexport interface IJoinpoint extends IPointcut {\r\n\r\n    /**\r\n     * prov joinpoint.\r\n     *\r\n     * @type {IJoinpoint}\r\n     * @memberof Joinpoint\r\n     */\r\n    provJoinpoint: IJoinpoint;\r\n\r\n    /**\r\n    * join point state.\r\n    *\r\n    * @type {JoinpointState}\r\n    * @memberof IJoinpoint\r\n    */\r\n    state: JoinpointState;\r\n    /**\r\n     * params of pointcut.\r\n     *\r\n     * @type {IParameter[]}\r\n     * @memberof IJoinpoint\r\n     */\r\n    params: IParameter[];\r\n    /**\r\n     * args of pointcut.\r\n     *\r\n     * @type {any[]}\r\n     * @memberof IJoinpoint\r\n     */\r\n    args: any[];\r\n    /**\r\n     * pointcut returing data\r\n     *\r\n     * @type {*}\r\n     * @memberof IJoinpoint\r\n     */\r\n    returning?: any;\r\n\r\n    /**\r\n     * the result value of returing.\r\n     *\r\n     * @type {*}\r\n     * @memberof Joinpoint\r\n     */\r\n    returningValue?: any;\r\n\r\n    /**\r\n     * pointcut throwing error.\r\n     *\r\n     * @type {*}\r\n     * @memberof IJoinpoint\r\n     */\r\n    throwing?: any;\r\n\r\n    /**\r\n     * Advicer of joinpoint.\r\n     *\r\n     * @type {Advicer}\r\n     * @memberof IJoinpoint\r\n     */\r\n    advicer: Advicer;\r\n\r\n    /**\r\n     * orgin pointcut method metadatas.\r\n     *\r\n     * @type {MethodMetadata[]}\r\n     * @memberof IJoinpoint\r\n     */\r\n    annotations: MethodMetadata[];\r\n\r\n    /**\r\n     * pointcut target instance\r\n     *\r\n     * @type {*}\r\n     * @memberof IJoinpoint\r\n     */\r\n    target: any;\r\n    /**\r\n     * pointcut target type.\r\n     *\r\n     * @type {Token<any>}\r\n     * @memberof IJoinpoint\r\n     */\r\n    targetType: Type<any>;\r\n\r\n}\r\n","import { IJoinpoint, JoinpointToken } from './IJoinpoint';\r\nimport { Type, Injectable, MethodMetadata, IParameter } from '@ts-ioc/core';\r\nimport { JoinpointState } from './JoinpointState';\r\nimport { Advicer } from '../advices';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n/**\r\n * Join point data.\r\n *\r\n * @export\r\n * @class Joinpoint\r\n * @implements {IJoinpoint}\r\n */\r\n@Injectable(JoinpointToken)\r\n@NonePointcut()\r\nexport class Joinpoint implements IJoinpoint {\r\n    /**\r\n     * method name\r\n     *\r\n     * @type {string}\r\n     * @memberof Joinpoint\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * prov joinpoint.\r\n     *\r\n     * @type {IJoinpoint}\r\n     * @memberof Joinpoint\r\n     */\r\n    provJoinpoint: IJoinpoint;\r\n    /**\r\n     * full name.\r\n     *\r\n     * @type {string}\r\n     * @memberof Joinpoint\r\n     */\r\n    fullName: string;\r\n    /**\r\n     * join point state.\r\n     *\r\n     * @type {JoinpointState}\r\n     * @memberof Joinpoint\r\n     */\r\n    state: JoinpointState;\r\n    /**\r\n     * params of pointcut.\r\n     *\r\n     * @type {IParameter[]}\r\n     * @memberof Joinpoint\r\n     */\r\n    params: IParameter[];\r\n    /**\r\n     * args of pointcut.\r\n     *\r\n     * @type {any[]}\r\n     * @memberof Joinpoint\r\n     */\r\n    args: any[];\r\n    /**\r\n     * pointcut returing\r\n     *\r\n     * @type {*}\r\n     * @memberof Joinpoint\r\n     */\r\n    returning?: any;\r\n\r\n    /**\r\n     * the result value of returing.\r\n     *\r\n     * @type {*}\r\n     * @memberof Joinpoint\r\n     */\r\n    returningValue?: any;\r\n\r\n    /**\r\n     * pointcut throwing error.\r\n     *\r\n     * @type {*}\r\n     * @memberof Joinpoint\r\n     */\r\n    throwing?: any;\r\n\r\n    /**\r\n     * advicer of joinpoint\r\n     *\r\n     * @type {Advicer}\r\n     * @memberof Joinpoint\r\n     */\r\n    advicer: Advicer;\r\n\r\n    /**\r\n     * orgin pointcut method metadatas.\r\n     *\r\n     * @type {MethodMetadata[]}\r\n     * @memberof Joinpoint\r\n     */\r\n    annotations: MethodMetadata[];\r\n\r\n    /**\r\n     * pointcut target instance\r\n     *\r\n     * @type {*}\r\n     * @memberof Joinpoint\r\n     */\r\n    target: any;\r\n    /**\r\n     * pointcut target type.\r\n     *\r\n     * @type {Type<any>}\r\n     * @memberof Joinpoint\r\n     */\r\n    targetType: Type<any>;\r\n\r\n\r\n    constructor(options: IJoinpoint) {\r\n        this.provJoinpoint = options.provJoinpoint;\r\n        this.name = options.name;\r\n        this.fullName = options.fullName;\r\n        this.params = options.params || [];\r\n        this.args = options.args;\r\n        this.returning = options.returning;\r\n        this.throwing = options.throwing;\r\n        this.state = options.state;\r\n        this.advicer = options.advicer;\r\n        this.annotations = options.annotations;\r\n        this.target = options.target;\r\n        this.targetType = options.targetType;\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"Joinpoint\",\"params\":{\"constructor\":[\"options\"]}};\n                   }\r\n","export * from './JoinpointState';\r\nexport * from './IPointcut';\r\nexport * from './IJoinpoint';\r\nexport * from './Joinpoint';\r\nexport * from './MatchPointcut';\r\n","import { Joinpoint } from '../joinpoints';\r\nimport { Express, IRecognizer, InjectToken } from '@ts-ioc/core';\r\n\r\n/**\r\n * Aop IAdvisorChain interface token.\r\n * it is a token id, you can register yourself IAdvisorChain for this.\r\n */\r\nexport const AdvisorChainToken = new InjectToken<IAdvisorChain>('DI_IAdvisorChain');\r\n\r\n/**\r\n * advisor chain.\r\n *\r\n * @export\r\n * @interface IAdvisorChain\r\n */\r\nexport interface IAdvisorChain {\r\n    /**\r\n     * register next step of chain.\r\n     *\r\n     * @param {Express<Joinpoint, any>} action\r\n     * @memberof IAdvisorChain\r\n     */\r\n    next(action: Express<Joinpoint, any>);\r\n    /**\r\n     * get Recognizer of the chain, to recognize the vaule is special alias for registor to container.\r\n     *\r\n     * @returns {IRecognizer}\r\n     * @memberof IAdvisorChain\r\n     */\r\n    getRecognizer(): IRecognizer;\r\n    /**\r\n     * run chain process.\r\n     *\r\n     * @memberof IAdvisorChain\r\n     */\r\n    process(): void;\r\n}\r\n","import { IContainer, Provider, Injectable, Inject, isUndefined, isArray, lang, ContainerToken } from '@ts-ioc/core';\r\nimport { Joinpoint, JoinpointState } from '../joinpoints';\r\nimport { Advicer, Advices } from '../advices';\r\nimport { IAdvisorChainFactory, AdvisorChainFactoryToken } from './IAdvisorChainFactory';\r\nimport { IAdvisorChain, AdvisorChainToken } from './IAdvisorChain';\r\nimport { NonePointcut } from '../decorators';\r\nimport { IAdvisor, AdvisorToken } from '../IAdvisor';\r\n\r\n@NonePointcut()\r\n@Injectable(AdvisorChainFactoryToken)\r\nexport class AdvisorChainFactory implements IAdvisorChainFactory {\r\n\r\n    constructor(@Inject(ContainerToken) private container: IContainer, @Inject(AdvisorToken) private advisor: IAdvisor, private advices: Advices) {\r\n\r\n    }\r\n\r\n    getAdvicers(adviceType: string): Advicer[] {\r\n        return (adviceType ? this.advices[adviceType] : null) || [];\r\n    }\r\n\r\n    invoaction(joinPoint: Joinpoint, state: JoinpointState, valueOrthrowing?: any): void {\r\n        joinPoint.state = state;\r\n        joinPoint.returning = undefined;\r\n        joinPoint.throwing = undefined;\r\n\r\n        switch (state) {\r\n            case JoinpointState.Before:\r\n                this.before(joinPoint);\r\n                break;\r\n            case JoinpointState.Pointcut:\r\n                this.pointcut(joinPoint);\r\n                break;\r\n\r\n            case JoinpointState.After:\r\n                joinPoint.returning = valueOrthrowing;\r\n                this.after(joinPoint);\r\n                break;\r\n\r\n            case JoinpointState.AfterThrowing:\r\n                joinPoint.throwing = valueOrthrowing;\r\n                this.afterThrowing(joinPoint);\r\n                break;\r\n\r\n            case JoinpointState.AfterReturning:\r\n                joinPoint.returning = valueOrthrowing;\r\n                this.afterReturning(joinPoint);\r\n                break;\r\n        }\r\n    }\r\n\r\n    before(joinPoint: Joinpoint) {\r\n        let cloneJp = lang.assign({}, joinPoint);\r\n        this.getAdvicers('Around')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n        if (!isUndefined(cloneJp.args)) {\r\n            joinPoint.args = cloneJp.args;\r\n        }\r\n\r\n        this.getAdvicers('Before')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n    }\r\n\r\n    pointcut(joinPoint: Joinpoint) {\r\n        let cloneJp = lang.assign({}, joinPoint);\r\n        this.getAdvicers('Pointcut')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n        if (!isUndefined(cloneJp.args)) {\r\n            joinPoint.args = cloneJp.args;\r\n        }\r\n    }\r\n\r\n    after(joinPoint: Joinpoint) {\r\n        let cloneJp = lang.assign({}, joinPoint);\r\n        this.getAdvicers('Around')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n        this.getAdvicers('After')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n    }\r\n\r\n    afterThrowing(joinPoint: Joinpoint) {\r\n        let cloneJp = lang.assign({}, joinPoint);\r\n        this.getAdvicers('Around')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n\r\n        this.getAdvicers('AfterThrowing')\r\n            .forEach(advicer => {\r\n                this.invokeAdvice(cloneJp, advicer);\r\n            });\r\n    }\r\n\r\n    afterReturning(joinPoint: Joinpoint) {\r\n        let cloneJp = lang.assign({}, joinPoint);\r\n        let advChain = this.container.resolve<IAdvisorChain>(AdvisorChainToken, { joinPoint: cloneJp });\r\n        this.getAdvicers('Around')\r\n            .forEach(advicer => {\r\n                advChain.next((jp) => {\r\n                    return this.invokeAdvice(jp, advicer);\r\n                });\r\n            });\r\n\r\n        this.getAdvicers('AfterReturning')\r\n            .forEach(advicer => {\r\n                advChain.next(jp => {\r\n                    return this.invokeAdvice(jp, advicer);\r\n                });\r\n            });\r\n\r\n        advChain.next((jp) => {\r\n            if (!isUndefined(jp.returning)) {\r\n                joinPoint.returning = jp.returning;\r\n            }\r\n            return joinPoint;\r\n        });\r\n\r\n        advChain.process();\r\n\r\n    }\r\n\r\n    invokeAdvice(joinPoint: Joinpoint, advicer: Advicer) {\r\n        let providers = [];\r\n\r\n        providers.push(Provider.createExtends(Joinpoint, joinPoint, (inst, provider) => {\r\n            inst._cache_JoinPoint = provider.resolve(this.container);\r\n        }));\r\n\r\n        let metadata: any = advicer.advice;\r\n\r\n        if (!isUndefined(joinPoint.args) && metadata.args) {\r\n            providers.push(Provider.create(metadata.args, joinPoint.args))\r\n        }\r\n\r\n        if (metadata.annotationArgName) {\r\n            providers.push(Provider.create(\r\n                metadata.annotationArgName,\r\n                () => {\r\n                    let curj = joinPoint;\r\n                    let annotations = curj.annotations;\r\n                    while (!annotations && joinPoint.provJoinpoint) {\r\n                        curj = joinPoint.provJoinpoint;\r\n                        if (curj && curj.annotations) {\r\n                            annotations = curj.annotations;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (isArray(annotations)) {\r\n                        if (metadata.annotationName) {\r\n                            let d: string = metadata.annotationName;\r\n                            d = /^@/.test(d) ? d : `@${d}`;\r\n                            return annotations.filter(a => a.decorator === d);\r\n                        }\r\n                        return annotations;\r\n                    } else {\r\n                        return [];\r\n                    }\r\n                }\r\n            ));\r\n        }\r\n\r\n        if (!isUndefined(joinPoint.returning) && metadata.returning) {\r\n            providers.push(Provider.create(metadata.returning, joinPoint.returning))\r\n        }\r\n\r\n        if (!isUndefined(joinPoint.throwing) && metadata.throwing) {\r\n            providers.push(Provider.create(metadata.throwing, joinPoint.throwing));\r\n        }\r\n\r\n        return this.advisor.getContainer(advicer.aspectType, this.container).syncInvoke<any>(advicer.aspectType, advicer.advice.propertyKey, null, ...providers);\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AdvisorChainFactory\",\"params\":{\"constructor\":[\"container\",\"advisor\",\"advices\"],\"getAdvicers\":[\"adviceType\"],\"invoaction\":[\"joinPoint\",\"state\",\"valueOrthrowing\"],\"before\":[\"joinPoint\"],\"pointcut\":[\"joinPoint\"],\"after\":[\"joinPoint\"],\"afterThrowing\":[\"joinPoint\"],\"afterReturning\":[\"joinPoint\"],\"invokeAdvice\":[\"joinPoint\",\"advicer\"]}};\n                   }\r\n","import { Joinpoint } from '../joinpoints';\r\nimport { Express, InjectToken } from '@ts-ioc/core';\r\n\r\n\r\n/**\r\n * Aop IAdvisorProceeding interface token.\r\n * it is a token id, you can register yourself IAdvisorProceeding for this.\r\n */\r\nexport const AdvisorProceedingToken = new InjectToken<IAdvisorProceeding>('DI_IAdvisorProceeding');\r\n\r\n/**\r\n * advisor proceeding.\r\n *\r\n * @export\r\n * @interface IAdvisorProceeding\r\n */\r\nexport interface IAdvisorProceeding {\r\n    /**\r\n     * process.\r\n     *\r\n     * @param {Joinpoint} joinPoint\r\n     * @param {...Express<Joinpoint, any>[]} actions\r\n     * @memberof IAdvisorProceeding\r\n     */\r\n    proceeding(joinPoint: Joinpoint, ...actions: Express<Joinpoint, any>[])\r\n}\r\n","import { IContainer, Injectable, Inject, IRecognizer, Express, ContainerToken, RecognizerToken } from '@ts-ioc/core';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { IAdvisorChain, AdvisorChainToken } from './IAdvisorChain';\r\nimport { AdvisorProceedingToken } from './IAdvisorProceeding';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Injectable(AdvisorChainToken)\r\nexport class AdvisorChain implements IAdvisorChain {\r\n\r\n    @Inject(ContainerToken)\r\n    container: IContainer;\r\n\r\n    protected actions: Express<Joinpoint, any>[];\r\n\r\n    constructor(protected joinPoint: Joinpoint) {\r\n        this.actions = [];\r\n    }\r\n\r\n    next(action: Express<Joinpoint, any>) {\r\n        this.actions.push(action);\r\n    }\r\n\r\n    getRecognizer(): IRecognizer {\r\n        return this.container.get(RecognizerToken, this.joinPoint.state);\r\n    }\r\n\r\n    process(): void {\r\n        let alias = this.getRecognizer().recognize(this.joinPoint.returning);\r\n        this.container.get(AdvisorProceedingToken, alias)\r\n            .proceeding(this.joinPoint, ...this.actions);\r\n    }\r\n\r\n\n                        static classAnnations:any  = {\"name\":\"AdvisorChain\",\"params\":{\"constructor\":[\"joinPoint\"],\"next\":[\"action\"],\"getRecognizer\":[],\"process\":[]}};\n                   }\r\n","import { Type, InjectToken } from '@ts-ioc/core';\r\nimport { IPointcut, Joinpoint } from '../joinpoints';\r\n\r\n/**\r\n * Aop proxy method interface token.\r\n * it is a token id, you can register yourself IProxyMethod for this.\r\n */\r\nexport const ProxyMethodToken = new InjectToken<IProxyMethod>('DI_IProxyMethod');\r\n\r\n/**\r\n * proxy method, for proxy advice method.\r\n *\r\n * @export\r\n * @interface IProxyMethod\r\n */\r\nexport interface IProxyMethod {\r\n    /**\r\n     * proceed the proxy method.\r\n     *\r\n     * @param {*} target\r\n     * @param {Type<any>} targetType\r\n     * @param {IPointcut} pointcut\r\n     * @param {Joinpoint} [provJoinpoint]\r\n     * @memberof IProxyMethod\r\n     */\r\n    proceed(target: any, targetType: Type<any>, pointcut: IPointcut, provJoinpoint?: Joinpoint);\r\n}\r\n","import { IContainer, Provider, Singleton, Inject, Type, LifeScope, isFunction, ContainerToken } from '@ts-ioc/core';\r\nimport { Advices } from '../advices';\r\nimport { JoinpointState, IPointcut } from '../joinpoints';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { IAdvisor, AdvisorToken } from '../IAdvisor';\r\nimport { IProxyMethod, ProxyMethodToken } from './IProxyMethod';\r\nimport { AdvisorChainFactoryToken } from './IAdvisorChainFactory';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Singleton(ProxyMethodToken)\r\nexport class ProxyMethod implements IProxyMethod {\r\n\r\n    constructor(@Inject(ContainerToken) private container: IContainer) {\r\n\r\n    }\r\n\r\n    _advisor: IAdvisor;\r\n    get advisor(): IAdvisor {\r\n        if (!this._advisor) {\r\n            this._advisor = this.container.get(AdvisorToken);\r\n        }\r\n        return this._advisor;\r\n    }\r\n\r\n    _liefScope: LifeScope;\r\n    get liefScope(): LifeScope {\r\n        if (!this._liefScope) {\r\n            this._liefScope = this.container.getLifeScope();\r\n        }\r\n        return this._liefScope;\r\n    }\r\n\r\n    proceed(target: any, targetType: Type<any>, pointcut: IPointcut, provJoinpoint?: Joinpoint) {\r\n\r\n        let aspectMgr = this.advisor;\r\n        let fullName = pointcut.fullName;\r\n        let methodName = pointcut.name;\r\n\r\n        let advices = aspectMgr.getAdvices(fullName);\r\n        if (advices && pointcut) {\r\n            if (pointcut.descriptor && (pointcut.descriptor.get || pointcut.descriptor.set)) {\r\n                if (pointcut.descriptor.get) {\r\n                    let getMethod = pointcut.descriptor.get.bind(target);\r\n                    pointcut.descriptor.get = this.proxy(getMethod, advices, target, targetType, pointcut, provJoinpoint);\r\n                }\r\n                if (pointcut.descriptor.set) {\r\n                    let setMethod = pointcut.descriptor.set.bind(target);\r\n                    pointcut.descriptor.set = this.proxy(setMethod, advices, target, targetType, pointcut, provJoinpoint);\r\n                }\r\n                Object.defineProperty(target, methodName, pointcut.descriptor);\r\n            } else if (isFunction(target[methodName])) {\r\n                let propertyMethod = target[methodName].bind(target);\r\n                target[methodName] = this.proxy(propertyMethod, advices, target, targetType, pointcut, provJoinpoint);\r\n            }\r\n        }\r\n    }\r\n\r\n    proxy(propertyMethod: Function, advices: Advices, target: any, targetType: Type<any>, pointcut: IPointcut, provJoinpoint?: Joinpoint) {\r\n        let fullName = pointcut.fullName;\r\n        let methodName = pointcut.name;\r\n        let liefScope = this.liefScope;\r\n        let container = this.container;\r\n\r\n        return (...args: any[]) => {\r\n            let joinPoint = this.container.resolve(Joinpoint, Provider.create('options', {\r\n                name: methodName,\r\n                fullName: fullName,\r\n                provJoinpoint: provJoinpoint,\r\n                annotations: provJoinpoint ? null : liefScope.getMethodMetadatas(targetType, methodName),\r\n                params: liefScope.getMethodParameters(targetType, target, methodName),\r\n                args: args,\r\n                target: target,\r\n                targetType: targetType\r\n            }));\r\n\r\n            let adChain = container.resolve(AdvisorChainFactoryToken, { container: container, advisor: this.advisor, advices: advices });\r\n            adChain.invoaction(joinPoint, JoinpointState.Before);\r\n            adChain.invoaction(joinPoint, JoinpointState.Pointcut);\r\n            let val, exeErr;\r\n            try {\r\n                val = propertyMethod(...joinPoint.args);\r\n            } catch (err) {\r\n                exeErr = err;\r\n            }\r\n\r\n            adChain.invoaction(joinPoint, JoinpointState.After, val);\r\n            if (exeErr) {\r\n                adChain.invoaction(joinPoint, JoinpointState.AfterThrowing, exeErr);\r\n            } else {\r\n                adChain.invoaction(joinPoint, JoinpointState.AfterReturning, val);\r\n                return joinPoint.returning;\r\n            }\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ProxyMethod\",\"params\":{\"constructor\":[\"container\"],\"proceed\":[\"target\",\"targetType\",\"pointcut\",\"provJoinpoint\"],\"proxy\":[\"propertyMethod\",\"advices\",\"target\",\"targetType\",\"pointcut\",\"provJoinpoint\"]}};\n                   }\r\n","\r\n/**\r\n * Returning Type\r\n *\r\n * @export\r\n * @enum {number}\r\n */\r\nexport enum ReturningType {\r\n    /**\r\n     * it is a sync returning\r\n     */\r\n    sync = 'sync',\r\n\r\n    /**\r\n     * it is promise asyce returning\r\n     */\r\n    promise = 'promise',\r\n    /**\r\n     * it is observable asyce returning\r\n     */\r\n    observable = 'observable'\r\n}\r\n","import { Express, Singleton } from '@ts-ioc/core';\r\nimport { IAdvisorProceeding, AdvisorProceedingToken } from './IAdvisorProceeding';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { ReturningType } from './ReturningType';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Singleton(AdvisorProceedingToken, ReturningType.promise)\r\nexport class AsyncPromiseProceeding implements IAdvisorProceeding {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    proceeding(joinPoint: Joinpoint, ...actions: Express<Joinpoint, any>[]) {\r\n        if (joinPoint.returning) {\r\n            actions.forEach((action => {\r\n                joinPoint.returning = joinPoint.returning.then((val) => {\r\n                    joinPoint.returningValue = val;\r\n                    return Promise.resolve(action(joinPoint))\r\n                        .then(() => {\r\n                            return joinPoint.returningValue;\r\n                        });\r\n                });\r\n            }));\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AsyncPromiseProceeding\",\"params\":{\"constructor\":[],\"proceeding\":[\"joinPoint\",\"actions\"]}};\n                   }\r\n","import { isFunction, isObservable, isPromise, Express, Singleton } from '@ts-ioc/core';\r\nimport { IAdvisorProceeding, AdvisorProceedingToken } from './IAdvisorProceeding';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { ReturningType } from './ReturningType';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Singleton(AdvisorProceedingToken, ReturningType.observable)\r\nexport class AsyncObservableProceeding implements IAdvisorProceeding {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    proceeding(joinPoint: Joinpoint, ...actions: Express<Joinpoint, any>[]) {\r\n        if (isFunction(joinPoint.returning.flatMap)) {\r\n            actions.forEach(action => {\r\n                joinPoint.returning = joinPoint.returning.flatMap((val) => {\r\n                    joinPoint.returningValue = val;\r\n                    action(joinPoint);\r\n                    if (isObservable(joinPoint.returningValue)) {\r\n                        return joinPoint.returningValue;\r\n                    } else if (isPromise(joinPoint.returningValue)) {\r\n                        return joinPoint.returningValue;\r\n                    } else {\r\n                        return Promise.resolve(joinPoint.returningValue);\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            actions.forEach(action => {\r\n                action(joinPoint);\r\n            });\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AsyncObservableProceeding\",\"params\":{\"constructor\":[],\"proceeding\":[\"joinPoint\",\"actions\"]}};\n                   }\r\n","import { Singleton, IRecognizer, isPromise, isObservable, RecognizerToken } from '@ts-ioc/core';\r\nimport { ReturningType } from './ReturningType';\r\nimport { JoinpointState } from '../joinpoints';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Singleton(RecognizerToken, JoinpointState.AfterReturning)\r\nexport class ReturningRecognizer implements IRecognizer {\r\n    constructor() {\r\n\r\n    }\r\n\r\n    recognize(value: any): string {\r\n        if (isPromise(value)) {\r\n            return ReturningType.promise;\r\n        }\r\n\r\n        if (isObservable(value)) {\r\n            return ReturningType.observable;\r\n        }\r\n\r\n        return ReturningType.sync;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ReturningRecognizer\",\"params\":{\"constructor\":[],\"recognize\":[\"value\"]}};\n                   }\r\n","import { IAdvisorProceeding, AdvisorProceedingToken } from './IAdvisorProceeding';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { Express, Singleton } from '@ts-ioc/core';\r\nimport { ReturningType } from './ReturningType';\r\nimport { NonePointcut } from '../decorators';\r\n\r\n@NonePointcut()\r\n@Singleton(AdvisorProceedingToken, ReturningType.sync)\r\nexport class SyncProceeding implements IAdvisorProceeding {\r\n\r\n    proceeding(joinPoint: Joinpoint, ...actions: Express<Joinpoint, any>[]) {\r\n        joinPoint.returningValue = joinPoint.returning;\r\n        actions.forEach((action => {\r\n            action(joinPoint);\r\n        }))\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"SyncProceeding\",\"params\":{\"proceeding\":[\"joinPoint\",\"actions\"]}};\n                   }\r\n","export * from './IAdvisorChainFactory';\r\nexport * from './AdvisorChainFactory';\r\nexport * from './IAdvisorChain';\r\nexport * from './AdvisorChain';\r\nexport * from './IProxyMethod';\r\nexport * from './ProxyMethod';\r\n\r\nexport * from './AsyncPromiseProceeding';\r\nexport * from './AsyncObservableProceeding';\r\nexport * from './IAdvisorProceeding';\r\nexport * from './ReturningRecognizer';\r\nexport * from './ReturningType';\r\nexport * from './SyncProceeding';\r\n","\r\nimport { IContainer, ActionData, ActionComposite, getParamerterNames, isUndefined, getClassName, lang } from '@ts-ioc/core';\r\nimport { AopActions } from './AopActions';\r\nimport { IPointcut, Joinpoint } from '../joinpoints';\r\nimport { isValideAspectTarget } from '../isValideAspectTarget';\r\nimport { ProxyMethodToken } from '../access';\r\n\r\n\r\n/**\r\n * bind pointcut action data.\r\n *\r\n * @export\r\n * @interface BindPointcutActionData\r\n * @extends {ActionData<Joinpoint>}\r\n */\r\nexport interface BindPointcutActionData extends ActionData<Joinpoint> {\r\n}\r\n\r\n/**\r\n * bind method pointcut action.\r\n *\r\n * @export\r\n * @class BindMethodPointcutAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class BindMethodPointcutAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.bindMethodPointcut);\r\n    }\r\n\r\n    protected working(container: IContainer, data: BindPointcutActionData) {\r\n        // aspect class do nothing.\r\n        if (!data.target || !isValideAspectTarget(data.targetType)) {\r\n            return;\r\n        }\r\n        if (!container.hasRegister(ProxyMethodToken.toString())) {\r\n            return;\r\n        }\r\n\r\n        let proxy = container.get(ProxyMethodToken);\r\n\r\n        let target = data.target;\r\n        let targetType = data.targetType;\r\n\r\n        let className = getClassName(targetType);\r\n        let methods: IPointcut[] = [];\r\n        let decorators = Object.getOwnPropertyDescriptors(targetType.prototype);\r\n\r\n        lang.forIn(decorators, (item, name: string) => {\r\n            if (name === 'constructor') {\r\n                return;\r\n            }\r\n            methods.push({\r\n                name: name,\r\n                fullName: `${className}.${name}`,\r\n                descriptor: item\r\n            });\r\n        });\r\n\r\n        let allmethods = getParamerterNames(targetType);\r\n        lang.forIn(allmethods, (item, name: string) => {\r\n            if (name === 'constructor') {\r\n                return;\r\n            }\r\n            if (isUndefined(decorators[name])) {\r\n                methods.push({\r\n                    name: name,\r\n                    fullName: `${className}.${name}`\r\n                });\r\n            }\r\n        });\r\n\r\n\r\n        methods.forEach(pointcut => {\r\n            proxy.proceed(target, targetType, pointcut, target['_cache_JoinPoint']);\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"BindMethodPointcutAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","import { IContainer, ActionData, ActionComposite, Provider, getClassName, MethodAccessorToken, Providers } from '@ts-ioc/core';\r\nimport { AdvisorToken } from '../IAdvisor';\r\nimport { AopActions } from './AopActions';\r\nimport { AdviceMetadata } from '../metadatas'\r\nimport { Joinpoint, JoinpointState, IJoinpoint } from '../joinpoints';\r\nimport { isValideAspectTarget } from '../isValideAspectTarget';\r\n\r\n/**\r\n * action data for invoke before constructor action.\r\n *\r\n * @export\r\n * @interface InvokeBeforeConstructorActionData\r\n * @extends {ActionData<AdviceMetadata>}\r\n */\r\nexport interface InvokeBeforeConstructorActionData extends ActionData<AdviceMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * actions invoke before constructor.\r\n *\r\n * @export\r\n * @class InvokeBeforeConstructorAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class InvokeBeforeConstructorAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.registAspect);\r\n    }\r\n\r\n    protected working(container: IContainer, data: InvokeBeforeConstructorActionData) {\r\n        // aspect class do nothing.\r\n        if (!isValideAspectTarget(data.targetType)) {\r\n            return;\r\n        }\r\n\r\n        let advisor = container.get(AdvisorToken);\r\n        let className = getClassName(data.targetType);\r\n        let advices = advisor.getAdvices(className + '.constructor');\r\n        if (!advices) {\r\n            return;\r\n        }\r\n\r\n        let targetType = data.targetType;\r\n        let target = data.target;\r\n\r\n        let joinPoint = container.resolve(Joinpoint, Provider.create('options', <IJoinpoint>{\r\n            name: 'constructor',\r\n            state: JoinpointState.Before,\r\n            fullName: className + '.constructor',\r\n            target: target,\r\n            args: data.args,\r\n            params: data.params,\r\n            targetType: targetType\r\n        }));\r\n        let providers: Providers[] = [Provider.create(Joinpoint, joinPoint)];\r\n\r\n        if (data.providerMap) {\r\n            providers.push(data.providerMap);\r\n        }\r\n\r\n        advices.Before.forEach(advicer => {\r\n            advisor.getContainer(advicer.aspectType, container).syncInvoke(advicer.aspectType, advicer.advice.propertyKey, null, ...providers); // new Joinpoint(joinPoint) // container.resolve(Joinpoint, { json: joinPoint })\r\n        });\r\n\r\n        advices.Around.forEach(advicer => {\r\n            advisor.getContainer(advicer.aspectType, container).syncInvoke(advicer.aspectType, advicer.advice.propertyKey, null, ...providers);\r\n        });\r\n\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InvokeBeforeConstructorAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","import { IContainer, ActionData, ActionComposite, Provider, getClassName, Providers } from '@ts-ioc/core';\r\nimport { AdvisorToken } from '../IAdvisor';\r\nimport { AopActions } from './AopActions';\r\nimport { AdviceMetadata } from '../metadatas'\r\nimport { Joinpoint, JoinpointState, IJoinpoint } from '../joinpoints';\r\nimport { isValideAspectTarget } from '../isValideAspectTarget';\r\n\r\n/**\r\n * invoke after constructor action data.\r\n *\r\n * @export\r\n * @interface InvokeAfterConstructorActionData\r\n * @extends {ActionData<AdviceMetadata>}\r\n */\r\nexport interface InvokeAfterConstructorActionData extends ActionData<AdviceMetadata> {\r\n}\r\n\r\n/**\r\n * invoke after constructor action.\r\n *\r\n * @export\r\n * @class InvokeAfterConstructorAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class InvokeAfterConstructorAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.invokeAfterConstructorAdvices);\r\n    }\r\n\r\n    protected working(container: IContainer, data: InvokeAfterConstructorActionData) {\r\n        // aspect class do nothing.\r\n        if (!data.target || !isValideAspectTarget(data.targetType)) {\r\n            return;\r\n        }\r\n\r\n        let advisor = container.get(AdvisorToken);\r\n        let className = getClassName(data.targetType);\r\n        let advices = advisor.getAdvices(className + '.constructor');\r\n        if (!advices) {\r\n            return;\r\n        }\r\n        let targetType = data.targetType;\r\n        let target = data.target;\r\n\r\n        let joinPoint = container.resolve(Joinpoint, Provider.create('options', <IJoinpoint>{\r\n            name: 'constructor',\r\n            state: JoinpointState.After,\r\n            fullName: className + '.constructor',\r\n            target: target,\r\n            args: data.args,\r\n            params: data.params,\r\n            targetType: targetType\r\n        }));\r\n        let providers: Providers[] = [Provider.create(Joinpoint, joinPoint)];\r\n        if (data.providerMap) {\r\n            providers.push(data.providerMap);\r\n        }\r\n\r\n        advices.After.forEach(advicer => {\r\n            advisor.getContainer(advicer.aspectType, container).syncInvoke(advicer.aspectType, advicer.advice.propertyKey, null, ...providers);\r\n        });\r\n\r\n        advices.Around.forEach(advicer => {\r\n            advisor.getContainer(advicer.aspectType, container).syncInvoke(advicer.aspectType, advicer.advice.propertyKey, null, ...providers);\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"InvokeAfterConstructorAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","import { AdviceMetadata } from './metadatas';\r\nimport { MatchPointcut } from './joinpoints';\r\nimport { Type, ObjectMap, InjectToken } from '@ts-ioc/core';\r\n\r\n/**\r\n * Aop advice matcher interface token.\r\n * it is a token id, you can register yourself IActionBuilder for this.\r\n */\r\nexport const AdviceMatcherToken = new InjectToken<IAdviceMatcher>('DI_IAdviceMatcher');\r\n\r\n/**\r\n * advice match interface, use to match advice when a registered create instance.\r\n *\r\n * @export\r\n * @interface IAdviceMatcher\r\n */\r\nexport interface IAdviceMatcher {\r\n\r\n    /**\r\n     * match pointcuts of type.\r\n     *\r\n     * @param {Type<any>} aspectType\r\n     * @param {Type<any>} type\r\n     * @param {ObjectMap<AdviceMetadata[]>} [adviceMetas]\r\n     * @param {*} [instance]\r\n     * @returns {MatchPointcut[]}\r\n     * @memberof IAdviceMatcher\r\n     */\r\n    match(aspectType: Type<any>, type: Type<any>, adviceMetas?: ObjectMap<AdviceMetadata[]>, instance?: any): MatchPointcut[]\r\n}\r\n","\r\nimport {\r\n    IContainer, ActionData, ActionComposite, lang\r\n} from '@ts-ioc/core';\r\nimport { AdvisorToken } from '../IAdvisor';\r\nimport { AopActions } from './AopActions';\r\nimport { AdviceMetadata } from '../metadatas'\r\nimport { AdviceMatcherToken } from '../IAdviceMatcher';\r\nimport { Joinpoint } from '../joinpoints';\r\nimport { Advices, Advicer } from '../advices';\r\nimport { isValideAspectTarget } from '../isValideAspectTarget';\r\n\r\n\r\n/**\r\n * match pointcut action data.\r\n *\r\n * @export\r\n * @interface MatchPointcutActionData\r\n * @extends {ActionData<Joinpoint>}\r\n */\r\nexport interface MatchPointcutActionData extends ActionData<Joinpoint> {\r\n}\r\n\r\n/**\r\n *  match pointcut action.\r\n *\r\n * @export\r\n * @class MatchPointcutAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class MatchPointcutAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.matchPointcut);\r\n    }\r\n\r\n    protected working(container: IContainer, data: MatchPointcutActionData) {\r\n        // aspect class do nothing.\r\n        if (!isValideAspectTarget(data.targetType)) {\r\n            return;\r\n        }\r\n\r\n        let advisor = container.get(AdvisorToken);\r\n        let matcher = container.get(AdviceMatcherToken);\r\n        advisor.aspects.forEach((adviceMetas, type) => {\r\n            let matchpoints = matcher.match(type, data.targetType, adviceMetas, data.target);\r\n            matchpoints.forEach(mpt => {\r\n                let fullName = mpt.fullName;\r\n                let advice = mpt.advice;\r\n\r\n                let advices = advisor.getAdvices(fullName);\r\n                if (!advices) {\r\n                    advices = {\r\n                        Before: [],\r\n                        Pointcut: [],\r\n                        After: [],\r\n                        Around: [],\r\n                        AfterThrowing: [],\r\n                        AfterReturning: []\r\n                    } as Advices;\r\n                    advisor.setAdvices(fullName, advices);\r\n                }\r\n                let advicer = lang.assign(mpt, {\r\n                    aspectType: type\r\n                }) as Advicer;\r\n\r\n                if (advice.adviceName === 'Before') {\r\n                    if (!advices.Before.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.Before.push(advicer);\r\n                    }\r\n                } else if (advice.adviceName === 'Pointcut') {\r\n                    if (!advices.Pointcut.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.Pointcut.push(advicer);\r\n                    }\r\n                } else if (advice.adviceName === 'Around') {\r\n                    if (!advices.Around.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.Around.push(advicer);\r\n                    }\r\n                } else if (advice.adviceName === 'After') {\r\n                    if (!advices.After.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.After.push(advicer);\r\n                    }\r\n                } else if (advice.adviceName === 'AfterThrowing') {\r\n                    if (!advices.AfterThrowing.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.AfterThrowing.push(advicer);\r\n                    }\r\n                } else if (advice.adviceName === 'AfterReturning') {\r\n                    if (!advices.AfterReturning.some(a => this.isAdviceEquals(a.advice, advice))) {\r\n                        advices.AfterReturning.push(advicer);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    isAdviceEquals(advice1: AdviceMetadata, advice2: AdviceMetadata) {\r\n        if (!advice1 || !advice2) {\r\n            return false;\r\n        }\r\n        if (advice1 === advice2) {\r\n            return true;\r\n        }\r\n\r\n        return advice1.adviceName === advice2.adviceName\r\n            && advice1.pointcut === advice2.pointcut\r\n            && advice1.propertyKey === advice2.propertyKey;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"MatchPointcutAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"],\"isAdviceEquals\":[\"advice1\",\"advice2\"]}};\n                   }\r\n","import { ActionComponent } from '@ts-ioc/core';\r\nimport { AopActions } from './AopActions';\r\nimport { RegistAspectAction } from './RegistAspectAction';\r\nimport {\r\n    InvokeBeforeConstructorAction, InvokeAfterConstructorAction,\r\n    BindMethodPointcutAction, MatchPointcutAction, ExetndsInstanceAction\r\n} from '.';\r\n\r\n/**\r\n * aop action factory.\r\n *\r\n * @export\r\n * @class AopActionFactory\r\n */\r\nexport class AopActionFactory {\r\n\r\n    create(type: string): ActionComponent {\r\n        let action: ActionComponent;\r\n        switch (type) {\r\n            case AopActions.registAspect:\r\n                action = new RegistAspectAction();\r\n                break;\r\n\r\n            case AopActions.matchPointcut:\r\n                action = new MatchPointcutAction();\r\n                break;\r\n\r\n            case AopActions.invokeBeforeConstructorAdvices:\r\n                action = new InvokeBeforeConstructorAction();\r\n                break;\r\n\r\n            case AopActions.invokeAfterConstructorAdvices:\r\n                action = new InvokeAfterConstructorAction();\r\n                break;\r\n\r\n            case AopActions.bindMethodPointcut:\r\n                action = new BindMethodPointcutAction();\r\n                break;\r\n\r\n            // case AopActions.bindPropertyPointcut:\r\n            //     action = new BindPropertyPointcutAction();\r\n            //     break;\r\n\r\n            case AopActions.exetndsInstance:\r\n                action = new ExetndsInstanceAction();\r\n                break;\r\n\r\n        }\r\n        return action;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AopActionFactory\",\"params\":{\"create\":[\"type\"]}};\n                   }\r\n","import { IContainer, ActionData, ActionComposite, ExtendsProvider } from '@ts-ioc/core';\r\nimport { AopActions } from './AopActions';\r\nimport { AdviceMetadata } from '../metadatas';\r\n\r\n/**\r\n * extends instance action data.\r\n *\r\n * @export\r\n * @interface ExetndsInstanceActionData\r\n * @extends {ActionData<AdviceMetadata>}\r\n */\r\nexport interface ExetndsInstanceActionData extends ActionData<AdviceMetadata> {\r\n\r\n}\r\n\r\n/**\r\n * extends instance action.\r\n *\r\n * @export\r\n * @class ExetndsInstanceAction\r\n * @extends {ActionComposite}\r\n */\r\nexport class ExetndsInstanceAction extends ActionComposite {\r\n\r\n    constructor() {\r\n        super(AopActions.registAspect);\r\n    }\r\n\r\n    protected working(container: IContainer, data: ExetndsInstanceActionData) {\r\n        // aspect class do nothing.\r\n        if (!data.target || !data.providers || data.providers.length < 1) {\r\n            return;\r\n        }\r\n\r\n        data.providers.forEach(p => {\r\n            if (p && p instanceof ExtendsProvider) {\r\n                p.extends(data.target);\r\n            }\r\n        });\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"ExetndsInstanceAction\",\"params\":{\"constructor\":[],\"working\":[\"container\",\"data\"]}};\n                   }\r\n","export * from './AopActions';\r\nexport * from './RegistAspectAction';\r\nexport * from './BindMethodPointcutAction';\r\nexport * from './InvokeBeforeConstructorAction';\r\nexport * from './InvokeAfterConstructorAction';\r\n// export * from './BindPropertyPointcutAction';\r\nexport * from './MatchPointcutAction';\r\nexport * from './AopActionFactory';\r\nexport * from './ExetndsInstanceAction'\r\n","import {\r\n    IContainer, Singleton, getOwnMethodMetadata,\r\n    MapSet, Type, ObjectMap, getClassName, lang, Providers\r\n} from '@ts-ioc/core';\r\nimport { Advices } from './advices';\r\nimport { Advice, NonePointcut } from './decorators';\r\nimport { AdviceMetadata } from './metadatas';\r\nimport { IAdvisor, AdvisorToken } from './IAdvisor';\r\n\r\n/**\r\n * for global aop advisor.\r\n *\r\n * @export\r\n * @class Advisor\r\n */\r\n@NonePointcut()\r\n@Singleton(AdvisorToken)\r\nexport class Advisor implements IAdvisor {\r\n    /**\r\n     * aspects.\r\n     *\r\n     * @type {MapSet<Type<any>, ObjectMap<AdviceMetadata[]>>}\r\n     * @memberof AspectManager\r\n     */\r\n    aspects: MapSet<Type<any>, ObjectMap<AdviceMetadata[]>>;\r\n\r\n    protected aspectIocs: MapSet<Type<any>, IContainer>;\r\n    /**\r\n     * method advices.\r\n     *\r\n     * @type {MapSet<string, Advices>}\r\n     * @memberof AspectManager\r\n     */\r\n    advices: MapSet<string, Advices>;\r\n\r\n\r\n    constructor() {\r\n        this.aspects = new MapSet();\r\n        this.aspectIocs = new MapSet();\r\n        this.advices = new MapSet();\r\n    }\r\n\r\n    setAdvices(key: string, advices: Advices) {\r\n        if (!this.advices.has(key)) {\r\n            this.advices.set(key, advices);\r\n        }\r\n    }\r\n\r\n    getAdvices(key: string) {\r\n        if (!this.advices.has(key)) {\r\n            return null;\r\n        }\r\n        return this.advices.get(key);\r\n    }\r\n\r\n    hasRegisterAdvices(targetType: Type<any>): boolean {\r\n        let methods = lang.keys(Object.getOwnPropertyDescriptors(targetType.prototype));\r\n        let className = getClassName(targetType);\r\n        return methods.some(m => this.advices.has(`${className}.${m}`));\r\n    }\r\n\r\n    add(aspect: Type<any>, raiseContainer: IContainer) {\r\n        if (!this.aspects.has(aspect)) {\r\n            let metas = getOwnMethodMetadata<AdviceMetadata>(Advice, aspect);\r\n            this.aspects.set(aspect, metas);\r\n            this.aspectIocs.set(aspect, raiseContainer);\r\n        }\r\n    }\r\n\r\n    getContainer(aspect: Type<any>, defaultContainer?: IContainer): IContainer {\r\n        if (this.aspectIocs.has(aspect)) {\r\n            return this.aspectIocs.get(aspect) || defaultContainer;\r\n        }\r\n        return defaultContainer;\r\n    }\r\n\r\n    /**\r\n     * resolve aspect.\r\n     *\r\n     * @template T\r\n     * @param {Type<T>} aspect\r\n     * @param {...Providers[]} providers\r\n     * @returns {T}\r\n     * @memberof Advisor\r\n     */\r\n    resolve<T>(aspect: Type<T>, ...providers: Providers[]): T {\r\n        if (this.aspectIocs.has(aspect)) {\r\n            return this.aspectIocs.get(aspect).resolve(aspect, ...providers);\r\n        }\r\n        return null;\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"Advisor\",\"params\":{\"constructor\":[],\"setAdvices\":[\"key\",\"advices\"],\"getAdvices\":[\"key\"],\"hasRegisterAdvices\":[\"targetType\"],\"add\":[\"aspect\",\"raiseContainer\"],\"getContainer\":[\"aspect\",\"defaultContainer\"],\"resolve\":[\"aspect\",\"providers\"]}};\n                   }\r\n","import { IAdviceMatcher, AdviceMatcherToken } from './IAdviceMatcher';\r\nimport { AdviceMetadata, AspectMetadata } from './metadatas';\r\nimport {\r\n    Inject, getParamerterNames, getOwnMethodMetadata, hasOwnMethodMetadata, hasOwnClassMetadata, Singleton,\r\n    IContainer, isString, isRegExp, isUndefined, Type, ObjectMap, getClassName, lang, ContainerToken, getOwnTypeMetadata, isArray, isFunction\r\n} from '@ts-ioc/core';\r\nimport { IPointcut, MatchPointcut } from './joinpoints';\r\nimport { Aspect, Advice, NonePointcut } from './decorators';\r\n\r\n\r\nexport type MatchExpress = (method: string, fullName: string, targetType?: Type<any>, target?: any, pointcut?: IPointcut) => boolean\r\n/**\r\n * advice matcher, use to match advice when a registered create instance.\r\n *\r\n * @export\r\n * @class AdviceMatcher\r\n * @implements {IAdviceMatcher}\r\n */\r\n@NonePointcut()\r\n@Singleton(AdviceMatcherToken)\r\nexport class AdviceMatcher implements IAdviceMatcher {\r\n\r\n    constructor(@Inject(ContainerToken) private container: IContainer) {\r\n\r\n    }\r\n\r\n    match(aspectType: Type<any>, targetType: Type<any>, adviceMetas?: ObjectMap<AdviceMetadata[]>, target?: any): MatchPointcut[] {\r\n\r\n        let aspectMeta = lang.first(getOwnTypeMetadata<AspectMetadata>(Aspect, aspectType));\r\n        if (aspectMeta) {\r\n            if (aspectMeta.within) {\r\n                let ins = isArray(aspectMeta.within) ? aspectMeta.within : [aspectMeta.within];\r\n                if (ins.indexOf(targetType) < 0) {\r\n                    return [];\r\n                }\r\n            }\r\n            if (aspectMeta.annotation) {\r\n                let annotation = isFunction(aspectMeta.annotation) ? aspectMeta.annotation.toString() : aspectMeta.annotation;\r\n                let anno = (/^\\^?@\\w+/.test(annotation) ? '' : '@') + annotation;\r\n                if (!hasOwnClassMetadata(anno, targetType)) {\r\n                    return [];\r\n                }\r\n            }\r\n        }\r\n\r\n        let className = getClassName(targetType);\r\n        adviceMetas = adviceMetas || getOwnMethodMetadata<AdviceMetadata>(Advice, targetType);\r\n        // let advisor = this.container.get(AdvisorToken);\r\n        let matched: MatchPointcut[] = [];\r\n\r\n        if (targetType === aspectType) {\r\n            let adviceNames = lang.keys(adviceMetas);\r\n            if (adviceNames.length > 1) {\r\n                let advices: AdviceMetadata[] = [];\r\n                adviceNames.forEach(n => {\r\n                    advices = advices.concat(adviceMetas[n]);\r\n                });\r\n\r\n                adviceNames.forEach(n => {\r\n                    advices.forEach(adv => {\r\n                        if (adv.propertyKey !== n) {\r\n                            if (this.matchAspectSelf(n, adv)) {\r\n                                matched.push({\r\n                                    name: n,\r\n                                    fullName: `${className}.${n}`,\r\n                                    advice: adv\r\n                                });\r\n                            }\r\n                        }\r\n                    })\r\n                });\r\n            }\r\n        } else { // if (!advisor.hasRegisterAdvices(targetType)) {\r\n            let points: IPointcut[] = [];\r\n            let decorators = Object.getOwnPropertyDescriptors(targetType.prototype);\r\n            // match method.\r\n            for (let name in decorators) {\r\n                points.push({\r\n                    name: name,\r\n                    fullName: `${className}.${name}`\r\n                });\r\n            }\r\n\r\n            let allmethods = getParamerterNames(targetType);\r\n            lang.forIn(allmethods, (item, name: string) => {\r\n                if (name === 'constructor') {\r\n                    return;\r\n                }\r\n                if (isUndefined(decorators[name])) {\r\n                    points.push({\r\n                        name: name,\r\n                        fullName: `${className}.${name}`\r\n                    });\r\n                }\r\n            });\r\n\r\n            Object.getOwnPropertyNames(adviceMetas).forEach(name => {\r\n                let advices = adviceMetas[name];\r\n                advices.forEach(metadata => {\r\n                    matched = matched.concat(this.filterPointcut(targetType, points, metadata));\r\n                });\r\n            });\r\n        }\r\n\r\n        return matched;\r\n\r\n    }\r\n\r\n    protected matchAspectSelf(name: string, metadata: AdviceMetadata): boolean {\r\n        if (metadata.pointcut) {\r\n            let pointcut = metadata.pointcut;\r\n\r\n            if (isString(pointcut)) {\r\n                if (/^execution\\(\\S+\\)$/.test(pointcut)) {\r\n                    pointcut = pointcut.substring(10, pointcut.length - 1);\r\n                }\r\n                return pointcut.startsWith(name);\r\n            } else if (isRegExp(pointcut)) {\r\n                return pointcut.test(name);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    filterPointcut(type: Type<any>, points: IPointcut[], metadata: AdviceMetadata, target?: any): MatchPointcut[] {\r\n        if (!metadata.pointcut) {\r\n            return [];\r\n        }\r\n        let matchedPointcut;\r\n        if (metadata.pointcut) {\r\n            let match = this.matchTypeFactory(type, metadata);\r\n            matchedPointcut = points.filter(p => match(p.name, p.fullName, type, target, p))\r\n        }\r\n\r\n        matchedPointcut = matchedPointcut || [];\r\n        return matchedPointcut.map(p => {\r\n            return lang.assign({}, p, { advice: metadata });\r\n        });\r\n    }\r\n\r\n    protected matchTypeFactory(type: Type<any>, metadata: AdviceMetadata): MatchExpress {\r\n        let pointcut = metadata.pointcut;\r\n        let expresses: (MatchExpress | string)[] = [];\r\n        if (metadata.within) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>) => {\r\n                if (isArray(metadata.within)) {\r\n                    return metadata.within.indexOf(targetType) >= 0;\r\n                } else {\r\n                    return metadata.within === targetType;\r\n                }\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n        if (metadata.target) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>, target?: any) => {\r\n                return metadata.target = target;\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n\r\n        if (metadata.annotation) {\r\n            expresses.push((method: string, fullName: string, targetType?: Type<any>, target?: any) => {\r\n                return hasOwnMethodMetadata(metadata.annotation, targetType, method);\r\n            });\r\n            expresses.push('&&')\r\n        }\r\n        if (isString(pointcut)) {\r\n            let pointcuts = (pointcut || '').trim();\r\n            expresses.push(this.tranlateExpress(type, pointcuts));\r\n        } else if (isRegExp(pointcut)) {\r\n            let pointcutReg = pointcut;\r\n            if (/^\\^?@\\w+/.test(pointcutReg.source)) {\r\n                expresses.push((name: string, fullName: string, targetType?: Type<any>) => {\r\n                    let decName = Reflect.getMetadataKeys(type, name);\r\n                    return decName.some(n => isString(n) && pointcutReg.test(n));\r\n                });\r\n\r\n            } else {\r\n                expresses.push((name: string, fullName: string) => pointcutReg.test(fullName));\r\n            }\r\n        }\r\n        return this.mergeExpress(...expresses);\r\n    }\r\n\r\n    protected spiltBrace(strExp: string) {\r\n        strExp = strExp.trim();\r\n\r\n        if (/^\\(/.test(strExp) && /\\)$/.test(strExp)) {\r\n            strExp = strExp.substring(1, strExp.length - 1).trim();\r\n        }\r\n\r\n        if (/^\\(/.test(strExp) && /\\)$/.test(strExp)) {\r\n            return this.spiltBrace(strExp);\r\n        } else {\r\n            return strExp;\r\n        }\r\n    }\r\n\r\n    protected expressToFunc(type: Type<any>, strExp: string): MatchExpress {\r\n        if (/^@annotation\\(.*\\)$/.test(strExp)) {\r\n            let exp = strExp.substring(12, strExp.length - 1);\r\n            let annotation = /^@/.test(exp) ? exp : ('@' + exp);\r\n            return (name: string, fullName: string) => hasOwnMethodMetadata(annotation, type, name) && !hasOwnClassMetadata(Aspect, type);\r\n\r\n        } else if (/^execution\\(.*\\)$/.test(strExp)) {\r\n            let exp = strExp.substring(10, strExp.length - 1);\r\n            if (exp === '*' || exp === '*.*') {\r\n                return (name: string, fullName: string) => !!name && !hasOwnClassMetadata(Aspect, type);\r\n            } else if (/^\\w+(\\((\\s*\\w+\\s*,)*\\s*\\w*\\))?$/.test(exp)) {\r\n                // if is method name, will match aspect self only.\r\n                return () => false;\r\n            } else if (/^([\\w\\*]+\\.)+[\\w\\*]+(\\((\\s*\\w+\\s*,)*\\s*\\w*\\))?$/.test(exp)) {\r\n                exp = exp.replace(/\\*\\*/gi, '(\\\\\\w+(\\\\\\.|\\\\\\/)){0,}\\\\\\w+')\r\n                    .replace(/\\*/gi, '\\\\\\w+')\r\n                    .replace(/\\./gi, '\\\\\\.')\r\n                    .replace(/\\//gi, '\\\\\\/');\r\n\r\n                let matcher = new RegExp(exp + \"$\");\r\n                return (name: string, fullName: string) => matcher.test(fullName);\r\n            } else {\r\n                return () => false;\r\n            }\r\n        } else if (/^@within\\(\\s*\\w+/.test(strExp)) {\r\n            let classnames = strExp.substring(strExp.indexOf('(') + 1, strExp.length - 1).split(',').map(n => n.trim());\r\n            return (name: string, fullName: string, targetType?: Type<any>) => classnames.indexOf(getClassName(targetType)) >= 0;\r\n        } else if (/^@target\\(\\s*\\w+/.test(strExp)) {\r\n            let torken = strExp.substring(strExp.indexOf('(') + 1, strExp.length - 1).trim();\r\n            return (name: string, fullName: string, targetType?: Type<any>) => this.container.getTokenImpl(torken) === targetType;\r\n        } else {\r\n            return () => false;\r\n        }\r\n    }\r\n\r\n    protected tranlateExpress(type: Type<any>, strExp: string): MatchExpress {\r\n        let expresses: ((MatchExpress) | string)[] = [];\r\n\r\n        let idxOr = strExp.indexOf('||');\r\n        let idxAd = strExp.indexOf('&&');\r\n        if (idxAd < 0 && idxOr < 0) {\r\n            expresses.push(this.expressToFunc(type, this.spiltBrace(strExp)))\r\n        } else {\r\n            if (idxOr > idxAd) {\r\n                let leftExp = this.spiltBrace(strExp.substring(0, idxOr));\r\n                if (leftExp) {\r\n                    expresses.push(this.tranlateExpress(type, leftExp));\r\n                }\r\n                let rightExp = this.spiltBrace(strExp.substring(idxOr + 2));\r\n                if (rightExp) {\r\n                    expresses.push('||');\r\n                    expresses.push(this.tranlateExpress(type, rightExp));\r\n                }\r\n            } else if (idxAd > idxOr) {\r\n                let leftExp = this.spiltBrace(strExp.substring(0, idxAd));\r\n                if (leftExp) {\r\n                    expresses.push(this.tranlateExpress(type, leftExp));\r\n                }\r\n                let rightExp = this.spiltBrace(strExp.substring(idxAd + 2));\r\n                if (rightExp) {\r\n                    expresses.push('&&');\r\n                    expresses.push(this.tranlateExpress(type, rightExp));\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.mergeExpress(...expresses);\r\n    }\r\n\r\n\r\n    protected mergeExpress(...expresses: (MatchExpress | string)[]): MatchExpress {\r\n        return (method: string, fullName: string, targetType?: Type<any>, pointcut?: IPointcut) => {\r\n            let flag;\r\n            expresses.forEach((express, idx) => {\r\n                if (!isUndefined(flag)) {\r\n                    return;\r\n                }\r\n                if (isFunction(express)) {\r\n                    let rel = express(method, fullName, targetType, pointcut);\r\n                    if (idx < expresses.length - 2) {\r\n                        if (!rel && express[idx + 1] === '&&') {\r\n                            flag = false;\r\n                        }\r\n                        if (rel && express[idx + 1] === '||') {\r\n                            flag = true;\r\n                        }\r\n                    } else {\r\n                        flag = rel;\r\n                    }\r\n                }\r\n\r\n            });\r\n            return flag;\r\n        }\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AdviceMatcher\",\"params\":{\"constructor\":[\"container\"],\"match\":[\"aspectType\",\"targetType\",\"adviceMetas\",\"target\"],\"matchAspectSelf\":[\"name\",\"metadata\"],\"filterPointcut\":[\"type\",\"points\",\"metadata\",\"target\"],\"matchTypeFactory\":[\"type\",\"metadata\"],\"spiltBrace\":[\"strExp\"],\"expressToFunc\":[\"type\",\"strExp\"],\"tranlateExpress\":[\"type\",\"strExp\"],\"mergeExpress\":[\"expresses\"]}};\n                   }\r\n","import { IContainer, IocState, LifeState, Inject, ContainerToken, LifeScopeToken, IocExt } from '@ts-ioc/core';\r\nimport { Aspect } from './decorators';\r\nimport { Advisor } from './Advisor';\r\nimport { AopActions } from './actions';\r\nimport { AdviceMatcher } from './AdviceMatcher';\r\nimport { AopActionFactory } from './actions/AopActionFactory';\r\nimport { Joinpoint } from './joinpoints';\r\nimport { ProxyMethod, AdvisorChainFactory, AdvisorChain, SyncProceeding, AsyncObservableProceeding, AsyncPromiseProceeding, ReturningRecognizer } from './access';\r\n\r\n\r\n/**\r\n * aop ext for ioc. auto run setup after registered.\r\n * with @IocExt('setup') decorator.\r\n * @export\r\n * @class AopModule\r\n */\r\n@IocExt('setup')\r\nexport class AopModule {\r\n\r\n    constructor(@Inject(ContainerToken) private container: IContainer) {\r\n\r\n    }\r\n\r\n    /**\r\n     * register aop for container.\r\n     *\r\n     * @memberof AopModule\r\n     */\r\n    setup() {\r\n        let container = this.container;\r\n        container.register(Joinpoint);\r\n        container.register(AdvisorChainFactory);\r\n        container.register(ReturningRecognizer);\r\n        container.register(SyncProceeding);\r\n        container.register(AsyncPromiseProceeding);\r\n        container.register(AsyncObservableProceeding);\r\n        container.register(AdvisorChain);\r\n        container.register(ProxyMethod);\r\n        container.register(Advisor);\r\n        container.register(AdviceMatcher);\r\n\r\n\r\n        let lifeScope = container.get(LifeScopeToken);\r\n\r\n        let factory = new AopActionFactory();\r\n        lifeScope.addAction(factory.create(AopActions.registAspect), IocState.design);\r\n        lifeScope.addAction(factory.create(AopActions.matchPointcut), IocState.runtime, LifeState.beforeConstructor);\r\n        lifeScope.addAction(factory.create(AopActions.bindMethodPointcut), IocState.runtime, LifeState.AfterInit);\r\n\r\n        lifeScope.addAction(factory.create(AopActions.invokeBeforeConstructorAdvices), IocState.runtime, LifeState.beforeConstructor);\r\n        lifeScope.addAction(factory.create(AopActions.exetndsInstance), IocState.runtime, LifeState.onInit, LifeState.afterConstructor);\r\n        lifeScope.addAction(factory.create(AopActions.invokeAfterConstructorAdvices), IocState.runtime, LifeState.afterConstructor);\r\n\r\n\r\n        lifeScope.registerDecorator(Aspect, AopActions.registAspect, AopActions.exetndsInstance);\r\n\r\n    }\r\n\n                        static classAnnations:any  = {\"name\":\"AopModule\",\"params\":{\"constructor\":[\"container\"],\"setup\":[]}};\n                   }\r\n","export * from './actions';\r\nexport * from './decorators';\r\nexport * from './metadatas';\r\nexport * from './joinpoints';\r\nexport * from './advices';\r\nexport * from './access';\r\n\r\nexport * from './IAdvisor';\r\nexport * from './Advisor';\r\nexport * from './AdviceMatcher';\r\nexport * from './isValideAspectTarget';\r\nexport * from './AopModule';\r\n\r\n"],"names":["IAdvisor_1","Advice_1","decorators_1","IJoinpoint_1","joinpoints_1","IAdvisorChain_1","IAdvisorChainFactory_1","IAdvisorProceeding_1","IProxyMethod_1","access_1","IAdviceMatcher_1","_1","decorators","actions_1"],"mappings":"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"}